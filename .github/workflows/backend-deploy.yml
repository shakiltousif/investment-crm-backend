name: Backend Deployment

on:
  push:
    branches:
      - main
      - master
    paths:
      - 'backend/**'
      - 'backend/.github/workflows/backend-deploy.yml'
  pull_request:
    branches:
      - main
      - master
    paths:
      - 'backend/**'
      - 'backend/.github/workflows/backend-deploy.yml'
  workflow_dispatch:

env:
  NODE_VERSION: '20'

jobs:
  test:
    name: Test Backend
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: investment_crm_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        id: setup-node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: package-lock.json
        continue-on-error: true

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npm run db:generate
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/investment_crm_test

      - name: Run database migrations
        run: npx prisma migrate deploy
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/investment_crm_test

      - name: Run linter
        run: npm run lint

      - name: Type check
        run: npm run type-check

      - name: Run tests
        run: npm test
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/investment_crm_test
          NODE_ENV: test
          JWT_SECRET: test-secret-key

  build:
    name: Build Backend
    runs-on: ubuntu-latest
    needs: test
    if: |
      always() &&
      (needs.test.result == 'success' || needs.test.result == 'skipped') &&
      ((github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')) ||
       (github.event_name == 'workflow_dispatch' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')))
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify package-lock.json exists
        run: |
          if [ ! -f package-lock.json ]; then
            echo "Warning: package-lock.json not found, cache will be skipped"
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npm run db:generate

      - name: Build application
        run: npm run build

      - name: Create deployment package
        run: |
          mkdir -p deploy
          cp -r dist deploy/
          cp -r prisma deploy/
          cp package.json deploy/
          cp package-lock.json deploy/
          tar -czf backend-deploy.tar.gz -C deploy .
          rm -rf deploy

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: backend-build
          path: backend-deploy.tar.gz
          retention-days: 1

  pre-deploy-check:
    name: Pre-Deployment Validation
    runs-on: ${{ vars.USE_SELF_HOSTED_RUNNER == 'true' && 'self-hosted' || 'ubuntu-latest' }}
    needs: build
    if: |
      (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')) ||
      (github.event_name == 'workflow_dispatch' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'))
    
    env:
      USE_SELF_HOSTED: ${{ vars.USE_SELF_HOSTED_RUNNER == 'true' }}
      WORKSPACE_PATH: $WORKSPACE_PATH
      DEPLOY_PATH: ${{ secrets.BACKEND_DEPLOY_PATH || '/var/www/investment-crm/backend' }}
    
    steps:
      - name: Setup SSH (for GitHub-hosted runners only)
        if: env.USE_SELF_HOSTED != 'true'
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts (for GitHub-hosted runners only)
        if: env.USE_SELF_HOSTED != 'true'
        run: |
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Setup environment for self-hosted runner
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          echo "âœ… Running on self-hosted runner - no SSH needed"
          [ -f /etc/profile ] && source /etc/profile
          [ -f ~/.bashrc ] && source ~/.bashrc
          [ -f ~/.bash_profile ] && source ~/.bash_profile
          [ -f ~/.profile ] && source ~/.profile
          export PATH="/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin:$PATH"
          export PATH="$HOME/.nvm/versions/node/*/bin:$PATH"
          export PATH="/opt/nodejs/bin:$PATH"

      - name: Validate Node.js (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          echo "ðŸ“¦ Checking Node.js installation..."
          echo "Current user: $(whoami)"
          echo "Current PATH: $PATH"
          
          NODE_CMD=""
          if [ -d /opt/nodejs/bin ]; then
            echo "Checking /opt/nodejs/bin directory..."
            ls -la /opt/nodejs/bin/ 2>/dev/null | head -10 || echo "Cannot list /opt/nodejs/bin"
            if [ -f /opt/nodejs/bin/node ]; then
              if [ -x /opt/nodejs/bin/node ]; then
                NODE_CMD="/opt/nodejs/bin/node"
                echo "âœ… Found executable node in /opt/nodejs/bin"
              else
                echo "âš ï¸  Found node in /opt/nodejs/bin but not executable"
                if sudo chmod +x /opt/nodejs/bin/node 2>/dev/null; then
                  NODE_CMD="/opt/nodejs/bin/node"
                  echo "âœ… Made node executable"
                fi
              fi
            fi
          fi
          
          if [ -z "$NODE_CMD" ]; then
            if command -v node &> /dev/null; then
              NODE_CMD="node"
              echo "âœ… Found node via command -v"
            elif [ -f /usr/local/bin/node ]; then
              NODE_CMD="/usr/local/bin/node"
              echo "âœ… Found node in /usr/local/bin"
            elif [ -f /usr/bin/node ]; then
              NODE_CMD="/usr/bin/node"
              echo "âœ… Found node in /usr/bin"
            fi
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            if [ -d /root/.nvm/versions/node ]; then
              NODE_CMD=$(find /root/.nvm/versions/node -name node -type f -executable 2>/dev/null | sort -V | tail -1)
            fi
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            if [ -d "$HOME/.nvm/versions/node" ]; then
              NODE_CMD=$(find "$HOME/.nvm/versions/node" -name node -type f -executable 2>/dev/null | sort -V | tail -1)
            fi
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            NODE_CMD=$(find /usr/local/bin /usr/bin /opt /root/.nvm /root/.local /root/bin -name node -type f -executable 2>/dev/null | head -1)
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            ROOT_NODE=$(sudo sh -c 'command -v node' 2>/dev/null || echo "")
            if [ -z "$ROOT_NODE" ]; then
              ROOT_NODE=$(sudo -n sh -c 'command -v node' 2>/dev/null || echo "")
            fi
            if [ -n "$ROOT_NODE" ] && [ -f "$ROOT_NODE" ]; then
              NODE_CMD="$ROOT_NODE"
              echo "Found node via root's PATH: $NODE_CMD"
            fi
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            if [ -f /root/.bashrc ]; then
              ROOT_NVM_DIR=$(grep -o 'NVM_DIR="[^"]*"' /root/.bashrc 2>/dev/null | cut -d'"' -f2 || echo "")
              if [ -n "$ROOT_NVM_DIR" ] && [ -d "$ROOT_NVM_DIR/versions/node" ]; then
                NODE_CMD=$(find "$ROOT_NVM_DIR/versions/node" -name node -type f -executable 2>/dev/null | sort -V | tail -1)
              fi
            fi
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            ROOT_NODE_PATH=$(sudo sh -c 'which node 2>&1' 2>/dev/null | grep -v "not found" | head -1 || echo "")
            if [ -n "$ROOT_NODE_PATH" ] && [ "$ROOT_NODE_PATH" != "" ]; then
              if sudo test -f "$ROOT_NODE_PATH" 2>/dev/null; then
                echo "âœ… Found Node.js at: $ROOT_NODE_PATH (requires sudo)"
                NODE_CMD="$ROOT_NODE_PATH"
                echo "USE_SUDO_FOR_NODE=1" >> $GITHUB_ENV
                echo "âœ… Will use sudo for all Node.js/npm commands"
              fi
            fi
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            ROOT_NODE_PATH=$(sudo sh -c 'which node 2>&1' 2>/dev/null | grep -v "not found" | head -1 || echo "")
            if [ -n "$ROOT_NODE_PATH" ] && sudo test -f "$ROOT_NODE_PATH" 2>/dev/null; then
              echo "Found Node.js at: $ROOT_NODE_PATH"
              if sudo ln -sf "$ROOT_NODE_PATH" /usr/local/bin/node 2>/dev/null; then
                sudo chmod +x /usr/local/bin/node 2>/dev/null
                if [ -f /usr/local/bin/node ] && [ -x /usr/local/bin/node ]; then
                  NODE_CMD="/usr/local/bin/node"
                  echo "âœ… Symlink created successfully"
                fi
              fi
            fi
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            echo "âŒ Node.js is not installed on the server or not accessible"
            exit 1
          fi
          
          if [ ! -x "$NODE_CMD" ]; then
            if sudo chmod +x "$NODE_CMD" 2>/dev/null; then
              echo "âœ… Made Node.js executable"
            else
              echo "âŒ Node.js found at $NODE_CMD but cannot be executed"
              exit 1
            fi
          fi
          
          if [ "${USE_SUDO_FOR_NODE:-}" = "1" ]; then
            NODE_VERSION=$(sudo $NODE_CMD --version 2>/dev/null || echo "unknown")
          else
            NODE_VERSION=$($NODE_CMD --version 2>/dev/null || sudo $NODE_CMD --version 2>/dev/null || echo "unknown")
          fi
          echo "âœ… Node.js found at: $NODE_CMD"
          echo "âœ… Node.js version: $NODE_VERSION"
          echo "NODE_CMD=$NODE_CMD" >> $GITHUB_ENV

      - name: Validate npm (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          echo "ðŸ“¦ Checking npm installation..."
          NPM_CMD=""
          if [ -f /opt/nodejs/bin/npm ] && [ -x /opt/nodejs/bin/npm ]; then
            NPM_CMD="/opt/nodejs/bin/npm"
          elif command -v npm &> /dev/null; then
            NPM_CMD="npm"
          elif [ -f /usr/local/bin/npm ]; then
            NPM_CMD="/usr/local/bin/npm"
          elif [ -f /usr/bin/npm ]; then
            NPM_CMD="/usr/bin/npm"
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            if [ -n "$NODE_CMD" ] && [ -d "$(dirname "$NODE_CMD")" ]; then
              NPM_CMD="$(dirname "$NODE_CMD")/npm"
              [ ! -f "$NPM_CMD" ] && NPM_CMD=""
            elif [ -d /root/.nvm/versions/node ]; then
              NPM_CMD=$(find /root/.nvm/versions/node -name npm -type f -executable 2>/dev/null | sort -V | tail -1)
            fi
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            if [ -d "$HOME/.nvm/versions/node" ]; then
              NPM_CMD=$(find "$HOME/.nvm/versions/node" -name npm -type f -executable 2>/dev/null | sort -V | tail -1)
            fi
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            NPM_CMD=$(find /usr/local/bin /usr/bin /opt /root/.nvm /root/.local /root/bin -name npm -type f -executable 2>/dev/null | head -1)
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            ROOT_NPM=$(sudo sh -c 'command -v npm' 2>/dev/null || echo "")
            [ -z "$ROOT_NPM" ] && ROOT_NPM=$(sudo -n sh -c 'command -v npm' 2>/dev/null || echo "")
            if [ -n "$ROOT_NPM" ] && [ -f "$ROOT_NPM" ]; then
              NPM_CMD="$ROOT_NPM"
            fi
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            if [ -f /root/.bashrc ]; then
              ROOT_NVM_DIR=$(grep -o 'NVM_DIR="[^"]*"' /root/.bashrc 2>/dev/null | cut -d'"' -f2 || echo "")
              if [ -n "$ROOT_NVM_DIR" ] && [ -d "$ROOT_NVM_DIR/versions/node" ]; then
                NPM_CMD=$(find "$ROOT_NVM_DIR/versions/node" -name npm -type f -executable 2>/dev/null | sort -V | tail -1)
              fi
            fi
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            ROOT_NPM_PATH=$(sudo sh -c 'which npm 2>&1' 2>/dev/null | grep -v "not found" | head -1 || echo "")
            if [ -n "$ROOT_NPM_PATH" ] && [ "$ROOT_NPM_PATH" != "" ]; then
              if sudo test -f "$ROOT_NPM_PATH" 2>/dev/null; then
                echo "âœ… Found npm at: $ROOT_NPM_PATH (requires sudo)"
                NPM_CMD="$ROOT_NPM_PATH"
                if [ "${USE_SUDO_FOR_NODE:-}" != "1" ]; then
                  echo "USE_SUDO_FOR_NODE=1" >> $GITHUB_ENV
                fi
              fi
            fi
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            ROOT_NPM_PATH=$(sudo sh -c 'which npm 2>&1' 2>/dev/null | grep -v "not found" | head -1 || echo "")
            if [ -n "$ROOT_NPM_PATH" ] && sudo test -f "$ROOT_NPM_PATH" 2>/dev/null; then
              if sudo ln -sf "$ROOT_NPM_PATH" /usr/local/bin/npm 2>/dev/null; then
                sudo chmod +x /usr/local/bin/npm 2>/dev/null
                if [ -f /usr/local/bin/npm ] && [ -x /usr/local/bin/npm ]; then
                  NPM_CMD="/usr/local/bin/npm"
                fi
              fi
            fi
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            echo "âŒ npm is not installed on the server or not accessible"
            exit 1
          fi
          
          if [ ! -x "$NPM_CMD" ]; then
            if sudo chmod +x "$NPM_CMD" 2>/dev/null; then
              echo "âœ… Made npm executable"
            else
              echo "âŒ npm found at $NPM_CMD but cannot be executed"
              exit 1
            fi
          fi
          
          if [ "${USE_SUDO_FOR_NODE:-}" = "1" ]; then
            NPM_VERSION=$(sudo $NPM_CMD --version 2>/dev/null || echo "unknown")
          else
            NPM_VERSION=$($NPM_CMD --version 2>/dev/null || sudo $NPM_CMD --version 2>/dev/null || echo "unknown")
          fi
          echo "âœ… npm found at: $NPM_CMD"
          echo "âœ… npm version: $NPM_VERSION"
          echo "NPM_CMD=$NPM_CMD" >> $GITHUB_ENV

      - name: Validate deployment directory and Docker (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          echo "ðŸ“ Checking deployment directory..."
          DEPLOY_PATH="$DEPLOY_PATH"
          if [ ! -d "$DEPLOY_PATH" ]; then
            mkdir -p "$DEPLOY_PATH/releases"
            mkdir -p "$DEPLOY_PATH/shared"
          fi
          if [ ! -w "$DEPLOY_PATH" ]; then
            echo "âŒ Deployment directory is not writable"
            exit 1
          fi
          echo "âœ… Deployment directory is ready"
          
          echo "ðŸ” Checking environment configuration..."
          if [ -n "${{ secrets.BACKEND_ENV_FILE }}" ]; then
            echo "âœ… BACKEND_ENV_FILE secret is set"
          elif [ -f "$DEPLOY_PATH/shared/.env" ]; then
            echo "âœ… Shared .env file found"
          else
            echo "âŒ No .env file found"
            exit 1
          fi
          
          echo "ðŸ³ Checking Docker and services..."
          if command -v docker &> /dev/null; then
            echo "âœ… Docker is installed"
            if command -v docker-compose &> /dev/null; then
              DOCKER_COMPOSE_CMD="docker-compose"
            elif docker compose version &> /dev/null; then
              DOCKER_COMPOSE_CMD="docker compose"
            else
              if command -v apt-get &> /dev/null; then
                sudo apt-get update && sudo apt-get install -y docker-compose-plugin 2>/dev/null || true
                DOCKER_COMPOSE_CMD="docker compose"
              fi
            fi
            
            if [ -n "$DOCKER_COMPOSE_CMD" ]; then
              # Check workspace root first (backend and frontend are separate repos)
              if [ -f "$WORKSPACE_PATH/docker-compose.yml" ]; then
                DOCKER_COMPOSE_FILE="$WORKSPACE_PATH/docker-compose.yml"
                DOCKER_COMPOSE_DIR="$WORKSPACE_PATH"
              elif [ -f "$DEPLOY_PATH/docker-compose.yml" ]; then
                DOCKER_COMPOSE_FILE="$DEPLOY_PATH/docker-compose.yml"
                DOCKER_COMPOSE_DIR="$DEPLOY_PATH"
              elif [ -f "$DEPLOY_PATH/current/docker-compose.yml" ]; then
                DOCKER_COMPOSE_FILE="$DEPLOY_PATH/current/docker-compose.yml"
                DOCKER_COMPOSE_DIR="$DEPLOY_PATH/current"
              fi
              
              if [ -n "$DOCKER_COMPOSE_FILE" ]; then
                cd "$DOCKER_COMPOSE_DIR"
                POSTGRES_RUNNING=$(docker ps --filter "name=investment_crm_db" --filter "status=running" --format "{{.Names}}" 2>/dev/null | grep -c "investment_crm_db" || echo "0")
                REDIS_RUNNING=$(docker ps --filter "name=investment_crm_redis" --filter "status=running" --format "{{.Names}}" 2>/dev/null | grep -c "investment_crm_redis" || echo "0")
                
                if [ "$POSTGRES_RUNNING" = "0" ] || [ "$REDIS_RUNNING" = "0" ]; then
                  echo "ðŸš€ Starting Docker services..."
                  if [ "${USE_SUDO_FOR_NODE:-}" = "1" ]; then
                    sudo $DOCKER_COMPOSE_CMD up -d postgres redis 2>&1 || $DOCKER_COMPOSE_CMD up -d postgres redis 2>&1 || exit 1
                  else
                    $DOCKER_COMPOSE_CMD up -d postgres redis 2>&1 || exit 1
                  fi
                  sleep 3
                  
                  RETRY_COUNT=0
                  while [ $RETRY_COUNT -lt 30 ]; do
                    if docker exec investment_crm_db pg_isready -U postgres &> /dev/null 2>&1; then
                      echo "âœ… PostgreSQL is ready"
                      break
                    fi
                    RETRY_COUNT=$((RETRY_COUNT + 1))
                    [ $((RETRY_COUNT % 5)) -eq 0 ] && echo "  Still waiting... ($RETRY_COUNT/30)"
                    sleep 2
                  done
                  
                  RETRY_COUNT=0
                  while [ $RETRY_COUNT -lt 30 ]; do
                    if docker exec investment_crm_redis redis-cli ping &> /dev/null 2>&1; then
                      echo "âœ… Redis is ready"
                      break
                    fi
                    RETRY_COUNT=$((RETRY_COUNT + 1))
                    [ $((RETRY_COUNT % 5)) -eq 0 ] && echo "  Still waiting... ($RETRY_COUNT/30)"
                    sleep 2
                  done
                else
                  echo "âœ… Docker services are already running"
                fi
              fi
            fi
          fi
          
          if command -v psql &> /dev/null; then
            echo "âœ… PostgreSQL client is installed"
          fi
          
          if command -v pm2 &> /dev/null; then
            echo "âœ… Process manager found: pm2"
          elif command -v systemctl &> /dev/null; then
            echo "âœ… Process manager found: systemd"
          fi

      - name: Validate server prerequisites (GitHub-hosted)
        if: env.USE_SELF_HOSTED != 'true'
        run: |
          echo "ðŸ“¡ Testing SSH connection..."
          ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "echo 'SSH connection successful'" || {
            echo "âŒ SSH connection failed"
            exit 1
          }
          
          NODE_VERSION=$(ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "node --version 2>/dev/null || echo 'not_installed'")
          if [ "$NODE_VERSION" = "not_installed" ]; then
            echo "âŒ Node.js is not installed on the server"
            exit 1
          fi
          echo "âœ… Node.js version: $NODE_VERSION"
          
          NPM_VERSION=$(ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "npm --version 2>/dev/null || echo 'not_installed'")
          if [ "$NPM_VERSION" = "not_installed" ]; then
            echo "âŒ npm is not installed on the server"
            exit 1
          fi
          echo "âœ… npm version: $NPM_VERSION"
          
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
            if [ ! -d '${{ secrets.BACKEND_DEPLOY_PATH }}' ]; then
              mkdir -p '${{ secrets.BACKEND_DEPLOY_PATH }}/releases'
              mkdir -p '${{ secrets.BACKEND_DEPLOY_PATH }}/shared'
            fi
            if [ ! -w '${{ secrets.BACKEND_DEPLOY_PATH }}' ]; then
              echo 'âŒ Deployment directory is not writable'
              exit 1
            fi
            echo 'âœ… Deployment directory is ready'
          " || exit 1
          
          if [ -n "${{ secrets.BACKEND_ENV_FILE }}" ]; then
            echo "âœ… BACKEND_ENV_FILE secret is set"
          else
            ENV_EXISTS=$(ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
              if [ -f '${{ secrets.BACKEND_DEPLOY_PATH }}/shared/.env' ]; then
                echo 'exists'
              else
                echo 'missing'
              fi
            ")
            if [ "$ENV_EXISTS" = "missing" ]; then
              echo "âŒ No .env file found"
              exit 1
            fi
            echo "âœ… Shared .env file found"
          fi
          
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
            if command -v psql &> /dev/null; then
              echo 'âœ… PostgreSQL client is installed'
            fi
          " || true
          
          PM_MANAGER=$(ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
            if command -v pm2 &> /dev/null; then
              echo 'pm2'
            elif command -v systemctl &> /dev/null; then
              echo 'systemd'
            else
              echo 'none'
            fi
          ")
          if [ "$PM_MANAGER" != "none" ]; then
            echo "âœ… Process manager found: $PM_MANAGER"
          fi
          
          echo "âœ… All prerequisites validated successfully!"

  deploy:
    name: Deploy Backend to Server
    runs-on: ${{ vars.USE_SELF_HOSTED_RUNNER == 'true' && 'self-hosted' || 'ubuntu-latest' }}
    needs: [build, pre-deploy-check]
    if: |
      (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')) ||
      (github.event_name == 'workflow_dispatch' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'))
    environment:
      name: production
    
    env:
      USE_SELF_HOSTED: ${{ vars.USE_SELF_HOSTED_RUNNER == 'true' }}
      WORKSPACE_PATH: ${{ github.workspace }}
      DEPLOY_PATH: ${{ secrets.BACKEND_DEPLOY_PATH || '/var/www/investment-crm/backend' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: backend-build
          path: .

      - name: Setup SSH (for GitHub-hosted runners only)
        if: env.USE_SELF_HOSTED != 'true'
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts (for GitHub-hosted runners only)
        if: env.USE_SELF_HOSTED != 'true'
        run: |
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Create .env file from secret
        run: |
          if [ -n "${{ secrets.BACKEND_ENV_FILE }}" ]; then
            echo "${{ secrets.BACKEND_ENV_FILE }}" > backend-env.txt
          fi

      - name: Setup PATH for self-hosted runner
        if: vars.USE_SELF_HOSTED_RUNNER == 'true'
        run: |
          # Source common profile files to ensure PATH is set correctly
          [ -f /etc/profile ] && source /etc/profile
          [ -f ~/.bashrc ] && source ~/.bashrc
          [ -f ~/.bash_profile ] && source ~/.bash_profile
          [ -f ~/.profile ] && source ~/.profile
          
          # Add common Node.js paths to PATH
          export PATH="/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin:$PATH"
          export PATH="$HOME/.nvm/versions/node/*/bin:$PATH"
          export PATH="/opt/nodejs/bin:$PATH"
          
          # Find Node.js and npm if not in PATH (including root's installation)
          if ! command -v node &> /dev/null; then
            NODE_CMD=$(find /usr/local /usr /opt /root -name node -type f -executable 2>/dev/null | head -1)
            if [ -z "$NODE_CMD" ]; then
              # Try using root's PATH
              ROOT_NODE=$(sudo -n sh -c 'command -v node' 2>/dev/null || echo "")
              if [ -n "$ROOT_NODE" ] && [ -f "$ROOT_NODE" ]; then
                NODE_CMD="$ROOT_NODE"
              fi
            fi
            if [ -n "$NODE_CMD" ]; then
              echo "NODE_CMD=$NODE_CMD" >> $GITHUB_ENV
              echo "PATH=$(dirname $NODE_CMD):$PATH" >> $GITHUB_ENV
            fi
          fi
          
          if ! command -v npm &> /dev/null; then
            NPM_CMD=$(find /usr/local /usr /opt /root -name npm -type f -executable 2>/dev/null | head -1)
            if [ -z "$NPM_CMD" ]; then
              # Try using root's PATH
              ROOT_NPM=$(sudo -n sh -c 'command -v npm' 2>/dev/null || echo "")
              if [ -n "$ROOT_NPM" ] && [ -f "$ROOT_NPM" ]; then
                NPM_CMD="$ROOT_NPM"
              fi
            fi
            if [ -n "$NPM_CMD" ]; then
              echo "NPM_CMD=$NPM_CMD" >> $GITHUB_ENV
              echo "PATH=$(dirname $NPM_CMD):$PATH" >> $GITHUB_ENV
            fi
          fi
          
          # Verify Node.js and npm are accessible
          echo "Node.js: $(command -v node || echo 'not found')"
          echo "npm: $(command -v npm || echo 'not found')"
          if [ -n "$NODE_CMD" ]; then
            $NODE_CMD --version || echo "Node.js version check failed"
          fi
          if [ -n "$NPM_CMD" ]; then
            $NPM_CMD --version || echo "npm version check failed"
          fi

      - name: Setup deployment environment (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          # Set deployment path (already set in env)
          DEPLOY_PATH="${DEPLOY_PATH:-/var/www/investment-crm/backend}"
          
          # Source profile to ensure PATH is correct
          [ -f /etc/profile ] && source /etc/profile
          [ -f ~/.bashrc ] && source ~/.bashrc
          [ -f ~/.profile ] && source ~/.profile
          
          # Use NPM_CMD from environment or find it (including root's installation)
          if [ -z "$NPM_CMD" ]; then
            if command -v npm &> /dev/null; then
              NPM_CMD="npm"
            else
              NPM_CMD=$(find /usr/local /usr /opt /root -name npm -type f -executable 2>/dev/null | head -1)
              if [ -z "$NPM_CMD" ]; then
                # Try using root's PATH
                ROOT_NPM=$(sudo -n sh -c 'command -v npm' 2>/dev/null || echo "")
                if [ -n "$ROOT_NPM" ] && [ -f "$ROOT_NPM" ]; then
                  NPM_CMD="$ROOT_NPM"
                fi
              fi
            fi
          fi
          
          if [ -z "$NPM_CMD" ]; then
            echo "âŒ Error: npm not found"
            echo "ðŸ’¡ Tip: Run this on your server as root to fix:"
            echo "   sudo ln -s \$(sudo which npm) /usr/local/bin/npm"
            echo "   sudo ln -s \$(sudo which node) /usr/local/bin/node"
            exit 1
          fi
          
          echo "Using npm at: $NPM_CMD"
          echo "NPM_CMD=$NPM_CMD" >> $GITHUB_ENV
          
          # Create deployment directory
          mkdir -p "$DEPLOY_PATH/releases"
          mkdir -p "$DEPLOY_PATH/shared"
          
          # Move build artifact
          mv backend-deploy.tar.gz "$DEPLOY_PATH/releases/"
          
          # Copy docker-compose.yml to deployment directory for easy access
          # Check workspace root first (backend and frontend are separate repos)
          if [ -f "$WORKSPACE_PATH/docker-compose.yml" ]; then
            echo "ðŸ“‹ Copying docker-compose.yml to deployment directory..."
            mkdir -p "$DEPLOY_PATH"
            cp "$WORKSPACE_PATH/docker-compose.yml" "$DEPLOY_PATH/docker-compose.yml" || echo "âš ï¸  Failed to copy docker-compose.yml (non-critical)"
          fi
          
          # Extract and deploy
          cd "$DEPLOY_PATH/releases"
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          mkdir -p "$TIMESTAMP"
          tar -xzf backend-deploy.tar.gz -C "$TIMESTAMP"
          rm backend-deploy.tar.gz
          
          echo "TIMESTAMP=$TIMESTAMP" >> $GITHUB_ENV
          echo "RELEASE_DIR=$DEPLOY_PATH/releases/$TIMESTAMP" >> $GITHUB_ENV

      - name: Install dependencies (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          cd "$RELEASE_DIR"
          echo "ðŸ“‚ Release directory: $RELEASE_DIR"
          
          if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
            sudo $NPM_CMD ci --production
          else
            $NPM_CMD ci --production
          fi
          
          # Verify Prisma is installed
          if [ ! -f "node_modules/.bin/prisma" ]; then
            echo "âš ï¸  Prisma binary not found after npm ci"
            echo "   Checking if prisma package is installed..."
            if [ -d "node_modules/prisma" ]; then
              echo "   âœ… prisma package found in node_modules"
              echo "   Listing node_modules/.bin:"
              ls -la node_modules/.bin/ 2>/dev/null | head -10 || echo "   node_modules/.bin not found"
            else
              echo "   âŒ prisma package not found in node_modules"
              echo "   This might be because prisma is in devDependencies"
              echo "   Installing prisma as production dependency..."
              if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
                sudo $NPM_CMD install prisma@^5.20.0 --save --no-save || true
              else
                $NPM_CMD install prisma@^5.20.0 --save --no-save || true
              fi
            fi
          fi

      - name: Setup environment variables (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          cd "$RELEASE_DIR"
          DEPLOY_PATH="${DEPLOY_PATH:-/var/www/investment-crm/backend}"
          
          # Create .env file from secret or use shared .env
          if [ -f "$WORKSPACE_PATH/backend-env.txt" ]; then
            cp "$WORKSPACE_PATH/backend-env.txt" .env
            rm "$WORKSPACE_PATH/backend-env.txt"
            echo "âœ… Created .env file from BACKEND_ENV_FILE secret"
          elif [ -f "$DEPLOY_PATH/shared/.env" ]; then
            cp "$DEPLOY_PATH/shared/.env" .env
            echo "âœ… Using shared .env file"
          else
            echo "âŒ Error: No .env file found. Deployment cannot continue."
            exit 1
          fi
          
          # Validate required environment variables
          echo "ðŸ” Validating environment variables..."
          set -a
          source .env
          set +a
          if [ -z "$DATABASE_URL" ]; then
            echo "âŒ Error: DATABASE_URL is not set in .env file"
            exit 1
          fi
          if [ -z "$JWT_SECRET" ]; then
            echo "âŒ Error: JWT_SECRET is not set in .env file"
            exit 1
          fi
          echo "âœ… Required environment variables are set"

      - name: Start Docker services (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          DEPLOY_PATH="${DEPLOY_PATH:-/var/www/investment-crm/backend}"
          
          # Check for Docker (try multiple methods)
          DOCKER_CMD=""
          if command -v docker &> /dev/null; then
            DOCKER_CMD="docker"
            echo "âœ… Docker is installed (found via command -v)"
          elif [ -f /usr/bin/docker ]; then
            DOCKER_CMD="/usr/bin/docker"
            echo "âœ… Docker is installed (found at /usr/bin/docker)"
          elif [ -f /usr/local/bin/docker ]; then
            DOCKER_CMD="/usr/local/bin/docker"
            echo "âœ… Docker is installed (found at /usr/local/bin/docker)"
          elif sudo command -v docker &> /dev/null; then
            DOCKER_CMD="sudo docker"
            echo "âœ… Docker is installed (found via sudo command -v)"
          else
            echo "âš ï¸  Docker is not found in PATH"
            DOCKER_CMD=$(find /usr /opt -name docker -type f -executable 2>/dev/null | head -1)
            if [ -n "$DOCKER_CMD" ]; then
              echo "âœ… Docker found at: $DOCKER_CMD"
            else
              echo "âŒ Docker is not installed or not accessible"
              exit 1
            fi
          fi
          
          if [ -n "$DOCKER_CMD" ]; then
            # Check if docker-compose is available
            DOCKER_COMPOSE_CMD=""
            if command -v docker-compose &> /dev/null; then
              DOCKER_COMPOSE_CMD="docker-compose"
            elif $DOCKER_CMD compose version &> /dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="$DOCKER_CMD compose"
            fi
            
            if [ -n "$DOCKER_COMPOSE_CMD" ]; then
              # Find docker-compose.yml
              DOCKER_COMPOSE_DIR=""
              if [ -f "$WORKSPACE_PATH/docker-compose.yml" ]; then
                DOCKER_COMPOSE_DIR="$WORKSPACE_PATH"
              elif [ -f "$DEPLOY_PATH/docker-compose.yml" ]; then
                DOCKER_COMPOSE_DIR="$DEPLOY_PATH"
              elif [ -f "$DEPLOY_PATH/current/docker-compose.yml" ]; then
                DOCKER_COMPOSE_DIR="$DEPLOY_PATH/current"
              fi
              
              if [ -n "$DOCKER_COMPOSE_DIR" ]; then
                cd "$DOCKER_COMPOSE_DIR"
                if ! $DOCKER_CMD ps --filter "name=investment_crm_db" --filter "status=running" --format "{{.Names}}" 2>/dev/null | grep -q "investment_crm_db"; then
                  echo "ðŸš€ Starting Docker services..."
                  $DOCKER_COMPOSE_CMD up -d postgres redis
                  
                  # Wait for PostgreSQL
                  RETRY_COUNT=0
                  while [ $RETRY_COUNT -lt 30 ]; do
                    if $DOCKER_CMD exec investment_crm_db pg_isready -U postgres &> /dev/null 2>&1; then
                      echo "âœ… PostgreSQL is ready"
                      break
                    fi
                    RETRY_COUNT=$((RETRY_COUNT + 1))
                    sleep 2
                  done
                  
                  # Wait for Redis
                  RETRY_COUNT=0
                  while [ $RETRY_COUNT -lt 30 ]; do
                    if $DOCKER_CMD exec investment_crm_redis redis-cli ping &> /dev/null 2>&1; then
                      echo "âœ… Redis is ready"
                      break
                    fi
                    RETRY_COUNT=$((RETRY_COUNT + 1))
                    sleep 2
                  done
                else
                  echo "âœ… Docker services are already running"
                fi
              fi
            fi
          fi

      - name: Run database migrations (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          cd "$RELEASE_DIR"
          
          # Generate Prisma client
          echo "ðŸ“¦ Generating Prisma client..."
          PRISMA_BIN=""
          if [ -f "node_modules/.bin/prisma" ]; then
            PRISMA_BIN="node_modules/.bin/prisma"
          elif [ -f "$RELEASE_DIR/node_modules/.bin/prisma" ]; then
            PRISMA_BIN="$RELEASE_DIR/node_modules/.bin/prisma"
          elif [ -d "node_modules/prisma" ] && [ -f "node_modules/prisma/build/index.js" ]; then
            PRISMA_BIN="node node_modules/prisma/build/index.js"
          fi
          
          if [ -n "$PRISMA_BIN" ]; then
            if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
              sudo "$PRISMA_BIN" generate
              sudo "$PRISMA_BIN" migrate deploy
            else
              "$PRISMA_BIN" generate
              "$PRISMA_BIN" migrate deploy
            fi
          else
            if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
              sudo $NPM_CMD run db:generate
              sudo $NPM_CMD exec --yes prisma migrate deploy
            else
              $NPM_CMD run db:generate
              $NPM_CMD exec --yes prisma migrate deploy
            fi
          fi
          echo "âœ… Database migrations completed"

      - name: Finalize deployment (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          DEPLOY_PATH="${DEPLOY_PATH:-/var/www/investment-crm/backend}"
          
          # Create symlink to current release
          cd "$DEPLOY_PATH"
          rm -f current
          ln -s "releases/$TIMESTAMP" current
          
          # Restart application
          if command -v pm2 &> /dev/null; then
            pm2 restart investment-crm-backend || pm2 start current/dist/index.js --name investment-crm-backend
          elif command -v systemctl &> /dev/null; then
            sudo systemctl restart investment-crm-backend || echo "Service not configured"
          else
            pkill -f 'node.*dist/index.js' || true
            cd current
            if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
              sudo nohup $NPM_CMD start > /dev/null 2>&1 &
            else
              nohup $NPM_CMD start > /dev/null 2>&1 &
            fi
          fi
          
          # Cleanup old releases (keep last 5)
          cd "$DEPLOY_PATH/releases"
          ls -t | tail -n +6 | xargs -r rm -rf

      - name: Deploy to server (GitHub-hosted)
        if: env.USE_SELF_HOSTED != 'true'
        run: |
          DEPLOY_PATH="${DEPLOY_PATH:-/var/www/investment-crm/backend}"
          
          # GitHub-hosted runner: deploy via SSH
          echo "ðŸš€ Deploying via SSH..."
          
          # Create deployment directory on server
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
            mkdir -p $DEPLOY_PATH/releases
            mkdir -p $DEPLOY_PATH/shared
          "
          
          # Upload build artifact
          scp backend-deploy.tar.gz ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:$DEPLOY_PATH/releases/
          
          # Upload .env file if provided
          if [ -f backend-env.txt ]; then
            scp backend-env.txt ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:$DEPLOY_PATH/releases/backend-env.txt
          fi
          
          # Extract and deploy on server
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
              cd $DEPLOY_PATH/releases
              TIMESTAMP=\$(date +%Y%m%d%H%M%S)
              mkdir -p \$TIMESTAMP
              tar -xzf backend-deploy.tar.gz -C \$TIMESTAMP
              rm backend-deploy.tar.gz
              
              # Install production dependencies
              cd \$TIMESTAMP
              ${NPM_CMD:-npm} ci --production
              
              # Create .env file from secret or use shared .env
              if [ -f ../backend-env.txt ]; then
                cp ../backend-env.txt .env
                rm ../backend-env.txt
                echo 'âœ… Created .env file from BACKEND_ENV_FILE secret'
              elif [ -f $DEPLOY_PATH/shared/.env ]; then
                cp $DEPLOY_PATH/shared/.env .env
                echo 'âœ… Using shared .env file'
              else
                echo 'âŒ Error: No .env file found. Deployment cannot continue.'
                exit 1
              fi
              
              # Validate required environment variables
              echo 'ðŸ” Validating environment variables...'
              source .env
              if [ -z \"\$DATABASE_URL\" ]; then
                echo 'âŒ Error: DATABASE_URL is not set in .env file'
                exit 1
              fi
              if [ -z \"\$JWT_SECRET\" ]; then
                echo 'âŒ Error: JWT_SECRET is not set in .env file'
                exit 1
              fi
              echo 'âœ… Required environment variables are set'
              
              # Test database connectivity
              echo 'ðŸ—„ï¸  Testing database connectivity...'
              if command -v psql &> /dev/null; then
                DB_CONN=\$(echo \$DATABASE_URL | sed -E 's|postgresql://([^:]+):([^@]+)@([^:]+):([^/]+)/(.+)|host=\3 port=\4 user=\1 password=\2 dbname=\5|')
                if psql \"\$DB_CONN\" -c 'SELECT 1' &> /dev/null; then
                  echo 'âœ… Database connection successful'
                else
                  echo 'âš ï¸  Could not verify database connection with psql, but continuing...'
                fi
              else
                echo 'âš ï¸  psql not available, skipping database connectivity test'
              fi
              
              # Generate Prisma client
              echo 'ðŸ“¦ Generating Prisma client...'
              # Use the local Prisma binary directly
              if [ -f 'node_modules/.bin/prisma' ]; then
                node_modules/.bin/prisma generate || {
                  echo 'âŒ Error: Failed to generate Prisma client'
                  exit 1
                }
              elif [ -f './node_modules/.bin/prisma' ]; then
                ./node_modules/.bin/prisma generate || {
                  echo 'âŒ Error: Failed to generate Prisma client'
                  exit 1
                }
              elif command -v npx &> /dev/null; then
                npx prisma generate || {
                  echo 'âŒ Error: Failed to generate Prisma client'
                  exit 1
                }
              else
                ${NPM_CMD:-npm} run db:generate || {
                  echo 'âŒ Error: Failed to generate Prisma client'
                  exit 1
                }
              fi
              
              # Run database migrations
              echo 'ðŸ”„ Running database migrations...'
              if [ -f 'node_modules/.bin/prisma' ]; then
                node_modules/.bin/prisma migrate deploy || {
                  echo 'âŒ Error: Database migration failed'
                  exit 1
                }
              elif [ -f './node_modules/.bin/prisma' ]; then
                ./node_modules/.bin/prisma migrate deploy || {
                  echo 'âŒ Error: Database migration failed'
                  exit 1
                }
              elif command -v npx &> /dev/null; then
                npx prisma migrate deploy || {
                  echo 'âŒ Error: Database migration failed'
                  exit 1
                }
              else
                ${NPM_CMD:-npm} run db:generate || {
                  echo 'âŒ Error: Database migration failed'
                  exit 1
                }
              fi
              echo 'âœ… Database migrations completed'
              
              # Create symlink to current release
              cd $DEPLOY_PATH
              rm -f current
              ln -s releases/\$TIMESTAMP current
              
              # Restart application
              if command -v pm2 &> /dev/null; then
                pm2 restart investment-crm-backend || pm2 start current/dist/index.js --name investment-crm-backend
              elif command -v systemctl &> /dev/null; then
                sudo systemctl restart investment-crm-backend || echo 'Service not configured'
              else
                # Fallback: kill existing process and start new one
                pkill -f 'node.*dist/index.js' || true
                cd current
                nohup ${NPM_CMD:-npm} start > /dev/null 2>&1 &
              fi
              
            # Cleanup old releases (keep last 5)
            cd releases
            ls -t | tail -n +6 | xargs -r rm -rf
          "

      - name: Health check
        run: |
          sleep 10
          curl -f ${{ secrets.BACKEND_URL || 'http://localhost:3001' }}/health || exit 1


