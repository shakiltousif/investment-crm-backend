name: Backend Deployment

on:
  push:
    branches:
      - main
      - master
    paths:
      - 'backend/**'
      - 'backend/.github/workflows/backend-deploy.yml'
  pull_request:
    branches:
      - main
      - master
    paths:
      - 'backend/**'
      - 'backend/.github/workflows/backend-deploy.yml'
  workflow_dispatch:

env:
  NODE_VERSION: '20'

jobs:
  test:
    name: Test Backend
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: investment_crm_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        id: setup-node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: package-lock.json
        continue-on-error: true

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npm run db:generate
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/investment_crm_test

      - name: Run database migrations
        run: npx prisma migrate deploy
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/investment_crm_test

      - name: Run linter
        run: npm run lint

      - name: Type check
        run: npm run type-check

      - name: Run tests
        run: npm test
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/investment_crm_test
          NODE_ENV: test
          JWT_SECRET: test-secret-key

  build:
    name: Build Backend
    runs-on: ubuntu-latest
    needs: test
    if: |
      always() &&
      (needs.test.result == 'success' || needs.test.result == 'skipped') &&
      ((github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')) ||
       (github.event_name == 'workflow_dispatch' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')))
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify package-lock.json exists
        run: |
          if [ ! -f package-lock.json ]; then
            echo "Warning: package-lock.json not found, cache will be skipped"
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npm run db:generate

      - name: Build application
        run: npm run build

      - name: Create deployment package
        run: |
          mkdir -p deploy
          cp -r dist deploy/
          cp -r prisma deploy/
          cp package.json deploy/
          cp package-lock.json deploy/
          tar -czf backend-deploy.tar.gz -C deploy .
          rm -rf deploy

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: backend-build
          path: backend-deploy.tar.gz
          retention-days: 1

  pre-deploy-check:
    name: Pre-Deployment Validation
    runs-on: ${{ vars.USE_SELF_HOSTED_RUNNER == 'true' && 'self-hosted' || 'ubuntu-latest' }}
    needs: build
    if: |
      (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')) ||
      (github.event_name == 'workflow_dispatch' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'))
    
    env:
      USE_SELF_HOSTED: ${{ vars.USE_SELF_HOSTED_RUNNER == 'true' }}
      WORKSPACE_PATH: $WORKSPACE_PATH
      DEPLOY_PATH: ${{ secrets.BACKEND_DEPLOY_PATH || '/var/www/investment-crm/backend' }}
    
    steps:
      - name: Setup SSH (for GitHub-hosted runners only)
        if: env.USE_SELF_HOSTED != 'true'
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts (for GitHub-hosted runners only)
        if: env.USE_SELF_HOSTED != 'true'
        run: |
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Validate server prerequisites
        run: |
          echo "üîç Validating server prerequisites..."
          
          # For self-hosted runners, we're already on the server
          if [ "$USE_SELF_HOSTED" = "true" ]; then
            echo "‚úÖ Running on self-hosted runner - no SSH needed"
            
            # Source common profile files to ensure PATH is set correctly
            [ -f /etc/profile ] && source /etc/profile
            [ -f ~/.bashrc ] && source ~/.bashrc
            [ -f ~/.bash_profile ] && source ~/.bash_profile
            [ -f ~/.profile ] && source ~/.profile
            
            # Add common Node.js paths to PATH
            export PATH="/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin:$PATH"
            export PATH="$HOME/.nvm/versions/node/*/bin:$PATH"
            export PATH="/opt/nodejs/bin:$PATH"
            
            # Check Node.js version (try multiple methods, including checking root's PATH)
            echo "üì¶ Checking Node.js installation..."
            echo "Current user: $(whoami)"
            echo "Current PATH: $PATH"
            
            NODE_CMD=""
            # First check if /opt/nodejs/bin directory exists and what's in it
            if [ -d /opt/nodejs/bin ]; then
              echo "Checking /opt/nodejs/bin directory..."
              ls -la /opt/nodejs/bin/ 2>/dev/null | head -10 || echo "Cannot list /opt/nodejs/bin"
              if [ -f /opt/nodejs/bin/node ]; then
                if [ -x /opt/nodejs/bin/node ]; then
                  NODE_CMD="/opt/nodejs/bin/node"
                  echo "‚úÖ Found executable node in /opt/nodejs/bin"
                else
                  echo "‚ö†Ô∏è  Found node in /opt/nodejs/bin but not executable"
                  # Try to make it executable
                  if sudo chmod +x /opt/nodejs/bin/node 2>/dev/null; then
                    NODE_CMD="/opt/nodejs/bin/node"
                    echo "‚úÖ Made node executable"
                  fi
                fi
              else
                echo "‚ö†Ô∏è  /opt/nodejs/bin exists but node file not found"
              fi
            fi
            
            # Try standard locations if not found yet
            if [ -z "$NODE_CMD" ]; then
              if command -v node &> /dev/null; then
                NODE_CMD="node"
                echo "‚úÖ Found node via command -v"
              elif [ -f /usr/local/bin/node ]; then
                NODE_CMD="/usr/local/bin/node"
                echo "‚úÖ Found node in /usr/local/bin"
              elif [ -f /usr/bin/node ]; then
                NODE_CMD="/usr/bin/node"
                echo "‚úÖ Found node in /usr/bin"
              fi
            fi
            
            # Check root's nvm installation
            if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
              echo "Checking root's nvm installation..."
              if [ -d /root/.nvm/versions/node ]; then
                NODE_CMD=$(find /root/.nvm/versions/node -name node -type f -executable 2>/dev/null | sort -V | tail -1)
              fi
            fi
            
            # Check current user's nvm
            if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
              if [ -d "$HOME/.nvm/versions/node" ]; then
                NODE_CMD=$(find "$HOME/.nvm/versions/node" -name node -type f -executable 2>/dev/null | sort -V | tail -1)
              fi
            fi
            
            # Try to find node in common locations (including root's home and bin directories)
            if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
              echo "Searching for node in common locations..."
              NODE_CMD=$(find /usr/local/bin /usr/bin /opt /root/.nvm /root/.local /root/bin -name node -type f -executable 2>/dev/null | head -1)
            fi
            
            # If still not found, try using sudo to check root's PATH (without -n to allow password prompt if needed)
            if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
              echo "Trying to find node using root's PATH..."
              # Try without -n first (in case passwordless sudo is configured)
              ROOT_NODE=$(sudo sh -c 'command -v node' 2>/dev/null || echo "")
              if [ -z "$ROOT_NODE" ]; then
                # Try with -n (non-interactive, requires passwordless sudo)
                ROOT_NODE=$(sudo -n sh -c 'command -v node' 2>/dev/null || echo "")
              fi
              if [ -n "$ROOT_NODE" ] && [ -f "$ROOT_NODE" ]; then
                NODE_CMD="$ROOT_NODE"
                echo "Found node via root's PATH: $NODE_CMD"
              fi
            fi
            
            # Last resort: try to read root's .bashrc or .profile to find NVM_DIR
            if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
              echo "Checking root's shell configuration for Node.js path..."
              if [ -f /root/.bashrc ]; then
                ROOT_NVM_DIR=$(grep -o 'NVM_DIR="[^"]*"' /root/.bashrc 2>/dev/null | cut -d'"' -f2 || echo "")
                if [ -n "$ROOT_NVM_DIR" ] && [ -d "$ROOT_NVM_DIR/versions/node" ]; then
                  NODE_CMD=$(find "$ROOT_NVM_DIR/versions/node" -name node -type f -executable 2>/dev/null | sort -V | tail -1)
                fi
              fi
            fi
            
            # If still not found, try to find Node.js as root and use sudo for all commands
            if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
              echo "Attempting to find Node.js as root user..."
              # Try to get root's node path
              ROOT_NODE_PATH=$(sudo sh -c 'which node 2>&1' 2>/dev/null | grep -v "not found" | head -1 || echo "")
              if [ -n "$ROOT_NODE_PATH" ] && [ "$ROOT_NODE_PATH" != "" ]; then
                # Verify the path exists
                if sudo test -f "$ROOT_NODE_PATH" 2>/dev/null; then
                  echo "‚úÖ Found Node.js at: $ROOT_NODE_PATH (requires sudo)"
                  NODE_CMD="$ROOT_NODE_PATH"
                  # Set flag to use sudo for all Node.js/npm commands
                  echo "USE_SUDO_FOR_NODE=1" >> $GITHUB_ENV
                  echo "‚úÖ Will use sudo for all Node.js/npm commands"
                fi
              fi
            fi
            
            # If still not found, try to create symlinks automatically (if sudo is available)
            if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
              echo "Attempting to create symlinks automatically..."
              # Try to get root's node path and create symlink
              ROOT_NODE_PATH=$(sudo sh -c 'which node 2>&1' 2>/dev/null | grep -v "not found" | head -1 || echo "")
              if [ -n "$ROOT_NODE_PATH" ] && sudo test -f "$ROOT_NODE_PATH" 2>/dev/null; then
                echo "Found Node.js at: $ROOT_NODE_PATH"
                echo "Creating symlink in /usr/local/bin..."
                if sudo ln -sf "$ROOT_NODE_PATH" /usr/local/bin/node 2>/dev/null; then
                  sudo chmod +x /usr/local/bin/node 2>/dev/null
                  if [ -f /usr/local/bin/node ] && [ -x /usr/local/bin/node ]; then
                    NODE_CMD="/usr/local/bin/node"
                    echo "‚úÖ Symlink created successfully"
                  fi
                else
                  echo "‚ö†Ô∏è  Failed to create symlink (may need passwordless sudo)"
                fi
              fi
            fi
            
            if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
              echo "‚ùå Node.js is not installed on the server or not accessible"
              echo "Current PATH: $PATH"
              echo "Current user: $(whoami)"
              echo ""
              echo "Trying to find node..."
              which node 2>/dev/null || echo "node not in PATH"
              echo ""
              echo "Searching in common locations:"
              find /usr /opt -name node -type f 2>/dev/null | head -10 || echo "node not found in /usr or /opt"
              echo ""
              echo "Checking if we can access root's directories:"
              ls -la /root/.nvm 2>/dev/null | head -5 || echo "Cannot access /root/.nvm"
              echo ""
              echo "üí° Solution: Run these commands on your server as root:"
              echo "   NODE_PATH=\$(which node)"
              echo "   NPM_PATH=\$(which npm)"
              echo "   sudo ln -sf \$NODE_PATH /usr/local/bin/node"
              echo "   sudo ln -sf \$NPM_PATH /usr/local/bin/npm"
              echo "   sudo chmod +x /usr/local/bin/node /usr/local/bin/npm"
              echo ""
              echo "Or configure passwordless sudo for the runner user:"
              echo "   sudo visudo"
              echo "   Add: signin-fil-investments-api ALL=(ALL) NOPASSWD: ALL"
              exit 1
            fi
            
            # Verify we can execute it
            if [ ! -x "$NODE_CMD" ]; then
              echo "‚ö†Ô∏è  Node.js found but not executable, checking permissions..."
              ls -la "$NODE_CMD" || echo "Cannot check permissions"
              # Try to make it executable
              if sudo chmod +x "$NODE_CMD" 2>/dev/null; then
                echo "‚úÖ Made Node.js executable"
              elif sudo -n test -x "$NODE_CMD" 2>/dev/null; then
                echo "Node.js requires sudo to execute"
              else
                echo "‚ùå Node.js found at $NODE_CMD but cannot be executed"
                echo "Try: sudo chmod +x $NODE_CMD"
                exit 1
              fi
            fi
            
            # Check Node.js version (use sudo if needed)
            if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
              NODE_VERSION=$(sudo $NODE_CMD --version 2>/dev/null || echo "unknown")
            else
              NODE_VERSION=$($NODE_CMD --version 2>/dev/null || sudo $NODE_CMD --version 2>/dev/null || echo "unknown")
            fi
            echo "‚úÖ Node.js found at: $NODE_CMD"
            echo "‚úÖ Node.js version: $NODE_VERSION"
            
            # Export NODE_CMD and USE_SUDO_FOR_NODE for use in later steps
            echo "NODE_CMD=$NODE_CMD" >> $GITHUB_ENV
            
            # Check npm (try multiple methods, including checking root's PATH)
            echo "üì¶ Checking npm installation..."
            NPM_CMD=""
            # First try standard locations (check /opt/nodejs/bin first since it's in PATH)
            if [ -f /opt/nodejs/bin/npm ] && [ -x /opt/nodejs/bin/npm ]; then
              NPM_CMD="/opt/nodejs/bin/npm"
              echo "Found npm in /opt/nodejs/bin"
            elif command -v npm &> /dev/null; then
              NPM_CMD="npm"
            elif [ -f /usr/local/bin/npm ]; then
              NPM_CMD="/usr/local/bin/npm"
            elif [ -f /usr/bin/npm ]; then
              NPM_CMD="/usr/bin/npm"
            fi
            
            # Check root's nvm installation (use same directory as node if found)
            if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
              if [ -n "$NODE_CMD" ] && [ -d "$(dirname "$NODE_CMD")" ]; then
                # npm should be in the same directory as node
                NPM_CMD="$(dirname "$NODE_CMD")/npm"
                if [ ! -f "$NPM_CMD" ]; then
                  NPM_CMD=""
                fi
              elif [ -d /root/.nvm/versions/node ]; then
                NPM_CMD=$(find /root/.nvm/versions/node -name npm -type f -executable 2>/dev/null | sort -V | tail -1)
              fi
            fi
            
            # Check current user's nvm
            if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
              if [ -d "$HOME/.nvm/versions/node" ]; then
                NPM_CMD=$(find "$HOME/.nvm/versions/node" -name npm -type f -executable 2>/dev/null | sort -V | tail -1)
              fi
            fi
            
            # Try to find npm in common locations
            if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
              echo "Searching for npm in common locations..."
              NPM_CMD=$(find /usr/local/bin /usr/bin /opt /root/.nvm /root/.local /root/bin -name npm -type f -executable 2>/dev/null | head -1)
            fi
            
            # If still not found, try using sudo to check root's PATH
            if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
              echo "Trying to find npm using root's PATH..."
              # Try without -n first
              ROOT_NPM=$(sudo sh -c 'command -v npm' 2>/dev/null || echo "")
              if [ -z "$ROOT_NPM" ]; then
                # Try with -n
                ROOT_NPM=$(sudo -n sh -c 'command -v npm' 2>/dev/null || echo "")
              fi
              if [ -n "$ROOT_NPM" ] && [ -f "$ROOT_NPM" ]; then
                NPM_CMD="$ROOT_NPM"
                echo "Found npm via root's PATH: $NPM_CMD"
              fi
            fi
            
            # Last resort: try to read root's .bashrc or .profile to find NVM_DIR
            if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
              if [ -f /root/.bashrc ]; then
                ROOT_NVM_DIR=$(grep -o 'NVM_DIR="[^"]*"' /root/.bashrc 2>/dev/null | cut -d'"' -f2 || echo "")
                if [ -n "$ROOT_NVM_DIR" ] && [ -d "$ROOT_NVM_DIR/versions/node" ]; then
                  NPM_CMD=$(find "$ROOT_NVM_DIR/versions/node" -name npm -type f -executable 2>/dev/null | sort -V | tail -1)
                fi
              fi
            fi
            
            # If still not found, try to create symlinks automatically (if sudo is available)
            if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
              echo "Attempting to find and create symlinks automatically..."
              # Try multiple methods to find root's npm
              ROOT_NPM_PATH=""
              # Method 1: Try sudo which
              ROOT_NPM_PATH=$(sudo sh -c 'which npm' 2>/dev/null || echo "")
              # Method 2: Use same directory as node if found
              if [ -z "$ROOT_NPM_PATH" ] && [ -n "$NODE_CMD" ] && [ -f "$NODE_CMD" ]; then
                ROOT_NPM_PATH="$(dirname "$NODE_CMD")/npm"
                if [ ! -f "$ROOT_NPM_PATH" ]; then
                  ROOT_NPM_PATH=""
                fi
              fi
              # Method 3: Check if /opt/nodejs/bin/npm exists
              if [ -z "$ROOT_NPM_PATH" ] && [ -f /opt/nodejs/bin/npm ]; then
                ROOT_NPM_PATH="/opt/nodejs/bin/npm"
              fi
              
              if [ -n "$ROOT_NPM_PATH" ] && [ -f "$ROOT_NPM_PATH" ]; then
                echo "Found npm at: $ROOT_NPM_PATH"
                echo "Creating symlink in /usr/local/bin..."
                sudo ln -sf "$ROOT_NPM_PATH" /usr/local/bin/npm 2>/dev/null || echo "Failed to create symlink (may need manual setup)"
                if [ -f /usr/local/bin/npm ] && [ -x /usr/local/bin/npm ]; then
                  NPM_CMD="/usr/local/bin/npm"
                  echo "‚úÖ Symlink created successfully"
                elif [ -f /opt/nodejs/bin/npm ]; then
                  # If /opt/nodejs/bin/npm exists, try to use it directly
                  NPM_CMD="/opt/nodejs/bin/npm"
                  echo "‚úÖ Using /opt/nodejs/bin/npm directly"
                fi
              fi
            fi
            
            if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
              echo "‚ùå npm is not installed on the server or not accessible"
              echo "Trying to find npm..."
              which npm 2>/dev/null || echo "npm not in PATH"
              echo ""
              echo "Searching in common locations:"
              find /usr /opt -name npm -type f 2>/dev/null | head -10 || echo "npm not found in /usr or /opt"
              echo ""
              echo "üí° Solution: Run these commands on your server as root:"
              echo "   NODE_PATH=\$(which node)"
              echo "   NPM_PATH=\$(which npm)"
              echo "   sudo ln -sf \$NODE_PATH /usr/local/bin/node"
              echo "   sudo ln -sf \$NPM_PATH /usr/local/bin/npm"
              echo "   sudo chmod +x /usr/local/bin/node /usr/local/bin/npm"
              echo ""
              echo "Or configure passwordless sudo for the runner user:"
              echo "   sudo visudo"
              echo "   Add: signin-fil-investments-api ALL=(ALL) NOPASSWD: ALL"
              exit 1
            fi
            
            # Verify we can execute it
            if [ ! -x "$NPM_CMD" ]; then
              echo "‚ö†Ô∏è  npm found but not executable, checking permissions..."
              ls -la "$NPM_CMD" || echo "Cannot check permissions"
              # Try to make it executable
              if sudo chmod +x "$NPM_CMD" 2>/dev/null; then
                echo "‚úÖ Made npm executable"
              elif sudo -n test -x "$NPM_CMD" 2>/dev/null; then
                echo "npm requires sudo to execute"
              else
                echo "‚ùå npm found at $NPM_CMD but cannot be executed"
                echo "Try: sudo chmod +x $NPM_CMD"
                exit 1
              fi
            fi
            
            # Check npm version (use sudo if needed)
            if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
              NPM_VERSION=$(sudo $NPM_CMD --version 2>/dev/null || echo "unknown")
            else
              NPM_VERSION=$($NPM_CMD --version 2>/dev/null || sudo $NPM_CMD --version 2>/dev/null || echo "unknown")
            fi
            echo "‚úÖ npm found at: $NPM_CMD"
            echo "‚úÖ npm version: $NPM_VERSION"
            
            # Export NPM_CMD and USE_SUDO_FOR_NODE for use in later steps
            echo "NPM_CMD=$NPM_CMD" >> $GITHUB_ENV
            
            # Check deployment directory
            echo "üìÅ Checking deployment directory..."
            DEPLOY_PATH="$DEPLOY_PATH"
            if [ ! -d "$DEPLOY_PATH" ]; then
              echo "Creating deployment directory..."
              mkdir -p "$DEPLOY_PATH/releases"
              mkdir -p "$DEPLOY_PATH/shared"
            fi
            
            if [ ! -w "$DEPLOY_PATH" ]; then
              echo "‚ùå Deployment directory is not writable"
              exit 1
            fi
            echo "‚úÖ Deployment directory is ready"
            
            # Check .env file
            echo "üîê Checking environment configuration..."
            if [ -n "${{ secrets.BACKEND_ENV_FILE }}" ]; then
              echo "‚úÖ BACKEND_ENV_FILE secret is set"
            elif [ -f "$DEPLOY_PATH/shared/.env" ]; then
              echo "‚úÖ Shared .env file found"
            else
              echo "‚ùå No .env file found. Please set BACKEND_ENV_FILE secret or create shared/.env file"
              exit 1
            fi
            
            # Check Docker and start services if needed
            echo "üê≥ Checking Docker and services..."
            if command -v docker &> /dev/null; then
              echo "‚úÖ Docker is installed"
              
              # Check if docker-compose is available
              if command -v docker-compose &> /dev/null; then
                DOCKER_COMPOSE_CMD="docker-compose"
              elif docker compose version &> /dev/null; then
                DOCKER_COMPOSE_CMD="docker compose"
              else
                echo "‚ö†Ô∏è  docker-compose not found, trying to install..."
                # Try to install docker-compose if not available
                if command -v apt-get &> /dev/null; then
                  sudo apt-get update && sudo apt-get install -y docker-compose-plugin 2>/dev/null || true
                  DOCKER_COMPOSE_CMD="docker compose"
                fi
              fi
              
              if [ -z "$DOCKER_COMPOSE_CMD" ]; then
                echo "‚ö†Ô∏è  docker-compose not available, skipping Docker service check"
              else
                echo "‚úÖ Using: $DOCKER_COMPOSE_CMD"
                
                # Try to find docker-compose.yml in various locations
                DOCKER_COMPOSE_FILE=""
                DOCKER_COMPOSE_DIR=""
                
                # Check in workspace first (for self-hosted runners)
                if [ -f "$WORKSPACE_PATH/backend/docker-compose.yml" ]; then
                  DOCKER_COMPOSE_FILE="$WORKSPACE_PATH/backend/docker-compose.yml"
                  DOCKER_COMPOSE_DIR="$WORKSPACE_PATH/backend"
                # Check in current deployment
                elif [ -f "$DEPLOY_PATH/current/docker-compose.yml" ]; then
                  DOCKER_COMPOSE_FILE="$DEPLOY_PATH/current/docker-compose.yml"
                  DOCKER_COMPOSE_DIR="$DEPLOY_PATH/current"
                # Check in latest release
                elif [ -d "$DEPLOY_PATH/releases" ] && [ -n "$(ls -t $DEPLOY_PATH/releases 2>/dev/null | head -1)" ]; then
                  LATEST_RELEASE=$(ls -t $DEPLOY_PATH/releases 2>/dev/null | head -1)
                  if [ -f "$DEPLOY_PATH/releases/$LATEST_RELEASE/docker-compose.yml" ]; then
                    DOCKER_COMPOSE_FILE="$DEPLOY_PATH/releases/$LATEST_RELEASE/docker-compose.yml"
                    DOCKER_COMPOSE_DIR="$DEPLOY_PATH/releases/$LATEST_RELEASE"
                  fi
                # Check in deployment root
                elif [ -f "$DEPLOY_PATH/docker-compose.yml" ]; then
                  DOCKER_COMPOSE_FILE="$DEPLOY_PATH/docker-compose.yml"
                  DOCKER_COMPOSE_DIR="$DEPLOY_PATH"
                fi
                
                if [ -z "$DOCKER_COMPOSE_FILE" ]; then
                  echo "‚ö†Ô∏è  docker-compose.yml not found, skipping Docker service setup"
                  echo "   Searched in:"
                  echo "   - $WORKSPACE_PATH/backend/docker-compose.yml"
                  echo "   - $DEPLOY_PATH/current/docker-compose.yml"
                  echo "   - $DEPLOY_PATH/docker-compose.yml"
                fi
                
                if [ -n "$DOCKER_COMPOSE_FILE" ]; then
                  echo "üìÑ Found docker-compose.yml at: $DOCKER_COMPOSE_FILE"
                  cd "$DOCKER_COMPOSE_DIR"
                  
                  # Check if containers are running
                  echo "üîç Checking if PostgreSQL and Redis containers are running..."
                  POSTGRES_RUNNING=$(docker ps --filter "name=investment_crm_db" --filter "status=running" --format "{{.Names}}" 2>/dev/null | grep -c "investment_crm_db" || echo "0")
                  REDIS_RUNNING=$(docker ps --filter "name=investment_crm_redis" --filter "status=running" --format "{{.Names}}" 2>/dev/null | grep -c "investment_crm_redis" || echo "0")
                  
                  echo "  PostgreSQL container: $([ "$POSTGRES_RUNNING" = "1" ] && echo "‚úÖ Running" || echo "‚ùå Not running")"
                  echo "  Redis container: $([ "$REDIS_RUNNING" = "1" ] && echo "‚úÖ Running" || echo "‚ùå Not running")"
                  
                  # Always ensure services are up (docker-compose up -d is idempotent)
                  echo "üöÄ Ensuring Docker services are running (PostgreSQL and Redis)..."
                  echo "   This will start services if they're not running, or do nothing if already running."
                  
                  # Start only postgres and redis services (not backend/frontend)
                  # Using docker-compose up -d is safe - it won't restart if already running
                  if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
                    sudo $DOCKER_COMPOSE_CMD up -d postgres redis 2>&1 || {
                      echo "‚ö†Ô∏è  Failed to start services with sudo, trying without sudo..."
                      $DOCKER_COMPOSE_CMD up -d postgres redis 2>&1 || {
                        echo "‚ùå Failed to start Docker services"
                        echo "üí° You can manually start them with: cd $DOCKER_COMPOSE_DIR && $DOCKER_COMPOSE_CMD up -d postgres redis"
                        exit 1
                      }
                    }
                  else
                    $DOCKER_COMPOSE_CMD up -d postgres redis 2>&1 || {
                      echo "‚ùå Failed to start Docker services"
                      echo "üí° You can manually start them with: cd $DOCKER_COMPOSE_DIR && $DOCKER_COMPOSE_CMD up -d postgres redis"
                      exit 1
                    }
                  fi
                  
                  echo "‚úÖ Docker services command executed successfully"
                  
                  # Wait for services to be healthy (whether just started or already running)
                  echo "‚è≥ Waiting for services to be healthy..."
                  sleep 3
                  
                  # Wait for PostgreSQL to be ready
                  echo "üîÑ Waiting for PostgreSQL to be ready..."
                  MAX_RETRIES=30
                  RETRY_COUNT=0
                  POSTGRES_READY=false
                  while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                    if docker exec investment_crm_db pg_isready -U postgres &> /dev/null 2>&1; then
                      echo "‚úÖ PostgreSQL is ready"
                      POSTGRES_READY=true
                      break
                    fi
                    RETRY_COUNT=$((RETRY_COUNT + 1))
                    if [ $((RETRY_COUNT % 5)) -eq 0 ]; then
                      echo "  Still waiting... ($RETRY_COUNT/$MAX_RETRIES)"
                    fi
                    sleep 2
                  done
                  
                  if [ "$POSTGRES_READY" = "false" ]; then
                    echo "‚ö†Ô∏è  PostgreSQL took too long to start (waited $((MAX_RETRIES * 2)) seconds)"
                    echo "üí° Check container logs: docker logs investment_crm_db"
                    echo "   Or manually start: cd $DOCKER_COMPOSE_DIR && $DOCKER_COMPOSE_CMD up -d postgres"
                  fi
                  
                  # Wait for Redis to be ready
                  echo "üîÑ Waiting for Redis to be ready..."
                  RETRY_COUNT=0
                  REDIS_READY=false
                  while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                    if docker exec investment_crm_redis redis-cli ping &> /dev/null 2>&1; then
                      echo "‚úÖ Redis is ready"
                      REDIS_READY=true
                      break
                    fi
                    RETRY_COUNT=$((RETRY_COUNT + 1))
                    if [ $((RETRY_COUNT % 5)) -eq 0 ]; then
                      echo "  Still waiting... ($RETRY_COUNT/$MAX_RETRIES)"
                    fi
                    sleep 2
                  done
                  
                  if [ "$REDIS_READY" = "false" ]; then
                    echo "‚ö†Ô∏è  Redis took too long to start (waited $((MAX_RETRIES * 2)) seconds)"
                    echo "üí° Check container logs: docker logs investment_crm_redis"
                    echo "   Or manually start: cd $DOCKER_COMPOSE_DIR && $DOCKER_COMPOSE_CMD up -d redis"
                  fi
                  
                  # Final status check
                  POSTGRES_FINAL=$(docker ps --filter "name=investment_crm_db" --filter "status=running" --format "{{.Names}}" 2>/dev/null | grep -c "investment_crm_db" || echo "0")
                  REDIS_FINAL=$(docker ps --filter "name=investment_crm_redis" --filter "status=running" --format "{{.Names}}" 2>/dev/null | grep -c "investment_crm_redis" || echo "0")
                  
                  if [ "$POSTGRES_FINAL" = "1" ] && [ "$REDIS_FINAL" = "1" ]; then
                    echo "‚úÖ Both Docker services are running and ready"
                  elif [ "$POSTGRES_FINAL" = "1" ]; then
                    echo "‚ö†Ô∏è  PostgreSQL is running but Redis is not"
                  elif [ "$REDIS_FINAL" = "1" ]; then
                    echo "‚ö†Ô∏è  Redis is running but PostgreSQL is not"
                  else
                    echo "‚ùå Neither service is running"
                    echo "üí° Manual start command:"
                    echo "   cd $DOCKER_COMPOSE_DIR"
                    echo "   $DOCKER_COMPOSE_CMD up -d postgres redis"
                    echo "   docker ps  # Verify containers are running"
                  fi
                fi
              fi
            else
              echo "‚ö†Ô∏è  Docker is not installed. Skipping Docker service setup."
              echo "üí° Install Docker to use docker-compose services: https://docs.docker.com/get-docker/"
            fi
            
            # Check PostgreSQL client
            echo "üóÑÔ∏è  Checking database prerequisites..."
            if command -v psql &> /dev/null; then
              echo "‚úÖ PostgreSQL client is installed"
            else
              echo "‚ö†Ô∏è  PostgreSQL client (psql) not found. Database migrations may require manual setup."
            fi
            
            # Check process manager
            echo "‚öôÔ∏è  Checking process manager..."
            if command -v pm2 &> /dev/null; then
              echo "‚úÖ Process manager found: pm2"
            elif command -v systemctl &> /dev/null; then
              echo "‚úÖ Process manager found: systemd"
            else
              echo "‚ö†Ô∏è  No process manager found. Application will run in background mode."
            fi
            
            # Check port availability
            echo "üîå Checking port availability..."
            if command -v netstat &> /dev/null; then
              PORT_CHECK=$(netstat -tuln | grep ':3001' || echo 'available')
            elif command -v ss &> /dev/null; then
              PORT_CHECK=$(ss -tuln | grep ':3001' || echo 'available')
            else
              PORT_CHECK='unknown'
            fi
            if [ "$PORT_CHECK" != "available" ] && [ "$PORT_CHECK" != "unknown" ]; then
              echo "‚ö†Ô∏è  Port 3001 may be in use. Ensure the application can bind to this port."
            else
              echo "‚úÖ Port 3001 appears to be available"
            fi
          else
            # For GitHub-hosted runners, use SSH
            echo "üì° Testing SSH connection..."
            ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "echo 'SSH connection successful'" || {
              echo "‚ùå SSH connection failed"
              exit 1
            }
            
            # Check Node.js version
            echo "üì¶ Checking Node.js installation..."
            NODE_VERSION=$(ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "node --version 2>/dev/null || echo 'not_installed'")
            if [ "$NODE_VERSION" = "not_installed" ]; then
              echo "‚ùå Node.js is not installed on the server"
              exit 1
            fi
            echo "‚úÖ Node.js version: $NODE_VERSION"
            
            # Check npm
            echo "üì¶ Checking npm installation..."
            NPM_VERSION=$(ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "npm --version 2>/dev/null || echo 'not_installed'")
            if [ "$NPM_VERSION" = "not_installed" ]; then
              echo "‚ùå npm is not installed on the server"
              exit 1
            fi
            echo "‚úÖ npm version: $NPM_VERSION"
            
            # Check deployment directory
            echo "üìÅ Checking deployment directory..."
            ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
              if [ ! -d '${{ secrets.BACKEND_DEPLOY_PATH }}' ]; then
                echo 'Creating deployment directory...'
                mkdir -p '${{ secrets.BACKEND_DEPLOY_PATH }}/releases'
                mkdir -p '${{ secrets.BACKEND_DEPLOY_PATH }}/shared'
              fi
              
              if [ ! -w '${{ secrets.BACKEND_DEPLOY_PATH }}' ]; then
                echo '‚ùå Deployment directory is not writable'
                exit 1
              fi
              echo '‚úÖ Deployment directory is ready'
            " || exit 1
            
            # Check .env file
            echo "üîê Checking environment configuration..."
            if [ -n "${{ secrets.BACKEND_ENV_FILE }}" ]; then
              echo "‚úÖ BACKEND_ENV_FILE secret is set"
            else
              echo "‚ö†Ô∏è  BACKEND_ENV_FILE secret not set, checking for shared .env file..."
              ENV_EXISTS=$(ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
                if [ -f '${{ secrets.BACKEND_DEPLOY_PATH }}/shared/.env' ]; then
                  echo 'exists'
                else
                  echo 'missing'
                fi
              ")
              if [ "$ENV_EXISTS" = "missing" ]; then
                echo "‚ùå No .env file found. Please set BACKEND_ENV_FILE secret or create shared/.env file"
                exit 1
              fi
              echo "‚úÖ Shared .env file found"
            fi
            
            # Check database prerequisites
            echo "üóÑÔ∏è  Checking database prerequisites..."
            ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
              if command -v psql &> /dev/null; then
                echo '‚úÖ PostgreSQL client is installed'
              else
                echo '‚ö†Ô∏è  PostgreSQL client (psql) not found. Database migrations may require manual setup.'
              fi
            " || true
            
            # Check process manager
            echo "‚öôÔ∏è  Checking process manager..."
            PM_MANAGER=$(ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
              if command -v pm2 &> /dev/null; then
                echo 'pm2'
              elif command -v systemctl &> /dev/null; then
                echo 'systemd'
              else
                echo 'none'
              fi
            ")
            if [ "$PM_MANAGER" = "none" ]; then
              echo "‚ö†Ô∏è  No process manager found. Application will run in background mode."
            else
              echo "‚úÖ Process manager found: $PM_MANAGER"
            fi
            
            # Check port availability
            echo "üîå Checking port availability..."
            PORT_CHECK=$(ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
              if command -v netstat &> /dev/null; then
                netstat -tuln | grep ':3001' || echo 'available'
              elif command -v ss &> /dev/null; then
                ss -tuln | grep ':3001' || echo 'available'
              else
                echo 'unknown'
              fi
            ")
            if [ "$PORT_CHECK" != "available" ] && [ "$PORT_CHECK" != "unknown" ]; then
              echo "‚ö†Ô∏è  Port 3001 may be in use. Ensure the application can bind to this port."
            else
              echo "‚úÖ Port 3001 appears to be available"
            fi
          fi
          
          echo "‚úÖ All prerequisites validated successfully!"

  deploy:
    name: Deploy Backend to Server
    runs-on: ${{ vars.USE_SELF_HOSTED_RUNNER == 'true' && 'self-hosted' || 'ubuntu-latest' }}
    needs: [build, pre-deploy-check]
    if: |
      (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')) ||
      (github.event_name == 'workflow_dispatch' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'))
    environment:
      name: production
    
    env:
      USE_SELF_HOSTED: ${{ vars.USE_SELF_HOSTED_RUNNER == 'true' }}
      WORKSPACE_PATH: ${{ github.workspace }}
      DEPLOY_PATH: ${{ secrets.BACKEND_DEPLOY_PATH || '/var/www/investment-crm/backend' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: backend-build
          path: .

      - name: Setup SSH (for GitHub-hosted runners only)
        if: env.USE_SELF_HOSTED != 'true'
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts (for GitHub-hosted runners only)
        if: env.USE_SELF_HOSTED != 'true'
        run: |
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Create .env file from secret
        run: |
          if [ -n "${{ secrets.BACKEND_ENV_FILE }}" ]; then
            echo "${{ secrets.BACKEND_ENV_FILE }}" > backend-env.txt
          fi

      - name: Setup PATH for self-hosted runner
        if: vars.USE_SELF_HOSTED_RUNNER == 'true'
        run: |
          # Source common profile files to ensure PATH is set correctly
          [ -f /etc/profile ] && source /etc/profile
          [ -f ~/.bashrc ] && source ~/.bashrc
          [ -f ~/.bash_profile ] && source ~/.bash_profile
          [ -f ~/.profile ] && source ~/.profile
          
          # Add common Node.js paths to PATH
          export PATH="/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin:$PATH"
          export PATH="$HOME/.nvm/versions/node/*/bin:$PATH"
          export PATH="/opt/nodejs/bin:$PATH"
          
          # Find Node.js and npm if not in PATH (including root's installation)
          if ! command -v node &> /dev/null; then
            NODE_CMD=$(find /usr/local /usr /opt /root -name node -type f -executable 2>/dev/null | head -1)
            if [ -z "$NODE_CMD" ]; then
              # Try using root's PATH
              ROOT_NODE=$(sudo -n sh -c 'command -v node' 2>/dev/null || echo "")
              if [ -n "$ROOT_NODE" ] && [ -f "$ROOT_NODE" ]; then
                NODE_CMD="$ROOT_NODE"
              fi
            fi
            if [ -n "$NODE_CMD" ]; then
              echo "NODE_CMD=$NODE_CMD" >> $GITHUB_ENV
              echo "PATH=$(dirname $NODE_CMD):$PATH" >> $GITHUB_ENV
            fi
          fi
          
          if ! command -v npm &> /dev/null; then
            NPM_CMD=$(find /usr/local /usr /opt /root -name npm -type f -executable 2>/dev/null | head -1)
            if [ -z "$NPM_CMD" ]; then
              # Try using root's PATH
              ROOT_NPM=$(sudo -n sh -c 'command -v npm' 2>/dev/null || echo "")
              if [ -n "$ROOT_NPM" ] && [ -f "$ROOT_NPM" ]; then
                NPM_CMD="$ROOT_NPM"
              fi
            fi
            if [ -n "$NPM_CMD" ]; then
              echo "NPM_CMD=$NPM_CMD" >> $GITHUB_ENV
              echo "PATH=$(dirname $NPM_CMD):$PATH" >> $GITHUB_ENV
            fi
          fi
          
          # Verify Node.js and npm are accessible
          echo "Node.js: $(command -v node || echo 'not found')"
          echo "npm: $(command -v npm || echo 'not found')"
          if [ -n "$NODE_CMD" ]; then
            $NODE_CMD --version || echo "Node.js version check failed"
          fi
          if [ -n "$NPM_CMD" ]; then
            $NPM_CMD --version || echo "npm version check failed"
          fi

      - name: Deploy to server
        run: |
          # Set deployment path (already set in env)
          DEPLOY_PATH="${DEPLOY_PATH:-/var/www/investment-crm/backend}"
          
          if [ "$USE_SELF_HOSTED" = "true" ]; then
            # Self-hosted runner: deploy directly
            echo "üöÄ Deploying on self-hosted runner..."
            
            # Source profile to ensure PATH is correct
            [ -f /etc/profile ] && source /etc/profile
            [ -f ~/.bashrc ] && source ~/.bashrc
            [ -f ~/.profile ] && source ~/.profile
            
            # Use NPM_CMD from environment or find it (including root's installation)
            if [ -z "$NPM_CMD" ]; then
              if command -v npm &> /dev/null; then
                NPM_CMD="npm"
              else
                NPM_CMD=$(find /usr/local /usr /opt /root -name npm -type f -executable 2>/dev/null | head -1)
                if [ -z "$NPM_CMD" ]; then
                  # Try using root's PATH
                  ROOT_NPM=$(sudo -n sh -c 'command -v npm' 2>/dev/null || echo "")
                  if [ -n "$ROOT_NPM" ] && [ -f "$ROOT_NPM" ]; then
                    NPM_CMD="$ROOT_NPM"
                  fi
                fi
              fi
            fi
            
            if [ -z "$NPM_CMD" ]; then
              echo "‚ùå Error: npm not found"
              echo "üí° Tip: Run this on your server as root to fix:"
              echo "   sudo ln -s \$(sudo which npm) /usr/local/bin/npm"
              echo "   sudo ln -s \$(sudo which node) /usr/local/bin/node"
              exit 1
            fi
            
            echo "Using npm at: $NPM_CMD"
            
            # Create deployment directory
            mkdir -p "$DEPLOY_PATH/releases"
            mkdir -p "$DEPLOY_PATH/shared"
            
            # Move build artifact
            mv backend-deploy.tar.gz "$DEPLOY_PATH/releases/"
            
            # Copy docker-compose.yml to deployment directory for easy access
            if [ -f "$WORKSPACE_PATH/backend/docker-compose.yml" ]; then
              echo "üìã Copying docker-compose.yml to deployment directory..."
              mkdir -p "$DEPLOY_PATH"
              cp "$WORKSPACE_PATH/backend/docker-compose.yml" "$DEPLOY_PATH/docker-compose.yml" || echo "‚ö†Ô∏è  Failed to copy docker-compose.yml (non-critical)"
            fi
            
            # Extract and deploy
            cd "$DEPLOY_PATH/releases"
            TIMESTAMP=$(date +%Y%m%d%H%M%S)
            mkdir -p "$TIMESTAMP"
            tar -xzf backend-deploy.tar.gz -C "$TIMESTAMP"
            rm backend-deploy.tar.gz
            
            # Install production dependencies
            cd "$TIMESTAMP"
            if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
              sudo $NPM_CMD ci --production
            else
              $NPM_CMD ci --production
            fi
            
            # Create .env file from secret or use shared .env
            if [ -f "$WORKSPACE_PATH/backend-env.txt" ]; then
              cp "$WORKSPACE_PATH/backend-env.txt" .env
              rm "$WORKSPACE_PATH/backend-env.txt"
              echo "‚úÖ Created .env file from BACKEND_ENV_FILE secret"
            elif [ -f "$DEPLOY_PATH/shared/.env" ]; then
              cp "$DEPLOY_PATH/shared/.env" .env
              echo "‚úÖ Using shared .env file"
            else
              echo "‚ùå Error: No .env file found. Deployment cannot continue."
              exit 1
            fi
            
            # Validate required environment variables
            echo "üîç Validating environment variables..."
            set -a
            source .env
            set +a
            if [ -z "$DATABASE_URL" ]; then
              echo "‚ùå Error: DATABASE_URL is not set in .env file"
              exit 1
            fi
            if [ -z "$JWT_SECRET" ]; then
              echo "‚ùå Error: JWT_SECRET is not set in .env file"
              exit 1
            fi
            echo "‚úÖ Required environment variables are set"
            
            # Test database connectivity
            echo "üóÑÔ∏è  Testing database connectivity..."
            # If DATABASE_URL points to localhost, try to connect via Docker container
            if echo "$DATABASE_URL" | grep -q "localhost\|127.0.0.1"; then
              echo "üîç DATABASE_URL points to localhost, checking Docker container..."
              if docker ps --filter "name=investment_crm_db" --filter "status=running" --format "{{.Names}}" | grep -q "investment_crm_db"; then
                echo "‚úÖ PostgreSQL container is running"
                # Try to test connection via docker exec
                if docker exec investment_crm_db pg_isready -U postgres &> /dev/null; then
                  echo "‚úÖ Database is ready (via Docker)"
                else
                  echo "‚ö†Ô∏è  Database container is running but not ready yet"
                fi
              else
                echo "‚ö†Ô∏è  PostgreSQL container is not running, but DATABASE_URL points to localhost"
                echo "üí° Make sure Docker services are started or update DATABASE_URL to point to the correct host"
              fi
            fi
            
            if command -v psql &> /dev/null; then
              DB_CONN=$(echo "$DATABASE_URL" | sed -E 's|postgresql://([^:]+):([^@]+)@([^:]+):([^/]+)/(.+)|host=\3 port=\4 user=\1 password=\2 dbname=\5|')
              if psql "$DB_CONN" -c 'SELECT 1' &> /dev/null; then
                echo "‚úÖ Database connection successful (via psql)"
              else
                echo "‚ö†Ô∏è  Could not verify database connection with psql, but continuing..."
              fi
            else
              echo "‚ö†Ô∏è  psql not available, skipping database connectivity test"
            fi
            
            # Generate Prisma client
            echo "üì¶ Generating Prisma client..."
            if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
              sudo $NPM_CMD run db:generate || {
                echo "‚ùå Error: Failed to generate Prisma client"
                exit 1
              }
            else
              $NPM_CMD run db:generate || {
                echo "‚ùå Error: Failed to generate Prisma client"
                exit 1
              }
            fi
            
            # Run database migrations
            echo "üîÑ Running database migrations..."
            if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
              sudo $NPM_CMD exec prisma migrate deploy || {
                echo "‚ùå Error: Database migration failed"
                exit 1
              }
            else
              $NPM_CMD exec prisma migrate deploy || {
                echo "‚ùå Error: Database migration failed"
                exit 1
              }
            fi
            echo "‚úÖ Database migrations completed"
            
            # Create symlink to current release
            cd "$DEPLOY_PATH"
            rm -f current
            ln -s "releases/$TIMESTAMP" current
            
            # Restart application
            if command -v pm2 &> /dev/null; then
              pm2 restart investment-crm-backend || pm2 start current/dist/index.js --name investment-crm-backend
            elif command -v systemctl &> /dev/null; then
              sudo systemctl restart investment-crm-backend || echo "Service not configured"
            else
              # Fallback: kill existing process and start new one
              pkill -f 'node.*dist/index.js' || true
              cd current
              if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
                sudo nohup $NPM_CMD start > /dev/null 2>&1 &
              else
                nohup $NPM_CMD start > /dev/null 2>&1 &
              fi
            fi
            
            # Cleanup old releases (keep last 5)
            cd "$DEPLOY_PATH/releases"
            ls -t | tail -n +6 | xargs -r rm -rf
          else
            # GitHub-hosted runner: deploy via SSH
            echo "üöÄ Deploying via SSH..."
            
            # Create deployment directory on server
            ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
              mkdir -p $DEPLOY_PATH/releases
              mkdir -p $DEPLOY_PATH/shared
            "
            
            # Upload build artifact
            scp backend-deploy.tar.gz ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:$DEPLOY_PATH/releases/
            
            # Upload .env file if provided
            if [ -f backend-env.txt ]; then
              scp backend-env.txt ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:$DEPLOY_PATH/releases/backend-env.txt
            fi
            
            # Extract and deploy on server
            ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
              cd $DEPLOY_PATH/releases
              TIMESTAMP=\$(date +%Y%m%d%H%M%S)
              mkdir -p \$TIMESTAMP
              tar -xzf backend-deploy.tar.gz -C \$TIMESTAMP
              rm backend-deploy.tar.gz
              
              # Install production dependencies
              cd \$TIMESTAMP
              ${NPM_CMD:-npm} ci --production
              
              # Create .env file from secret or use shared .env
              if [ -f ../backend-env.txt ]; then
                cp ../backend-env.txt .env
                rm ../backend-env.txt
                echo '‚úÖ Created .env file from BACKEND_ENV_FILE secret'
              elif [ -f $DEPLOY_PATH/shared/.env ]; then
                cp $DEPLOY_PATH/shared/.env .env
                echo '‚úÖ Using shared .env file'
              else
                echo '‚ùå Error: No .env file found. Deployment cannot continue.'
                exit 1
              fi
              
              # Validate required environment variables
              echo 'üîç Validating environment variables...'
              source .env
              if [ -z \"\$DATABASE_URL\" ]; then
                echo '‚ùå Error: DATABASE_URL is not set in .env file'
                exit 1
              fi
              if [ -z \"\$JWT_SECRET\" ]; then
                echo '‚ùå Error: JWT_SECRET is not set in .env file'
                exit 1
              fi
              echo '‚úÖ Required environment variables are set'
              
              # Test database connectivity
              echo 'üóÑÔ∏è  Testing database connectivity...'
              if command -v psql &> /dev/null; then
                DB_CONN=\$(echo \$DATABASE_URL | sed -E 's|postgresql://([^:]+):([^@]+)@([^:]+):([^/]+)/(.+)|host=\3 port=\4 user=\1 password=\2 dbname=\5|')
                if psql \"\$DB_CONN\" -c 'SELECT 1' &> /dev/null; then
                  echo '‚úÖ Database connection successful'
                else
                  echo '‚ö†Ô∏è  Could not verify database connection with psql, but continuing...'
                fi
              else
                echo '‚ö†Ô∏è  psql not available, skipping database connectivity test'
              fi
              
              # Generate Prisma client
              echo 'üì¶ Generating Prisma client...'
              ${NPM_CMD:-npm} run db:generate || {
                echo '‚ùå Error: Failed to generate Prisma client'
                exit 1
              }
              
              # Run database migrations
              echo 'üîÑ Running database migrations...'
              npx prisma migrate deploy || {
                echo '‚ùå Error: Database migration failed'
                exit 1
              }
              echo '‚úÖ Database migrations completed'
              
              # Create symlink to current release
              cd $DEPLOY_PATH
              rm -f current
              ln -s releases/\$TIMESTAMP current
              
              # Restart application
              if command -v pm2 &> /dev/null; then
                pm2 restart investment-crm-backend || pm2 start current/dist/index.js --name investment-crm-backend
              elif command -v systemctl &> /dev/null; then
                sudo systemctl restart investment-crm-backend || echo 'Service not configured'
              else
                # Fallback: kill existing process and start new one
                pkill -f 'node.*dist/index.js' || true
                cd current
                nohup ${NPM_CMD:-npm} start > /dev/null 2>&1 &
              fi
              
              # Cleanup old releases (keep last 5)
              cd releases
              ls -t | tail -n +6 | xargs -r rm -rf
            "
          fi

      - name: Health check
        run: |
          sleep 10
          curl -f ${{ secrets.BACKEND_URL || 'http://localhost:3001' }}/health || exit 1


