name: Backend Deployment

on:
  push:
    branches:
      - main
      - master
    paths:
      - 'backend/**'
      - 'backend/.github/workflows/backend-deploy.yml'
  pull_request:
    branches:
      - main
      - master
    paths:
      - 'backend/**'
      - 'backend/.github/workflows/backend-deploy.yml'
  workflow_dispatch:

env:
  NODE_VERSION: '20'

jobs:
  test:
    name: Test Backend
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: investment_crm_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        id: setup-node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: package-lock.json
        continue-on-error: true

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npm run db:generate
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/investment_crm_test

      - name: Run database migrations
        run: npx prisma migrate deploy
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/investment_crm_test

      - name: Run linter
        run: npm run lint

      - name: Type check
        run: npm run type-check

      - name: Run tests
        run: npm test
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/investment_crm_test
          NODE_ENV: test
          JWT_SECRET: test-secret-key

  build:
    name: Build Backend
    runs-on: ubuntu-latest
    needs: test
    if: |
      always() &&
      (needs.test.result == 'success' || needs.test.result == 'skipped') &&
      ((github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')) ||
       (github.event_name == 'workflow_dispatch' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')))
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify package-lock.json exists
        run: |
          if [ ! -f package-lock.json ]; then
            echo "Warning: package-lock.json not found, cache will be skipped"
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npm run db:generate

      - name: Build application
        run: npm run build

      - name: Create deployment package
        run: |
          mkdir -p deploy
          cp -r dist deploy/
          cp -r prisma deploy/
          cp package.json deploy/
          cp package-lock.json deploy/
          tar -czf backend-deploy.tar.gz -C deploy .
          rm -rf deploy

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: backend-build
          path: backend-deploy.tar.gz
          retention-days: 1

  pre-deploy-check:
    name: Pre-Deployment Validation
    runs-on: ${{ vars.USE_SELF_HOSTED_RUNNER == 'true' && 'self-hosted' || 'ubuntu-latest' }}
    needs: build
    if: |
      (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')) ||
      (github.event_name == 'workflow_dispatch' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'))
    
    env:
      USE_SELF_HOSTED: ${{ vars.USE_SELF_HOSTED_RUNNER == 'true' }}
      WORKSPACE_PATH: $WORKSPACE_PATH
      DEPLOY_PATH: ${{ secrets.BACKEND_DEPLOY_PATH || '/var/www/investment-crm/backend' }}
    
    steps:
      - name: Setup SSH (for GitHub-hosted runners only)
        if: env.USE_SELF_HOSTED != 'true'
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts (for GitHub-hosted runners only)
        if: env.USE_SELF_HOSTED != 'true'
        run: |
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Setup environment for self-hosted runner
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          echo "‚úÖ Running on self-hosted runner - no SSH needed"
          [ -f /etc/profile ] && source /etc/profile
          [ -f ~/.bashrc ] && source ~/.bashrc
          [ -f ~/.bash_profile ] && source ~/.bash_profile
          [ -f ~/.profile ] && source ~/.profile
          export PATH="/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin:$PATH"
          export PATH="$HOME/.nvm/versions/node/*/bin:$PATH"
          export PATH="/opt/nodejs/bin:$PATH"

      - name: Validate Node.js (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          echo "üì¶ Checking Node.js installation..."
          echo "Current user: $(whoami)"
          echo "Current PATH: $PATH"
          
          NODE_CMD=""
          if [ -d /opt/nodejs/bin ]; then
            echo "Checking /opt/nodejs/bin directory..."
            ls -la /opt/nodejs/bin/ 2>/dev/null | head -10 || echo "Cannot list /opt/nodejs/bin"
            if [ -f /opt/nodejs/bin/node ]; then
              if [ -x /opt/nodejs/bin/node ]; then
                NODE_CMD="/opt/nodejs/bin/node"
                echo "‚úÖ Found executable node in /opt/nodejs/bin"
              else
                echo "‚ö†Ô∏è  Found node in /opt/nodejs/bin but not executable"
                if sudo chmod +x /opt/nodejs/bin/node 2>/dev/null; then
                  NODE_CMD="/opt/nodejs/bin/node"
                  echo "‚úÖ Made node executable"
                fi
              fi
            fi
          fi
          
          if [ -z "$NODE_CMD" ]; then
            if command -v node &> /dev/null; then
              NODE_CMD="node"
              echo "‚úÖ Found node via command -v"
            elif [ -f /usr/local/bin/node ]; then
              NODE_CMD="/usr/local/bin/node"
              echo "‚úÖ Found node in /usr/local/bin"
            elif [ -f /usr/bin/node ]; then
              NODE_CMD="/usr/bin/node"
              echo "‚úÖ Found node in /usr/bin"
            fi
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            if [ -d /root/.nvm/versions/node ]; then
              NODE_CMD=$(find /root/.nvm/versions/node -name node -type f -executable 2>/dev/null | sort -V | tail -1)
            fi
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            if [ -d "$HOME/.nvm/versions/node" ]; then
              NODE_CMD=$(find "$HOME/.nvm/versions/node" -name node -type f -executable 2>/dev/null | sort -V | tail -1)
            fi
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            NODE_CMD=$(find /usr/local/bin /usr/bin /opt /root/.nvm /root/.local /root/bin -name node -type f -executable 2>/dev/null | head -1)
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            ROOT_NODE=$(sudo sh -c 'command -v node' 2>/dev/null || echo "")
            if [ -z "$ROOT_NODE" ]; then
              ROOT_NODE=$(sudo -n sh -c 'command -v node' 2>/dev/null || echo "")
            fi
            if [ -n "$ROOT_NODE" ] && [ -f "$ROOT_NODE" ]; then
              NODE_CMD="$ROOT_NODE"
              echo "Found node via root's PATH: $NODE_CMD"
            fi
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            if [ -f /root/.bashrc ]; then
              ROOT_NVM_DIR=$(grep -o 'NVM_DIR="[^"]*"' /root/.bashrc 2>/dev/null | cut -d'"' -f2 || echo "")
              if [ -n "$ROOT_NVM_DIR" ] && [ -d "$ROOT_NVM_DIR/versions/node" ]; then
                NODE_CMD=$(find "$ROOT_NVM_DIR/versions/node" -name node -type f -executable 2>/dev/null | sort -V | tail -1)
              fi
            fi
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            ROOT_NODE_PATH=$(sudo sh -c 'which node 2>&1' 2>/dev/null | grep -v "not found" | head -1 || echo "")
            if [ -n "$ROOT_NODE_PATH" ] && [ "$ROOT_NODE_PATH" != "" ]; then
              if sudo test -f "$ROOT_NODE_PATH" 2>/dev/null; then
                echo "‚úÖ Found Node.js at: $ROOT_NODE_PATH (requires sudo)"
                NODE_CMD="$ROOT_NODE_PATH"
                echo "USE_SUDO_FOR_NODE=1" >> $GITHUB_ENV
                echo "‚úÖ Will use sudo for all Node.js/npm commands"
              fi
            fi
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            ROOT_NODE_PATH=$(sudo sh -c 'which node 2>&1' 2>/dev/null | grep -v "not found" | head -1 || echo "")
            if [ -n "$ROOT_NODE_PATH" ] && sudo test -f "$ROOT_NODE_PATH" 2>/dev/null; then
              echo "Found Node.js at: $ROOT_NODE_PATH"
              if sudo ln -sf "$ROOT_NODE_PATH" /usr/local/bin/node 2>/dev/null; then
                sudo chmod +x /usr/local/bin/node 2>/dev/null
                if [ -f /usr/local/bin/node ] && [ -x /usr/local/bin/node ]; then
                  NODE_CMD="/usr/local/bin/node"
                  echo "‚úÖ Symlink created successfully"
                fi
              fi
            fi
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            echo "‚ùå Node.js is not installed on the server or not accessible"
            exit 1
          fi
          
          if [ ! -x "$NODE_CMD" ]; then
            if sudo chmod +x "$NODE_CMD" 2>/dev/null; then
              echo "‚úÖ Made Node.js executable"
            else
              echo "‚ùå Node.js found at $NODE_CMD but cannot be executed"
              exit 1
            fi
          fi
          
          if [ "${USE_SUDO_FOR_NODE:-}" = "1" ]; then
            NODE_VERSION=$(sudo $NODE_CMD --version 2>/dev/null || echo "unknown")
          else
            NODE_VERSION=$($NODE_CMD --version 2>/dev/null || sudo $NODE_CMD --version 2>/dev/null || echo "unknown")
          fi
          echo "‚úÖ Node.js found at: $NODE_CMD"
          echo "‚úÖ Node.js version: $NODE_VERSION"
          echo "NODE_CMD=$NODE_CMD" >> $GITHUB_ENV

      - name: Validate npm (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          echo "üì¶ Checking npm installation..."
          NPM_CMD=""
          if [ -f /opt/nodejs/bin/npm ] && [ -x /opt/nodejs/bin/npm ]; then
            NPM_CMD="/opt/nodejs/bin/npm"
          elif command -v npm &> /dev/null; then
            NPM_CMD="npm"
          elif [ -f /usr/local/bin/npm ]; then
            NPM_CMD="/usr/local/bin/npm"
          elif [ -f /usr/bin/npm ]; then
            NPM_CMD="/usr/bin/npm"
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            if [ -n "$NODE_CMD" ] && [ -d "$(dirname "$NODE_CMD")" ]; then
              NPM_CMD="$(dirname "$NODE_CMD")/npm"
              [ ! -f "$NPM_CMD" ] && NPM_CMD=""
            elif [ -d /root/.nvm/versions/node ]; then
              NPM_CMD=$(find /root/.nvm/versions/node -name npm -type f -executable 2>/dev/null | sort -V | tail -1)
            fi
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            if [ -d "$HOME/.nvm/versions/node" ]; then
              NPM_CMD=$(find "$HOME/.nvm/versions/node" -name npm -type f -executable 2>/dev/null | sort -V | tail -1)
            fi
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            NPM_CMD=$(find /usr/local/bin /usr/bin /opt /root/.nvm /root/.local /root/bin -name npm -type f -executable 2>/dev/null | head -1)
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            ROOT_NPM=$(sudo sh -c 'command -v npm' 2>/dev/null || echo "")
            [ -z "$ROOT_NPM" ] && ROOT_NPM=$(sudo -n sh -c 'command -v npm' 2>/dev/null || echo "")
            if [ -n "$ROOT_NPM" ] && [ -f "$ROOT_NPM" ]; then
              NPM_CMD="$ROOT_NPM"
            fi
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            if [ -f /root/.bashrc ]; then
              ROOT_NVM_DIR=$(grep -o 'NVM_DIR="[^"]*"' /root/.bashrc 2>/dev/null | cut -d'"' -f2 || echo "")
              if [ -n "$ROOT_NVM_DIR" ] && [ -d "$ROOT_NVM_DIR/versions/node" ]; then
                NPM_CMD=$(find "$ROOT_NVM_DIR/versions/node" -name npm -type f -executable 2>/dev/null | sort -V | tail -1)
              fi
            fi
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            ROOT_NPM_PATH=$(sudo sh -c 'which npm 2>&1' 2>/dev/null | grep -v "not found" | head -1 || echo "")
            if [ -n "$ROOT_NPM_PATH" ] && [ "$ROOT_NPM_PATH" != "" ]; then
              if sudo test -f "$ROOT_NPM_PATH" 2>/dev/null; then
                echo "‚úÖ Found npm at: $ROOT_NPM_PATH (requires sudo)"
                NPM_CMD="$ROOT_NPM_PATH"
                if [ "${USE_SUDO_FOR_NODE:-}" != "1" ]; then
                  echo "USE_SUDO_FOR_NODE=1" >> $GITHUB_ENV
                fi
              fi
            fi
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            ROOT_NPM_PATH=$(sudo sh -c 'which npm 2>&1' 2>/dev/null | grep -v "not found" | head -1 || echo "")
            if [ -n "$ROOT_NPM_PATH" ] && sudo test -f "$ROOT_NPM_PATH" 2>/dev/null; then
              if sudo ln -sf "$ROOT_NPM_PATH" /usr/local/bin/npm 2>/dev/null; then
                sudo chmod +x /usr/local/bin/npm 2>/dev/null
                if [ -f /usr/local/bin/npm ] && [ -x /usr/local/bin/npm ]; then
                  NPM_CMD="/usr/local/bin/npm"
                fi
              fi
            fi
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            echo "‚ùå npm is not installed on the server or not accessible"
            exit 1
          fi
          
          if [ ! -x "$NPM_CMD" ]; then
            if sudo chmod +x "$NPM_CMD" 2>/dev/null; then
              echo "‚úÖ Made npm executable"
            else
              echo "‚ùå npm found at $NPM_CMD but cannot be executed"
              exit 1
            fi
          fi
          
          if [ "${USE_SUDO_FOR_NODE:-}" = "1" ]; then
            NPM_VERSION=$(sudo $NPM_CMD --version 2>/dev/null || echo "unknown")
          else
            NPM_VERSION=$($NPM_CMD --version 2>/dev/null || sudo $NPM_CMD --version 2>/dev/null || echo "unknown")
          fi
          echo "‚úÖ npm found at: $NPM_CMD"
          echo "‚úÖ npm version: $NPM_VERSION"
          echo "NPM_CMD=$NPM_CMD" >> $GITHUB_ENV

      - name: Validate deployment directory and Docker (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          echo "üìÅ Checking deployment directory..."
          DEPLOY_PATH="$DEPLOY_PATH"
          if [ ! -d "$DEPLOY_PATH" ]; then
            mkdir -p "$DEPLOY_PATH/releases"
            mkdir -p "$DEPLOY_PATH/shared"
          fi
          if [ ! -w "$DEPLOY_PATH" ]; then
            echo "‚ùå Deployment directory is not writable"
            exit 1
          fi
          echo "‚úÖ Deployment directory is ready"
          
          echo "üîê Checking environment configuration..."
          if [ -n "${{ secrets.BACKEND_ENV_FILE }}" ]; then
            echo "‚úÖ BACKEND_ENV_FILE secret is set"
          elif [ -f "$DEPLOY_PATH/shared/.env" ]; then
            echo "‚úÖ Shared .env file found"
          else
            echo "‚ùå No .env file found"
            exit 1
          fi
          
          echo "üê≥ Checking Docker and services..."
          if command -v docker &> /dev/null; then
            echo "‚úÖ Docker is installed"
            if command -v docker-compose &> /dev/null; then
              DOCKER_COMPOSE_CMD="docker-compose"
            elif docker compose version &> /dev/null; then
              DOCKER_COMPOSE_CMD="docker compose"
            else
              if command -v apt-get &> /dev/null; then
                sudo apt-get update && sudo apt-get install -y docker-compose-plugin 2>/dev/null || true
                DOCKER_COMPOSE_CMD="docker compose"
              fi
            fi
            
            if [ -n "$DOCKER_COMPOSE_CMD" ]; then
              # Check workspace root first (backend and frontend are separate repos)
              if [ -f "$WORKSPACE_PATH/docker-compose.yml" ]; then
                DOCKER_COMPOSE_FILE="$WORKSPACE_PATH/docker-compose.yml"
                DOCKER_COMPOSE_DIR="$WORKSPACE_PATH"
              elif [ -f "$DEPLOY_PATH/docker-compose.yml" ]; then
                DOCKER_COMPOSE_FILE="$DEPLOY_PATH/docker-compose.yml"
                DOCKER_COMPOSE_DIR="$DEPLOY_PATH"
              elif [ -f "$DEPLOY_PATH/current/docker-compose.yml" ]; then
                DOCKER_COMPOSE_FILE="$DEPLOY_PATH/current/docker-compose.yml"
                DOCKER_COMPOSE_DIR="$DEPLOY_PATH/current"
              fi
              
              if [ -n "$DOCKER_COMPOSE_FILE" ]; then
                cd "$DOCKER_COMPOSE_DIR"
                POSTGRES_RUNNING=$(docker ps --filter "name=investment_crm_db" --filter "status=running" --format "{{.Names}}" 2>/dev/null | grep -c "investment_crm_db" || echo "0")
                REDIS_RUNNING=$(docker ps --filter "name=investment_crm_redis" --filter "status=running" --format "{{.Names}}" 2>/dev/null | grep -c "investment_crm_redis" || echo "0")
                
                if [ "$POSTGRES_RUNNING" = "0" ] || [ "$REDIS_RUNNING" = "0" ]; then
                  echo "üöÄ Starting Docker services..."
                  if [ "${USE_SUDO_FOR_NODE:-}" = "1" ]; then
                    sudo $DOCKER_COMPOSE_CMD up -d postgres redis 2>&1 || $DOCKER_COMPOSE_CMD up -d postgres redis 2>&1 || exit 1
                  else
                    $DOCKER_COMPOSE_CMD up -d postgres redis 2>&1 || exit 1
                  fi
                  sleep 3
                  
                  RETRY_COUNT=0
                  while [ $RETRY_COUNT -lt 30 ]; do
                    if docker exec investment_crm_db pg_isready -U postgres &> /dev/null 2>&1; then
                      echo "‚úÖ PostgreSQL is ready"
                      break
                    fi
                    RETRY_COUNT=$((RETRY_COUNT + 1))
                    [ $((RETRY_COUNT % 5)) -eq 0 ] && echo "  Still waiting... ($RETRY_COUNT/30)"
                    sleep 2
                  done
                  
                  RETRY_COUNT=0
                  while [ $RETRY_COUNT -lt 30 ]; do
                    if docker exec investment_crm_redis redis-cli ping &> /dev/null 2>&1; then
                      echo "‚úÖ Redis is ready"
                      break
                    fi
                    RETRY_COUNT=$((RETRY_COUNT + 1))
                    [ $((RETRY_COUNT % 5)) -eq 0 ] && echo "  Still waiting... ($RETRY_COUNT/30)"
                    sleep 2
                  done
                else
                  echo "‚úÖ Docker services are already running"
                fi
              fi
            fi
          fi
          
          if command -v psql &> /dev/null; then
            echo "‚úÖ PostgreSQL client is installed"
          fi
          
          if command -v pm2 &> /dev/null; then
            echo "‚úÖ Process manager found: pm2"
          elif command -v systemctl &> /dev/null; then
            echo "‚úÖ Process manager found: systemd"
          fi

      - name: Validate server prerequisites (GitHub-hosted)
        if: env.USE_SELF_HOSTED != 'true'
        run: |
          echo "üì° Testing SSH connection..."
          ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "echo 'SSH connection successful'" || {
            echo "‚ùå SSH connection failed"
            exit 1
          }
          
          NODE_VERSION=$(ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "node --version 2>/dev/null || echo 'not_installed'")
          if [ "$NODE_VERSION" = "not_installed" ]; then
            echo "‚ùå Node.js is not installed on the server"
            exit 1
          fi
          echo "‚úÖ Node.js version: $NODE_VERSION"
          
          NPM_VERSION=$(ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "npm --version 2>/dev/null || echo 'not_installed'")
          if [ "$NPM_VERSION" = "not_installed" ]; then
            echo "‚ùå npm is not installed on the server"
            exit 1
          fi
          echo "‚úÖ npm version: $NPM_VERSION"
          
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
            if [ ! -d '${{ secrets.BACKEND_DEPLOY_PATH }}' ]; then
              mkdir -p '${{ secrets.BACKEND_DEPLOY_PATH }}/releases'
              mkdir -p '${{ secrets.BACKEND_DEPLOY_PATH }}/shared'
            fi
            if [ ! -w '${{ secrets.BACKEND_DEPLOY_PATH }}' ]; then
              echo '‚ùå Deployment directory is not writable'
              exit 1
            fi
            echo '‚úÖ Deployment directory is ready'
          " || exit 1
          
          if [ -n "${{ secrets.BACKEND_ENV_FILE }}" ]; then
            echo "‚úÖ BACKEND_ENV_FILE secret is set"
          else
            ENV_EXISTS=$(ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
              if [ -f '${{ secrets.BACKEND_DEPLOY_PATH }}/shared/.env' ]; then
                echo 'exists'
              else
                echo 'missing'
              fi
            ")
            if [ "$ENV_EXISTS" = "missing" ]; then
              echo "‚ùå No .env file found"
              exit 1
            fi
            echo "‚úÖ Shared .env file found"
          fi
          
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
            if command -v psql &> /dev/null; then
              echo '‚úÖ PostgreSQL client is installed'
            fi
          " || true
          
          PM_MANAGER=$(ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
            if command -v pm2 &> /dev/null; then
              echo 'pm2'
            elif command -v systemctl &> /dev/null; then
              echo 'systemd'
            else
              echo 'none'
            fi
          ")
          if [ "$PM_MANAGER" != "none" ]; then
            echo "‚úÖ Process manager found: $PM_MANAGER"
          fi
          
          echo "‚úÖ All prerequisites validated successfully!"

  deploy:
    name: Deploy Backend to Server
    runs-on: ${{ vars.USE_SELF_HOSTED_RUNNER == 'true' && 'self-hosted' || 'ubuntu-latest' }}
    needs: [build, pre-deploy-check]
    if: |
      (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')) ||
      (github.event_name == 'workflow_dispatch' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'))
    environment:
      name: production
    
    env:
      USE_SELF_HOSTED: ${{ vars.USE_SELF_HOSTED_RUNNER == 'true' }}
      WORKSPACE_PATH: ${{ github.workspace }}
      DEPLOY_PATH: ${{ secrets.BACKEND_DEPLOY_PATH || '/var/www/investment-crm/backend' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: backend-build
          path: .

      - name: Setup SSH (for GitHub-hosted runners only)
        if: env.USE_SELF_HOSTED != 'true'
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts (for GitHub-hosted runners only)
        if: env.USE_SELF_HOSTED != 'true'
        run: |
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Create .env file from secret
        run: |
          if [ -n "${{ secrets.BACKEND_ENV_FILE }}" ]; then
            echo "${{ secrets.BACKEND_ENV_FILE }}" > backend-env.txt
          fi

      - name: Setup PATH for self-hosted runner
        if: vars.USE_SELF_HOSTED_RUNNER == 'true'
        run: |
          # Source common profile files to ensure PATH is set correctly
          [ -f /etc/profile ] && source /etc/profile
          [ -f ~/.bashrc ] && source ~/.bashrc
          [ -f ~/.bash_profile ] && source ~/.bash_profile
          [ -f ~/.profile ] && source ~/.profile
          
          # Add common Node.js paths to PATH
          export PATH="/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin:$PATH"
          export PATH="$HOME/.nvm/versions/node/*/bin:$PATH"
          export PATH="/opt/nodejs/bin:$PATH"
          
          # Find Node.js and npm if not in PATH (including root's installation)
          if ! command -v node &> /dev/null; then
            NODE_CMD=$(find /usr/local /usr /opt /root -name node -type f -executable 2>/dev/null | head -1)
            if [ -z "$NODE_CMD" ]; then
              # Try using root's PATH
              ROOT_NODE=$(sudo -n sh -c 'command -v node' 2>/dev/null || echo "")
              if [ -n "$ROOT_NODE" ] && [ -f "$ROOT_NODE" ]; then
                NODE_CMD="$ROOT_NODE"
              fi
            fi
            if [ -n "$NODE_CMD" ]; then
              echo "NODE_CMD=$NODE_CMD" >> $GITHUB_ENV
              echo "PATH=$(dirname $NODE_CMD):$PATH" >> $GITHUB_ENV
            fi
          fi
          
          if ! command -v npm &> /dev/null; then
            NPM_CMD=$(find /usr/local /usr /opt /root -name npm -type f -executable 2>/dev/null | head -1)
            if [ -z "$NPM_CMD" ]; then
              # Try using root's PATH
              ROOT_NPM=$(sudo -n sh -c 'command -v npm' 2>/dev/null || echo "")
              if [ -n "$ROOT_NPM" ] && [ -f "$ROOT_NPM" ]; then
                NPM_CMD="$ROOT_NPM"
              fi
            fi
            if [ -n "$NPM_CMD" ]; then
              echo "NPM_CMD=$NPM_CMD" >> $GITHUB_ENV
              echo "PATH=$(dirname $NPM_CMD):$PATH" >> $GITHUB_ENV
            fi
          fi
          
          # Verify Node.js and npm are accessible
          echo "Node.js: $(command -v node || echo 'not found')"
          echo "npm: $(command -v npm || echo 'not found')"
          if [ -n "$NODE_CMD" ]; then
            $NODE_CMD --version || echo "Node.js version check failed"
          fi
          if [ -n "$NPM_CMD" ]; then
            $NPM_CMD --version || echo "npm version check failed"
          fi

      - name: Deploy to server
        run: |
          # Set deployment path (already set in env)
          DEPLOY_PATH="${DEPLOY_PATH:-/var/www/investment-crm/backend}"
          
          if [ "$USE_SELF_HOSTED" = "true" ]; then
            # Self-hosted runner: deploy directly
            echo "üöÄ Deploying on self-hosted runner..."
            
            # Source profile to ensure PATH is correct
            [ -f /etc/profile ] && source /etc/profile
            [ -f ~/.bashrc ] && source ~/.bashrc
            [ -f ~/.profile ] && source ~/.profile
            
            # Use NPM_CMD from environment or find it (including root's installation)
            if [ -z "$NPM_CMD" ]; then
              if command -v npm &> /dev/null; then
                NPM_CMD="npm"
              else
                NPM_CMD=$(find /usr/local /usr /opt /root -name npm -type f -executable 2>/dev/null | head -1)
                if [ -z "$NPM_CMD" ]; then
                  # Try using root's PATH
                  ROOT_NPM=$(sudo -n sh -c 'command -v npm' 2>/dev/null || echo "")
                  if [ -n "$ROOT_NPM" ] && [ -f "$ROOT_NPM" ]; then
                    NPM_CMD="$ROOT_NPM"
                  fi
                fi
              fi
            fi
            
            if [ -z "$NPM_CMD" ]; then
              echo "‚ùå Error: npm not found"
              echo "üí° Tip: Run this on your server as root to fix:"
              echo "   sudo ln -s \$(sudo which npm) /usr/local/bin/npm"
              echo "   sudo ln -s \$(sudo which node) /usr/local/bin/node"
              exit 1
            fi
            
            echo "Using npm at: $NPM_CMD"
            
            # Create deployment directory
            mkdir -p "$DEPLOY_PATH/releases"
            mkdir -p "$DEPLOY_PATH/shared"
            
            # Move build artifact
            mv backend-deploy.tar.gz "$DEPLOY_PATH/releases/"
            
            # Copy docker-compose.yml to deployment directory for easy access
            # Check workspace root first (backend and frontend are separate repos)
            if [ -f "$WORKSPACE_PATH/docker-compose.yml" ]; then
              echo "üìã Copying docker-compose.yml to deployment directory..."
              mkdir -p "$DEPLOY_PATH"
              cp "$WORKSPACE_PATH/docker-compose.yml" "$DEPLOY_PATH/docker-compose.yml" || echo "‚ö†Ô∏è  Failed to copy docker-compose.yml (non-critical)"
            fi
            
            # Extract and deploy
            cd "$DEPLOY_PATH/releases"
            TIMESTAMP=$(date +%Y%m%d%H%M%S)
            mkdir -p "$TIMESTAMP"
            tar -xzf backend-deploy.tar.gz -C "$TIMESTAMP"
            rm backend-deploy.tar.gz
            
            # Install production dependencies
            cd "$TIMESTAMP"
            RELEASE_DIR="$(pwd)"
            echo "üìÇ Release directory: $RELEASE_DIR"
            
            if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
              sudo $NPM_CMD ci --production
            else
              $NPM_CMD ci --production
            fi
            
            # Verify Prisma is installed
            if [ ! -f "node_modules/.bin/prisma" ]; then
              echo "‚ö†Ô∏è  Prisma binary not found after npm ci"
              echo "   Checking if prisma package is installed..."
              if [ -d "node_modules/prisma" ]; then
                echo "   ‚úÖ prisma package found in node_modules"
                echo "   Listing node_modules/.bin:"
                ls -la node_modules/.bin/ 2>/dev/null | head -10 || echo "   node_modules/.bin not found"
              else
                echo "   ‚ùå prisma package not found in node_modules"
                echo "   This might be because prisma is in devDependencies"
                echo "   Installing prisma as production dependency..."
                if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
                  sudo $NPM_CMD install prisma@^5.20.0 --save --no-save || true
                else
                  $NPM_CMD install prisma@^5.20.0 --save --no-save || true
                fi
              fi
            fi
            
            # Create .env file from secret or use shared .env
            if [ -f "$WORKSPACE_PATH/backend-env.txt" ]; then
              cp "$WORKSPACE_PATH/backend-env.txt" .env
              rm "$WORKSPACE_PATH/backend-env.txt"
              echo "‚úÖ Created .env file from BACKEND_ENV_FILE secret"
            elif [ -f "$DEPLOY_PATH/shared/.env" ]; then
              cp "$DEPLOY_PATH/shared/.env" .env
              echo "‚úÖ Using shared .env file"
            else
              echo "‚ùå Error: No .env file found. Deployment cannot continue."
              exit 1
            fi
            
            # Validate required environment variables
            echo "üîç Validating environment variables..."
            set -a
            source .env
            set +a
            if [ -z "$DATABASE_URL" ]; then
              echo "‚ùå Error: DATABASE_URL is not set in .env file"
              exit 1
            fi
            if [ -z "$JWT_SECRET" ]; then
              echo "‚ùå Error: JWT_SECRET is not set in .env file"
              exit 1
            fi
            echo "‚úÖ Required environment variables are set"
            
            # Ensure Docker services are running before database migration
            echo "üê≥ Ensuring Docker services are running..."
            
            # Check for Docker (try multiple methods)
            DOCKER_CMD=""
            if command -v docker &> /dev/null; then
              DOCKER_CMD="docker"
              echo "‚úÖ Docker is installed (found via command -v)"
            elif [ -f /usr/bin/docker ]; then
              DOCKER_CMD="/usr/bin/docker"
              echo "‚úÖ Docker is installed (found at /usr/bin/docker)"
            elif [ -f /usr/local/bin/docker ]; then
              DOCKER_CMD="/usr/local/bin/docker"
              echo "‚úÖ Docker is installed (found at /usr/local/bin/docker)"
            elif sudo command -v docker &> /dev/null; then
              DOCKER_CMD="sudo docker"
              echo "‚úÖ Docker is installed (found via sudo command -v)"
            else
              echo "‚ö†Ô∏è  Docker is not found in PATH"
              echo "   Trying to find Docker in common locations..."
              DOCKER_CMD=$(find /usr /opt -name docker -type f -executable 2>/dev/null | head -1)
              if [ -n "$DOCKER_CMD" ]; then
                echo "‚úÖ Docker found at: $DOCKER_CMD"
              else
                echo "‚ùå Docker is not installed or not accessible"
                echo "üí° Install Docker: https://docs.docker.com/get-docker/"
              fi
            fi
            
            if [ -n "$DOCKER_CMD" ]; then
              
              # Check if docker-compose is available
              DOCKER_COMPOSE_CMD=""
              if command -v docker-compose &> /dev/null; then
                DOCKER_COMPOSE_CMD="docker-compose"
                echo "‚úÖ Found docker-compose command"
              elif $DOCKER_CMD compose version &> /dev/null 2>&1; then
                DOCKER_COMPOSE_CMD="$DOCKER_CMD compose"
                echo "‚úÖ Found docker compose command"
              else
                echo "‚ö†Ô∏è  docker-compose not found, trying to install..."
                if command -v apt-get &> /dev/null; then
                  sudo apt-get update && sudo apt-get install -y docker-compose-plugin 2>/dev/null || true
                  if $DOCKER_CMD compose version &> /dev/null 2>&1; then
                    DOCKER_COMPOSE_CMD="$DOCKER_CMD compose"
                    echo "‚úÖ docker-compose installed successfully"
                  fi
                fi
              fi
              
              if [ -n "$DOCKER_COMPOSE_CMD" ]; then
                # Find docker-compose.yml
                DOCKER_COMPOSE_FILE=""
                DOCKER_COMPOSE_DIR=""
                
                echo "üîç Searching for docker-compose.yml..."
                # Check workspace root first (backend and frontend are separate repos)
                echo "  Checking: $WORKSPACE_PATH/docker-compose.yml"
                if [ -f "$WORKSPACE_PATH/docker-compose.yml" ]; then
                  DOCKER_COMPOSE_FILE="$WORKSPACE_PATH/docker-compose.yml"
                  DOCKER_COMPOSE_DIR="$WORKSPACE_PATH"
                  echo "‚úÖ Found docker-compose.yml at: $DOCKER_COMPOSE_FILE"
                elif [ -f "$DEPLOY_PATH/docker-compose.yml" ]; then
                  DOCKER_COMPOSE_FILE="$DEPLOY_PATH/docker-compose.yml"
                  DOCKER_COMPOSE_DIR="$DEPLOY_PATH"
                  echo "‚úÖ Found docker-compose.yml at: $DOCKER_COMPOSE_FILE"
                elif [ -f "$DEPLOY_PATH/current/docker-compose.yml" ]; then
                  DOCKER_COMPOSE_FILE="$DEPLOY_PATH/current/docker-compose.yml"
                  DOCKER_COMPOSE_DIR="$DEPLOY_PATH/current"
                  echo "‚úÖ Found docker-compose.yml at: $DOCKER_COMPOSE_FILE"
                else
                  echo "‚ö†Ô∏è  docker-compose.yml not found in expected locations"
                  echo "   Searched:"
                  echo "   - $WORKSPACE_PATH/docker-compose.yml"
                  echo "   - $DEPLOY_PATH/docker-compose.yml"
                  echo "   - $DEPLOY_PATH/current/docker-compose.yml"
                fi
                
                if [ -n "$DOCKER_COMPOSE_FILE" ] && [ -n "$DOCKER_COMPOSE_DIR" ]; then
                  echo "üìÇ Changing to directory: $DOCKER_COMPOSE_DIR"
                  cd "$DOCKER_COMPOSE_DIR"
                  
                  # Check if containers are running (try with sudo if needed)
                  POSTGRES_RUNNING="0"
                  DOCKER_USE_SUDO="0"
                  
                  echo "üîç Checking if PostgreSQL container is running..."
                  if $DOCKER_CMD ps --filter "name=investment_crm_db" --filter "status=running" --format "{{.Names}}" 2>/dev/null | grep -q "investment_crm_db"; then
                    POSTGRES_RUNNING="1"
                    echo "‚úÖ PostgreSQL container is running"
                  else
                    echo "‚ö†Ô∏è  PostgreSQL container is not running"
                  fi
                  
                  if [ "$POSTGRES_RUNNING" = "0" ]; then
                    echo "üöÄ Starting Docker services (PostgreSQL and Redis)..."
                    echo "   Using command: $DOCKER_COMPOSE_CMD"
                    echo "   Directory: $DOCKER_COMPOSE_DIR"
                    
                    # Start services using the detected docker command
                    echo "   Executing: $DOCKER_COMPOSE_CMD up -d postgres redis"
                    if $DOCKER_COMPOSE_CMD up -d postgres redis 2>&1; then
                      echo "‚úÖ Docker services started"
                    else
                      echo "‚ùå Failed to start Docker services"
                      echo "üí° Try running manually: cd $DOCKER_COMPOSE_DIR && $DOCKER_COMPOSE_CMD up -d postgres redis"
                      exit 1
                    fi
                    
                    # Wait for services to be ready
                    echo "‚è≥ Waiting for PostgreSQL to be ready..."
                    RETRY_COUNT=0
                    POSTGRES_READY="false"
                    while [ $RETRY_COUNT -lt 30 ]; do
                      if $DOCKER_CMD exec investment_crm_db pg_isready -U postgres &> /dev/null 2>&1; then
                        echo "‚úÖ PostgreSQL is ready"
                        POSTGRES_READY="true"
                        break
                      fi
                      RETRY_COUNT=$((RETRY_COUNT + 1))
                      [ $((RETRY_COUNT % 5)) -eq 0 ] && echo "  Still waiting... ($RETRY_COUNT/30)"
                      sleep 2
                    done
                    
                    if [ "$POSTGRES_READY" = "false" ]; then
                      echo "‚ö†Ô∏è  PostgreSQL took too long to start"
                      echo "üí° Check logs: $DOCKER_CMD logs investment_crm_db"
                    fi
                    
                    # Wait for Redis
                    echo "‚è≥ Waiting for Redis to be ready..."
                    RETRY_COUNT=0
                    REDIS_READY="false"
                    while [ $RETRY_COUNT -lt 30 ]; do
                      if $DOCKER_CMD exec investment_crm_redis redis-cli ping &> /dev/null 2>&1; then
                        echo "‚úÖ Redis is ready"
                        REDIS_READY="true"
                        break
                      fi
                      RETRY_COUNT=$((RETRY_COUNT + 1))
                      [ $((RETRY_COUNT % 5)) -eq 0 ] && echo "  Still waiting... ($RETRY_COUNT/30)"
                      sleep 2
                    done
                    
                    if [ "$REDIS_READY" = "false" ]; then
                      echo "‚ö†Ô∏è  Redis took too long to start"
                      echo "üí° Check logs: $DOCKER_CMD logs investment_crm_redis"
                    fi
                  else
                    echo "‚úÖ Docker services are already running"
                  fi
                else
                  echo "‚ö†Ô∏è  docker-compose.yml not found, skipping Docker service startup"
                  echo "üí° Make sure docker-compose.yml exists or start services manually"
                fi
              else
                echo "‚ö†Ô∏è  docker-compose command not available"
              fi
            else
              echo "‚ö†Ô∏è  Cannot proceed without Docker"
              echo "üí° Install Docker or ensure it's in PATH"
            fi
            
            # Test database connectivity
            echo "üóÑÔ∏è  Testing database connectivity..."
            # If DATABASE_URL points to localhost, try to connect via Docker container
            if echo "$DATABASE_URL" | grep -q "localhost\|127.0.0.1"; then
              echo "üîç DATABASE_URL points to localhost, checking Docker container..."
              # Use the DOCKER_CMD we detected earlier, or try to find it again
              CHECK_DOCKER_CMD="${DOCKER_CMD:-docker}"
              if [ -z "$DOCKER_CMD" ]; then
                if command -v docker &> /dev/null; then
                  CHECK_DOCKER_CMD="docker"
                elif sudo command -v docker &> /dev/null; then
                  CHECK_DOCKER_CMD="sudo docker"
                fi
              fi
              
              POSTGRES_RUNNING="0"
              if $CHECK_DOCKER_CMD ps --filter "name=investment_crm_db" --filter "status=running" --format "{{.Names}}" 2>/dev/null | grep -q "investment_crm_db"; then
                POSTGRES_RUNNING="1"
                echo "‚úÖ PostgreSQL container is running"
                # Try to test connection via docker exec
                if $CHECK_DOCKER_CMD exec investment_crm_db pg_isready -U postgres &> /dev/null 2>&1; then
                  echo "‚úÖ Database is ready (via Docker)"
                else
                  echo "‚ö†Ô∏è  Database container is running but not ready yet"
                fi
              else
                echo "‚ö†Ô∏è  PostgreSQL container is not running, but DATABASE_URL points to localhost"
                echo "üí° Make sure Docker services are started or update DATABASE_URL to point to the correct host"
              fi
            fi
            
            if command -v psql &> /dev/null; then
              DB_CONN=$(echo "$DATABASE_URL" | sed -E 's|postgresql://([^:]+):([^@]+)@([^:]+):([^/]+)/(.+)|host=\3 port=\4 user=\1 password=\2 dbname=\5|')
              if psql "$DB_CONN" -c 'SELECT 1' &> /dev/null; then
                echo "‚úÖ Database connection successful (via psql)"
              else
                echo "‚ö†Ô∏è  Could not verify database connection with psql, but continuing..."
              fi
            else
              echo "‚ö†Ô∏è  psql not available, skipping database connectivity test"
            fi
            
            # Generate Prisma client
            echo "üì¶ Generating Prisma client..."
            # Ensure we're in the release directory where node_modules exists
            cd "$RELEASE_DIR"
            echo "üìÇ Current directory: $(pwd)"
            echo "üìÇ Release directory: $RELEASE_DIR"
            
            # Use the local Prisma binary directly
            PRISMA_BIN=""
            if [ -f "node_modules/.bin/prisma" ]; then
              PRISMA_BIN="node_modules/.bin/prisma"
              echo "‚úÖ Found local Prisma binary"
            elif [ -f "$RELEASE_DIR/node_modules/.bin/prisma" ]; then
              PRISMA_BIN="$RELEASE_DIR/node_modules/.bin/prisma"
              echo "‚úÖ Found local Prisma binary (absolute path)"
            else
              echo "‚ö†Ô∏è  Prisma binary not found in node_modules/.bin/prisma"
              echo "   Current directory: $(pwd)"
              echo "   Release directory: $RELEASE_DIR"
              echo "   Checking if node_modules exists..."
              if [ -d "node_modules" ]; then
                echo "   ‚úÖ node_modules directory exists"
                echo "   Listing node_modules/.bin:"
                ls -la node_modules/.bin/ 2>/dev/null | head -10 || echo "   node_modules/.bin not found"
                echo "   Checking if prisma package exists..."
                if [ -d "node_modules/prisma" ]; then
                  echo "   ‚úÖ prisma package found, but binary missing"
                  echo "   This might be a symlink issue. Trying to run prisma directly..."
                  if [ -f "node_modules/prisma/build/index.js" ]; then
                    PRISMA_BIN="node node_modules/prisma/build/index.js"
                    echo "   ‚úÖ Using Prisma via node"
                  fi
                fi
              else
                echo "   ‚ùå node_modules directory not found"
              fi
              
              # If still no binary, use npm run script (which should work)
              if [ -z "$PRISMA_BIN" ]; then
                echo "   Using npm run db:generate as fallback..."
                if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
                  sudo $NPM_CMD run db:generate || {
                    echo "‚ùå Error: Failed to generate Prisma client"
                    exit 1
                  }
                else
                  $NPM_CMD run db:generate || {
                    echo "‚ùå Error: Failed to generate Prisma client"
                    exit 1
                  }
                fi
                PRISMA_BIN="skip" # Skip the direct binary call since we used npm run
              fi
            fi
            
            if [ "$PRISMA_BIN" != "skip" ] && [ -n "$PRISMA_BIN" ]; then
              if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
                sudo "$PRISMA_BIN" generate || {
                  echo "‚ùå Error: Failed to generate Prisma client"
                  exit 1
                }
              else
                "$PRISMA_BIN" generate || {
                  echo "‚ùå Error: Failed to generate Prisma client"
                  exit 1
                }
              fi
            fi
            
            # Run database migrations
            echo "üîÑ Running database migrations..."
            if [ "$PRISMA_BIN" != "skip" ] && [ -n "$PRISMA_BIN" ]; then
              if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
                sudo "$PRISMA_BIN" migrate deploy || {
                  echo "‚ùå Error: Database migration failed"
                  exit 1
                }
              else
                "$PRISMA_BIN" migrate deploy || {
                  echo "‚ùå Error: Database migration failed"
                  exit 1
                }
              fi
            else
              # Use npm exec with --yes to prevent package installation
              if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
                sudo $NPM_CMD exec --yes prisma migrate deploy || {
                  echo "‚ùå Error: Database migration failed"
                  exit 1
                }
              else
                $NPM_CMD exec --yes prisma migrate deploy || {
                  echo "‚ùå Error: Database migration failed"
                  exit 1
                }
              fi
            fi
            echo "‚úÖ Database migrations completed"
            
            # Create symlink to current release
            cd "$DEPLOY_PATH"
            rm -f current
            ln -s "releases/$TIMESTAMP" current
            
            # Restart application
            if command -v pm2 &> /dev/null; then
              pm2 restart investment-crm-backend || pm2 start current/dist/index.js --name investment-crm-backend
            elif command -v systemctl &> /dev/null; then
              sudo systemctl restart investment-crm-backend || echo "Service not configured"
            else
              # Fallback: kill existing process and start new one
              pkill -f 'node.*dist/index.js' || true
              cd current
              if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
                sudo nohup $NPM_CMD start > /dev/null 2>&1 &
              else
                nohup $NPM_CMD start > /dev/null 2>&1 &
              fi
            fi
            
            # Cleanup old releases (keep last 5)
            cd "$DEPLOY_PATH/releases"
            ls -t | tail -n +6 | xargs -r rm -rf
          else
            # GitHub-hosted runner: deploy via SSH
            echo "üöÄ Deploying via SSH..."
            
            # Create deployment directory on server
            ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
              mkdir -p $DEPLOY_PATH/releases
              mkdir -p $DEPLOY_PATH/shared
            "
            
            # Upload build artifact
            scp backend-deploy.tar.gz ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:$DEPLOY_PATH/releases/
            
            # Upload .env file if provided
            if [ -f backend-env.txt ]; then
              scp backend-env.txt ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:$DEPLOY_PATH/releases/backend-env.txt
            fi
            
            # Extract and deploy on server
            ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
              cd $DEPLOY_PATH/releases
              TIMESTAMP=\$(date +%Y%m%d%H%M%S)
              mkdir -p \$TIMESTAMP
              tar -xzf backend-deploy.tar.gz -C \$TIMESTAMP
              rm backend-deploy.tar.gz
              
              # Install production dependencies
              cd \$TIMESTAMP
              ${NPM_CMD:-npm} ci --production
              
              # Create .env file from secret or use shared .env
              if [ -f ../backend-env.txt ]; then
                cp ../backend-env.txt .env
                rm ../backend-env.txt
                echo '‚úÖ Created .env file from BACKEND_ENV_FILE secret'
              elif [ -f $DEPLOY_PATH/shared/.env ]; then
                cp $DEPLOY_PATH/shared/.env .env
                echo '‚úÖ Using shared .env file'
              else
                echo '‚ùå Error: No .env file found. Deployment cannot continue.'
                exit 1
              fi
              
              # Validate required environment variables
              echo 'üîç Validating environment variables...'
              source .env
              if [ -z \"\$DATABASE_URL\" ]; then
                echo '‚ùå Error: DATABASE_URL is not set in .env file'
                exit 1
              fi
              if [ -z \"\$JWT_SECRET\" ]; then
                echo '‚ùå Error: JWT_SECRET is not set in .env file'
                exit 1
              fi
              echo '‚úÖ Required environment variables are set'
              
              # Test database connectivity
              echo 'üóÑÔ∏è  Testing database connectivity...'
              if command -v psql &> /dev/null; then
                DB_CONN=\$(echo \$DATABASE_URL | sed -E 's|postgresql://([^:]+):([^@]+)@([^:]+):([^/]+)/(.+)|host=\3 port=\4 user=\1 password=\2 dbname=\5|')
                if psql \"\$DB_CONN\" -c 'SELECT 1' &> /dev/null; then
                  echo '‚úÖ Database connection successful'
                else
                  echo '‚ö†Ô∏è  Could not verify database connection with psql, but continuing...'
                fi
              else
                echo '‚ö†Ô∏è  psql not available, skipping database connectivity test'
              fi
              
              # Generate Prisma client
              echo 'üì¶ Generating Prisma client...'
              # Use the local Prisma binary directly
              if [ -f 'node_modules/.bin/prisma' ]; then
                node_modules/.bin/prisma generate || {
                  echo '‚ùå Error: Failed to generate Prisma client'
                  exit 1
                }
              elif [ -f './node_modules/.bin/prisma' ]; then
                ./node_modules/.bin/prisma generate || {
                  echo '‚ùå Error: Failed to generate Prisma client'
                  exit 1
                }
              elif command -v npx &> /dev/null; then
                npx prisma generate || {
                  echo '‚ùå Error: Failed to generate Prisma client'
                  exit 1
                }
              else
                ${NPM_CMD:-npm} run db:generate || {
                  echo '‚ùå Error: Failed to generate Prisma client'
                  exit 1
                }
              fi
              
              # Run database migrations
              echo 'üîÑ Running database migrations...'
              if [ -f 'node_modules/.bin/prisma' ]; then
                node_modules/.bin/prisma migrate deploy || {
                  echo '‚ùå Error: Database migration failed'
                  exit 1
                }
              elif [ -f './node_modules/.bin/prisma' ]; then
                ./node_modules/.bin/prisma migrate deploy || {
                  echo '‚ùå Error: Database migration failed'
                  exit 1
                }
              elif command -v npx &> /dev/null; then
                npx prisma migrate deploy || {
                  echo '‚ùå Error: Database migration failed'
                  exit 1
                }
              else
                ${NPM_CMD:-npm} run db:generate || {
                  echo '‚ùå Error: Database migration failed'
                  exit 1
                }
              fi
              echo '‚úÖ Database migrations completed'
              
              # Create symlink to current release
              cd $DEPLOY_PATH
              rm -f current
              ln -s releases/\$TIMESTAMP current
              
              # Restart application
              if command -v pm2 &> /dev/null; then
                pm2 restart investment-crm-backend || pm2 start current/dist/index.js --name investment-crm-backend
              elif command -v systemctl &> /dev/null; then
                sudo systemctl restart investment-crm-backend || echo 'Service not configured'
              else
                # Fallback: kill existing process and start new one
                pkill -f 'node.*dist/index.js' || true
                cd current
                nohup ${NPM_CMD:-npm} start > /dev/null 2>&1 &
              fi
              
              # Cleanup old releases (keep last 5)
              cd releases
              ls -t | tail -n +6 | xargs -r rm -rf
            "
          fi

      - name: Health check
        run: |
          sleep 10
          curl -f ${{ secrets.BACKEND_URL || 'http://localhost:3001' }}/health || exit 1


