name: Backend Deployment

on:
  push:
    branches:
      - main
      - master
    paths:
      - '.github/workflows/backend-deploy.yml'
  pull_request:
    branches:
      - main
      - master
    paths:
      - '.github/workflows/backend-deploy.yml'
  workflow_dispatch:

env:
  NODE_VERSION: '20'

jobs:
  test:
    name: Test Backend
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: investment_crm_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        id: setup-node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: package-lock.json
        continue-on-error: true

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npm run db:generate
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/investment_crm_test

      - name: Run database migrations
        run: npx prisma migrate deploy
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/investment_crm_test

      - name: Run linter
        run: npm run lint

      - name: Type check
        run: npm run type-check

      - name: Run tests
        run: npm test
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/investment_crm_test
          NODE_ENV: test
          JWT_SECRET: test-secret-key

  build:
    name: Build Backend
    runs-on: ubuntu-latest
    needs: test
    if: |
      always() &&
      (needs.test.result == 'success' || needs.test.result == 'skipped') &&
      ((github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')) ||
       (github.event_name == 'workflow_dispatch' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')))
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify package-lock.json exists
        run: |
          if [ ! -f package-lock.json ]; then
            echo "Warning: package-lock.json not found, cache will be skipped"
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npm run db:generate

      - name: Build application
        run: |
          echo "ðŸ”¨ Building application..."
          npm run build
          
          # Check if build was successful
          if [ $? -ne 0 ]; then
            echo "âŒ Build failed"
            exit 1
          fi
          
          echo "âœ… Build completed"

      - name: Verify build output
        run: |
          echo "ðŸ” Verifying build output..."
          if [ ! -d "dist" ]; then
            echo "âŒ Error: dist directory not found"
            exit 1
          fi
          
          # Check for critical files
          if [ ! -f "dist/index.js" ]; then
            echo "âŒ Error: dist/index.js not found"
            exit 1
          fi
          
          # Check if config directory exists
          if [ ! -d "dist/config" ]; then
            echo "âš ï¸  Warning: dist/config directory not found"
            echo "ðŸ“‹ Contents of dist directory:"
            ls -la dist/ || true
          else
            echo "âœ… dist/config directory found"
            if [ ! -f "dist/config/logger.js" ]; then
              echo "âš ï¸  Warning: dist/config/logger.js not found"
              echo "ðŸ“‹ Contents of dist/config:"
              ls -la dist/config/ || true
            else
              echo "âœ… dist/config/logger.js found"
            fi
          fi
          
          # Show dist structure
          echo "ðŸ“‹ Build output structure:"
          find dist -type f -name "*.js" | head -20 || true
          
          # Check if config directory has all files
          if [ -d "dist/config" ]; then
            echo "ðŸ“‹ Files in dist/config:"
            ls -la dist/config/ || true
            CONFIG_FILE_COUNT=$(find dist/config -name "*.js" | wc -l)
            echo "âœ… Found $CONFIG_FILE_COUNT .js files in dist/config"
          fi
          
          # Check compiled index.js for import statements
          if [ -f "dist/index.js" ]; then
            echo "ðŸ“‹ Checking imports in dist/index.js:"
            grep -E "from ['\"].*config/logger" dist/index.js | head -5 || echo "   (no logger import found or different format)"
          fi
          
          echo "âœ… Build verification complete"

      - name: Create deployment package
        run: |
          echo "ðŸ“¦ Creating deployment package..."
          mkdir -p deploy
          
          # Copy dist directory (preserve structure)
          if [ -d "dist" ]; then
          cp -r dist deploy/
            echo "âœ… Copied dist directory"
          else
            echo "âŒ Error: dist directory not found"
            exit 1
          fi
          
          # Copy prisma directory
          if [ -d "prisma" ]; then
          cp -r prisma deploy/
            echo "âœ… Copied prisma directory"
          fi
          
          # Copy package files
          cp package.json deploy/
          cp package-lock.json deploy/
          
          # Verify package contents
          echo "ðŸ“‹ Deployment package contents:"
          ls -la deploy/ || true
          if [ -d "deploy/dist" ]; then
            echo "ðŸ“‹ dist directory structure:"
            find deploy/dist -type f -name "*.js" | head -10 || true
          fi
          
          # Create tarball
          tar -czf backend-deploy.tar.gz -C deploy .
          echo "âœ… Created backend-deploy.tar.gz"
          
          # Verify tarball
          echo "ðŸ“‹ Verifying tarball contents:"
          tar -tzf backend-deploy.tar.gz | head -20 || true
          
          rm -rf deploy

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: backend-build
          path: backend-deploy.tar.gz
          retention-days: 1

  pre-deploy-check:
    name: Pre-Deployment Validation
    runs-on: ${{ vars.USE_SELF_HOSTED_RUNNER == 'true' && 'self-hosted' || 'ubuntu-latest' }}
    needs: build
    if: |
      (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')) ||
      (github.event_name == 'workflow_dispatch' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'))
    
    env:
      USE_SELF_HOSTED: ${{ vars.USE_SELF_HOSTED_RUNNER == 'true' }}
      WORKSPACE_PATH: $WORKSPACE_PATH
      DEPLOY_PATH: ${{ secrets.BACKEND_DEPLOY_PATH || '/var/www/investment-crm/backend' }}
    
    steps:
      - name: Setup SSH (for GitHub-hosted runners only)
        if: env.USE_SELF_HOSTED != 'true'
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts (for GitHub-hosted runners only)
        if: env.USE_SELF_HOSTED != 'true'
        run: |
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Setup environment for self-hosted runner
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          echo "âœ… Running on self-hosted runner - no SSH needed"
          [ -f /etc/profile ] && source /etc/profile
          [ -f ~/.bashrc ] && source ~/.bashrc
          [ -f ~/.bash_profile ] && source ~/.bash_profile
          [ -f ~/.profile ] && source ~/.profile
          export PATH="/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin:$PATH"
          export PATH="$HOME/.nvm/versions/node/*/bin:$PATH"
          export PATH="/opt/nodejs/bin:$PATH"

      - name: Validate Node.js (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          echo "ðŸ“¦ Checking Node.js installation..."
          echo "Current user: $(whoami)"
          echo "Current PATH: $PATH"
          
          NODE_CMD=""
          if [ -d /opt/nodejs/bin ]; then
            echo "Checking /opt/nodejs/bin directory..."
            ls -la /opt/nodejs/bin/ 2>/dev/null | head -10 || echo "Cannot list /opt/nodejs/bin"
            if [ -f /opt/nodejs/bin/node ]; then
              if [ -x /opt/nodejs/bin/node ]; then
                NODE_CMD="/opt/nodejs/bin/node"
                echo "âœ… Found executable node in /opt/nodejs/bin"
              else
                echo "âš ï¸  Found node in /opt/nodejs/bin but not executable"
                if sudo chmod +x /opt/nodejs/bin/node 2>/dev/null; then
                  NODE_CMD="/opt/nodejs/bin/node"
                  echo "âœ… Made node executable"
                fi
              fi
            fi
          fi
          
          if [ -z "$NODE_CMD" ]; then
            if command -v node &> /dev/null; then
              NODE_CMD="node"
              echo "âœ… Found node via command -v"
            elif [ -f /usr/local/bin/node ]; then
              NODE_CMD="/usr/local/bin/node"
              echo "âœ… Found node in /usr/local/bin"
            elif [ -f /usr/bin/node ]; then
              NODE_CMD="/usr/bin/node"
              echo "âœ… Found node in /usr/bin"
            fi
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            if [ -d /root/.nvm/versions/node ]; then
              NODE_CMD=$(find /root/.nvm/versions/node -name node -type f -executable 2>/dev/null | sort -V | tail -1)
            fi
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            if [ -d "$HOME/.nvm/versions/node" ]; then
              NODE_CMD=$(find "$HOME/.nvm/versions/node" -name node -type f -executable 2>/dev/null | sort -V | tail -1)
            fi
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            NODE_CMD=$(find /usr/local/bin /usr/bin /opt /root/.nvm /root/.local /root/bin -name node -type f -executable 2>/dev/null | head -1)
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            ROOT_NODE=$(sudo sh -c 'command -v node' 2>/dev/null || echo "")
            if [ -z "$ROOT_NODE" ]; then
              ROOT_NODE=$(sudo -n sh -c 'command -v node' 2>/dev/null || echo "")
            fi
            if [ -n "$ROOT_NODE" ] && [ -f "$ROOT_NODE" ]; then
              NODE_CMD="$ROOT_NODE"
              echo "Found node via root's PATH: $NODE_CMD"
            fi
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            if [ -f /root/.bashrc ]; then
              ROOT_NVM_DIR=$(grep -o 'NVM_DIR="[^"]*"' /root/.bashrc 2>/dev/null | cut -d'"' -f2 || echo "")
              if [ -n "$ROOT_NVM_DIR" ] && [ -d "$ROOT_NVM_DIR/versions/node" ]; then
                NODE_CMD=$(find "$ROOT_NVM_DIR/versions/node" -name node -type f -executable 2>/dev/null | sort -V | tail -1)
              fi
            fi
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            ROOT_NODE_PATH=$(sudo sh -c 'which node 2>&1' 2>/dev/null | grep -v "not found" | head -1 || echo "")
            if [ -n "$ROOT_NODE_PATH" ] && [ "$ROOT_NODE_PATH" != "" ]; then
              if sudo test -f "$ROOT_NODE_PATH" 2>/dev/null; then
                echo "âœ… Found Node.js at: $ROOT_NODE_PATH (requires sudo)"
                NODE_CMD="$ROOT_NODE_PATH"
                echo "USE_SUDO_FOR_NODE=1" >> $GITHUB_ENV
                echo "âœ… Will use sudo for all Node.js/npm commands"
              fi
            fi
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            ROOT_NODE_PATH=$(sudo sh -c 'which node 2>&1' 2>/dev/null | grep -v "not found" | head -1 || echo "")
            if [ -n "$ROOT_NODE_PATH" ] && sudo test -f "$ROOT_NODE_PATH" 2>/dev/null; then
              echo "Found Node.js at: $ROOT_NODE_PATH"
              if sudo ln -sf "$ROOT_NODE_PATH" /usr/local/bin/node 2>/dev/null; then
                sudo chmod +x /usr/local/bin/node 2>/dev/null
                if [ -f /usr/local/bin/node ] && [ -x /usr/local/bin/node ]; then
                  NODE_CMD="/usr/local/bin/node"
                  echo "âœ… Symlink created successfully"
                fi
              fi
            fi
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            echo "âŒ Node.js is not installed on the server or not accessible"
            exit 1
          fi
          
          if [ ! -x "$NODE_CMD" ]; then
            if sudo chmod +x "$NODE_CMD" 2>/dev/null; then
              echo "âœ… Made Node.js executable"
            else
              echo "âŒ Node.js found at $NODE_CMD but cannot be executed"
              exit 1
            fi
          fi
          
          if [ "${USE_SUDO_FOR_NODE:-}" = "1" ]; then
            NODE_VERSION=$(sudo $NODE_CMD --version 2>/dev/null || echo "unknown")
          else
            NODE_VERSION=$($NODE_CMD --version 2>/dev/null || sudo $NODE_CMD --version 2>/dev/null || echo "unknown")
          fi
          echo "âœ… Node.js found at: $NODE_CMD"
          echo "âœ… Node.js version: $NODE_VERSION"
          echo "NODE_CMD=$NODE_CMD" >> $GITHUB_ENV

      - name: Validate npm (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          echo "ðŸ“¦ Checking npm installation..."
          NPM_CMD=""
          if [ -f /opt/nodejs/bin/npm ] && [ -x /opt/nodejs/bin/npm ]; then
            NPM_CMD="/opt/nodejs/bin/npm"
          elif command -v npm &> /dev/null; then
            NPM_CMD="npm"
          elif [ -f /usr/local/bin/npm ]; then
            NPM_CMD="/usr/local/bin/npm"
          elif [ -f /usr/bin/npm ]; then
            NPM_CMD="/usr/bin/npm"
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            if [ -n "$NODE_CMD" ] && [ -d "$(dirname "$NODE_CMD")" ]; then
              NPM_CMD="$(dirname "$NODE_CMD")/npm"
              [ ! -f "$NPM_CMD" ] && NPM_CMD=""
            elif [ -d /root/.nvm/versions/node ]; then
              NPM_CMD=$(find /root/.nvm/versions/node -name npm -type f -executable 2>/dev/null | sort -V | tail -1)
            fi
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            if [ -d "$HOME/.nvm/versions/node" ]; then
              NPM_CMD=$(find "$HOME/.nvm/versions/node" -name npm -type f -executable 2>/dev/null | sort -V | tail -1)
            fi
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            NPM_CMD=$(find /usr/local/bin /usr/bin /opt /root/.nvm /root/.local /root/bin -name npm -type f -executable 2>/dev/null | head -1)
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            ROOT_NPM=$(sudo sh -c 'command -v npm' 2>/dev/null || echo "")
            [ -z "$ROOT_NPM" ] && ROOT_NPM=$(sudo -n sh -c 'command -v npm' 2>/dev/null || echo "")
            if [ -n "$ROOT_NPM" ] && [ -f "$ROOT_NPM" ]; then
              NPM_CMD="$ROOT_NPM"
            fi
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            if [ -f /root/.bashrc ]; then
              ROOT_NVM_DIR=$(grep -o 'NVM_DIR="[^"]*"' /root/.bashrc 2>/dev/null | cut -d'"' -f2 || echo "")
              if [ -n "$ROOT_NVM_DIR" ] && [ -d "$ROOT_NVM_DIR/versions/node" ]; then
                NPM_CMD=$(find "$ROOT_NVM_DIR/versions/node" -name npm -type f -executable 2>/dev/null | sort -V | tail -1)
              fi
            fi
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            ROOT_NPM_PATH=$(sudo sh -c 'which npm 2>&1' 2>/dev/null | grep -v "not found" | head -1 || echo "")
            if [ -n "$ROOT_NPM_PATH" ] && [ "$ROOT_NPM_PATH" != "" ]; then
              if sudo test -f "$ROOT_NPM_PATH" 2>/dev/null; then
                echo "âœ… Found npm at: $ROOT_NPM_PATH (requires sudo)"
                NPM_CMD="$ROOT_NPM_PATH"
                if [ "${USE_SUDO_FOR_NODE:-}" != "1" ]; then
                  echo "USE_SUDO_FOR_NODE=1" >> $GITHUB_ENV
                fi
              fi
            fi
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            ROOT_NPM_PATH=$(sudo sh -c 'which npm 2>&1' 2>/dev/null | grep -v "not found" | head -1 || echo "")
            if [ -n "$ROOT_NPM_PATH" ] && sudo test -f "$ROOT_NPM_PATH" 2>/dev/null; then
              if sudo ln -sf "$ROOT_NPM_PATH" /usr/local/bin/npm 2>/dev/null; then
                sudo chmod +x /usr/local/bin/npm 2>/dev/null
                if [ -f /usr/local/bin/npm ] && [ -x /usr/local/bin/npm ]; then
                  NPM_CMD="/usr/local/bin/npm"
                fi
              fi
            fi
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            echo "âŒ npm is not installed on the server or not accessible"
            exit 1
          fi
          
          if [ ! -x "$NPM_CMD" ]; then
            if sudo chmod +x "$NPM_CMD" 2>/dev/null; then
              echo "âœ… Made npm executable"
            else
              echo "âŒ npm found at $NPM_CMD but cannot be executed"
              exit 1
            fi
          fi
          
          if [ "${USE_SUDO_FOR_NODE:-}" = "1" ]; then
            NPM_VERSION=$(sudo $NPM_CMD --version 2>/dev/null || echo "unknown")
          else
            NPM_VERSION=$($NPM_CMD --version 2>/dev/null || sudo $NPM_CMD --version 2>/dev/null || echo "unknown")
          fi
          echo "âœ… npm found at: $NPM_CMD"
          echo "âœ… npm version: $NPM_VERSION"
          echo "NPM_CMD=$NPM_CMD" >> $GITHUB_ENV

      - name: Validate deployment directory and Docker (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          echo "ðŸ“ Checking deployment directory..."
          DEPLOY_PATH="$DEPLOY_PATH"
          if [ ! -d "$DEPLOY_PATH" ]; then
            mkdir -p "$DEPLOY_PATH/releases"
            mkdir -p "$DEPLOY_PATH/shared"
          fi
          if [ ! -w "$DEPLOY_PATH" ]; then
            echo "âŒ Deployment directory is not writable"
            exit 1
          fi
          echo "âœ… Deployment directory is ready"
          
          echo "ðŸ” Checking environment configuration..."
          if [ -n "${{ secrets.BACKEND_ENV_FILE }}" ]; then
            echo "âœ… BACKEND_ENV_FILE secret is set"
          elif [ -f "$DEPLOY_PATH/shared/.env" ]; then
            echo "âœ… Shared .env file found"
          else
            echo "âŒ No .env file found"
            exit 1
          fi
          
          echo "ðŸ³ Checking Docker and services..."
          if command -v docker &> /dev/null; then
            echo "âœ… Docker is installed"
            if command -v docker-compose &> /dev/null; then
              DOCKER_COMPOSE_CMD="docker-compose"
            elif docker compose version &> /dev/null; then
              DOCKER_COMPOSE_CMD="docker compose"
            else
              if command -v apt-get &> /dev/null; then
                sudo apt-get update && sudo apt-get install -y docker-compose-plugin 2>/dev/null || true
                DOCKER_COMPOSE_CMD="docker compose"
              fi
            fi
            
            if [ -n "$DOCKER_COMPOSE_CMD" ]; then
              # Check workspace root first (backend and frontend are separate repos)
              if [ -f "$WORKSPACE_PATH/docker-compose.yml" ]; then
                DOCKER_COMPOSE_FILE="$WORKSPACE_PATH/docker-compose.yml"
                DOCKER_COMPOSE_DIR="$WORKSPACE_PATH"
              elif [ -f "$DEPLOY_PATH/docker-compose.yml" ]; then
                DOCKER_COMPOSE_FILE="$DEPLOY_PATH/docker-compose.yml"
                DOCKER_COMPOSE_DIR="$DEPLOY_PATH"
              elif [ -f "$DEPLOY_PATH/current/docker-compose.yml" ]; then
                DOCKER_COMPOSE_FILE="$DEPLOY_PATH/current/docker-compose.yml"
                DOCKER_COMPOSE_DIR="$DEPLOY_PATH/current"
              fi
              
              if [ -n "$DOCKER_COMPOSE_FILE" ]; then
                cd "$DOCKER_COMPOSE_DIR"
                POSTGRES_RUNNING=$(docker ps --filter "name=investment_crm_db" --filter "status=running" --format "{{.Names}}" 2>/dev/null | grep -c "investment_crm_db" || echo "0")
                REDIS_RUNNING=$(docker ps --filter "name=investment_crm_redis" --filter "status=running" --format "{{.Names}}" 2>/dev/null | grep -c "investment_crm_redis" || echo "0")
                
                if [ "$POSTGRES_RUNNING" = "0" ] || [ "$REDIS_RUNNING" = "0" ]; then
                  echo "ðŸš€ Starting Docker services..."
                  if [ "${USE_SUDO_FOR_NODE:-}" = "1" ]; then
                    sudo $DOCKER_COMPOSE_CMD up -d postgres redis 2>&1 || $DOCKER_COMPOSE_CMD up -d postgres redis 2>&1 || exit 1
                  else
                    $DOCKER_COMPOSE_CMD up -d postgres redis 2>&1 || exit 1
                  fi
                  sleep 3
                  
                  RETRY_COUNT=0
                  while [ $RETRY_COUNT -lt 30 ]; do
                    if docker exec investment_crm_db pg_isready -U postgres &> /dev/null 2>&1; then
                      echo "âœ… PostgreSQL is ready"
                      break
                    fi
                    RETRY_COUNT=$((RETRY_COUNT + 1))
                    [ $((RETRY_COUNT % 5)) -eq 0 ] && echo "  Still waiting... ($RETRY_COUNT/30)"
                    sleep 2
                  done
                  
                  RETRY_COUNT=0
                  while [ $RETRY_COUNT -lt 30 ]; do
                    if docker exec investment_crm_redis redis-cli ping &> /dev/null 2>&1; then
                      echo "âœ… Redis is ready"
                      break
                    fi
                    RETRY_COUNT=$((RETRY_COUNT + 1))
                    [ $((RETRY_COUNT % 5)) -eq 0 ] && echo "  Still waiting... ($RETRY_COUNT/30)"
                    sleep 2
                  done
                else
                  echo "âœ… Docker services are already running"
                fi
              fi
            fi
          fi
          
          if command -v psql &> /dev/null; then
            echo "âœ… PostgreSQL client is installed"
          fi
          
          if command -v pm2 &> /dev/null; then
            echo "âœ… Process manager found: pm2"
          elif command -v systemctl &> /dev/null; then
            echo "âœ… Process manager found: systemd"
          fi

      - name: Validate server prerequisites (GitHub-hosted)
        if: env.USE_SELF_HOSTED != 'true'
        run: |
          echo "ðŸ“¡ Testing SSH connection..."
          ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "echo 'SSH connection successful'" || {
            echo "âŒ SSH connection failed"
            exit 1
          }
          
          NODE_VERSION=$(ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "node --version 2>/dev/null || echo 'not_installed'")
          if [ "$NODE_VERSION" = "not_installed" ]; then
            echo "âŒ Node.js is not installed on the server"
            exit 1
          fi
          echo "âœ… Node.js version: $NODE_VERSION"
          
          NPM_VERSION=$(ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "npm --version 2>/dev/null || echo 'not_installed'")
          if [ "$NPM_VERSION" = "not_installed" ]; then
            echo "âŒ npm is not installed on the server"
            exit 1
          fi
          echo "âœ… npm version: $NPM_VERSION"
          
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
            if [ ! -d '${{ secrets.BACKEND_DEPLOY_PATH }}' ]; then
              mkdir -p '${{ secrets.BACKEND_DEPLOY_PATH }}/releases'
              mkdir -p '${{ secrets.BACKEND_DEPLOY_PATH }}/shared'
            fi
            if [ ! -w '${{ secrets.BACKEND_DEPLOY_PATH }}' ]; then
              echo 'âŒ Deployment directory is not writable'
              exit 1
            fi
            echo 'âœ… Deployment directory is ready'
          " || exit 1
          
          if [ -n "${{ secrets.BACKEND_ENV_FILE }}" ]; then
            echo "âœ… BACKEND_ENV_FILE secret is set"
          else
            ENV_EXISTS=$(ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
              if [ -f '${{ secrets.BACKEND_DEPLOY_PATH }}/shared/.env' ]; then
                echo 'exists'
              else
                echo 'missing'
              fi
            ")
            if [ "$ENV_EXISTS" = "missing" ]; then
              echo "âŒ No .env file found"
              exit 1
            fi
            echo "âœ… Shared .env file found"
          fi
          
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
            if command -v psql &> /dev/null; then
              echo 'âœ… PostgreSQL client is installed'
            fi
          " || true
          
          PM_MANAGER=$(ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
            if command -v pm2 &> /dev/null; then
              echo 'pm2'
            elif command -v systemctl &> /dev/null; then
              echo 'systemd'
            else
              echo 'none'
            fi
          ")
          if [ "$PM_MANAGER" != "none" ]; then
            echo "âœ… Process manager found: $PM_MANAGER"
          fi
          
          echo "âœ… All prerequisites validated successfully!"

  deploy:
    name: Deploy Backend to Server
    runs-on: ${{ vars.USE_SELF_HOSTED_RUNNER == 'true' && 'self-hosted' || 'ubuntu-latest' }}
    needs: [build, pre-deploy-check]
    if: |
      (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')) ||
      (github.event_name == 'workflow_dispatch' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'))
    environment:
      name: production
    
    env:
      USE_SELF_HOSTED: ${{ vars.USE_SELF_HOSTED_RUNNER == 'true' }}
      WORKSPACE_PATH: ${{ github.workspace }}
      DEPLOY_PATH: ${{ secrets.BACKEND_DEPLOY_PATH || '/var/www/investment-crm/backend' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: backend-build
          path: .

      - name: Setup SSH (for GitHub-hosted runners only)
        if: env.USE_SELF_HOSTED != 'true'
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts (for GitHub-hosted runners only)
        if: env.USE_SELF_HOSTED != 'true'
        run: |
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Create .env file from secret
        run: |
          if [ -n "${{ secrets.BACKEND_ENV_FILE }}" ]; then
            echo "${{ secrets.BACKEND_ENV_FILE }}" > backend-env.txt
          fi

      - name: Setup PATH for self-hosted runner
        if: vars.USE_SELF_HOSTED_RUNNER == 'true'
        run: |
          # Source common profile files to ensure PATH is set correctly
          [ -f /etc/profile ] && source /etc/profile
          [ -f ~/.bashrc ] && source ~/.bashrc
          [ -f ~/.bash_profile ] && source ~/.bash_profile
          [ -f ~/.profile ] && source ~/.profile
          
          # Add common Node.js paths to PATH
          export PATH="/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin:$PATH"
          export PATH="$HOME/.nvm/versions/node/*/bin:$PATH"
          export PATH="/opt/nodejs/bin:$PATH"
          
          # Find Node.js and npm if not in PATH (including root's installation)
          if ! command -v node &> /dev/null; then
            NODE_CMD=$(find /usr/local /usr /opt /root -name node -type f -executable 2>/dev/null | head -1)
            if [ -z "$NODE_CMD" ]; then
              # Try using root's PATH
              ROOT_NODE=$(sudo -n sh -c 'command -v node' 2>/dev/null || echo "")
              if [ -n "$ROOT_NODE" ] && [ -f "$ROOT_NODE" ]; then
                NODE_CMD="$ROOT_NODE"
              fi
            fi
            if [ -n "$NODE_CMD" ]; then
              echo "NODE_CMD=$NODE_CMD" >> $GITHUB_ENV
              echo "PATH=$(dirname $NODE_CMD):$PATH" >> $GITHUB_ENV
            fi
          fi
          
          if ! command -v npm &> /dev/null; then
            NPM_CMD=$(find /usr/local /usr /opt /root -name npm -type f -executable 2>/dev/null | head -1)
            if [ -z "$NPM_CMD" ]; then
              # Try using root's PATH
              ROOT_NPM=$(sudo -n sh -c 'command -v npm' 2>/dev/null || echo "")
              if [ -n "$ROOT_NPM" ] && [ -f "$ROOT_NPM" ]; then
                NPM_CMD="$ROOT_NPM"
              fi
            fi
            if [ -n "$NPM_CMD" ]; then
              echo "NPM_CMD=$NPM_CMD" >> $GITHUB_ENV
              echo "PATH=$(dirname $NPM_CMD):$PATH" >> $GITHUB_ENV
            fi
          fi
          
          # Verify Node.js and npm are accessible
          echo "Node.js: $(command -v node || echo 'not found')"
          echo "npm: $(command -v npm || echo 'not found')"
          if [ -n "$NODE_CMD" ]; then
            $NODE_CMD --version || echo "Node.js version check failed"
          fi
          if [ -n "$NPM_CMD" ]; then
            $NPM_CMD --version || echo "npm version check failed"
          fi

      - name: Setup deployment environment (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          # Set deployment path (already set in env)
          DEPLOY_PATH="${DEPLOY_PATH:-/var/www/investment-crm/backend}"
          
          # Source profile to ensure PATH is correct
          [ -f /etc/profile ] && source /etc/profile
          [ -f ~/.bashrc ] && source ~/.bashrc
          [ -f ~/.profile ] && source ~/.profile
          
          # Use NPM_CMD from environment or find it (including root's installation)
          if [ -z "$NPM_CMD" ]; then
            if command -v npm &> /dev/null; then
              NPM_CMD="npm"
            else
              NPM_CMD=$(find /usr/local /usr /opt /root -name npm -type f -executable 2>/dev/null | head -1)
              if [ -z "$NPM_CMD" ]; then
                # Try using root's PATH
                ROOT_NPM=$(sudo -n sh -c 'command -v npm' 2>/dev/null || echo "")
                if [ -n "$ROOT_NPM" ] && [ -f "$ROOT_NPM" ]; then
                  NPM_CMD="$ROOT_NPM"
                fi
              fi
            fi
          fi
          
          if [ -z "$NPM_CMD" ]; then
            echo "âŒ Error: npm not found"
            echo "ðŸ’¡ Tip: Run this on your server as root to fix:"
            echo "   sudo ln -s \$(sudo which npm) /usr/local/bin/npm"
            echo "   sudo ln -s \$(sudo which node) /usr/local/bin/node"
            exit 1
          fi
          
          echo "Using npm at: $NPM_CMD"
          echo "NPM_CMD=$NPM_CMD" >> $GITHUB_ENV
          
          # Create deployment directory
          mkdir -p "$DEPLOY_PATH/releases"
          mkdir -p "$DEPLOY_PATH/shared"
          
          # Move build artifact
          mv backend-deploy.tar.gz "$DEPLOY_PATH/releases/"
          
          # Copy docker-compose.yml to deployment directory for easy access
          # Check workspace root first (backend and frontend are separate repos)
          if [ -f "$WORKSPACE_PATH/docker-compose.yml" ]; then
            echo "ðŸ“‹ Copying docker-compose.yml to deployment directory..."
            mkdir -p "$DEPLOY_PATH"
            cp "$WORKSPACE_PATH/docker-compose.yml" "$DEPLOY_PATH/docker-compose.yml" || echo "âš ï¸  Failed to copy docker-compose.yml (non-critical)"
          fi
          
          # Extract and deploy
          cd "$DEPLOY_PATH/releases"
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          mkdir -p "$TIMESTAMP"
          
          echo "ðŸ“¦ Extracting deployment package..."
          tar -xzf backend-deploy.tar.gz -C "$TIMESTAMP"
          rm backend-deploy.tar.gz
          
          # Verify extracted files
          echo "ðŸ” Verifying extracted files..."
          if [ ! -f "$TIMESTAMP/dist/index.js" ]; then
            echo "âŒ Error: dist/index.js not found after extraction"
            echo "ðŸ“‹ Contents of $TIMESTAMP:"
            ls -la "$TIMESTAMP/" || true
            exit 1
          fi
          
          if [ ! -d "$TIMESTAMP/dist/config" ]; then
            echo "âŒ Error: dist/config directory not found after extraction"
            echo "ðŸ“‹ Contents of $TIMESTAMP/dist:"
            ls -la "$TIMESTAMP/dist/" || true
            exit 1
          fi
          
          if [ ! -f "$TIMESTAMP/dist/config/logger.js" ]; then
            echo "âŒ Error: dist/config/logger.js not found after extraction"
            echo "ðŸ“‹ Contents of $TIMESTAMP/dist/config:"
            ls -la "$TIMESTAMP/dist/config/" || true
            exit 1
          fi
          
          echo "âœ… All required files extracted successfully"
          echo "ðŸ“‹ Sample of extracted structure:"
          find "$TIMESTAMP/dist" -type f -name "*.js" | head -10 || true
          
          echo "TIMESTAMP=$TIMESTAMP" >> $GITHUB_ENV
          echo "RELEASE_DIR=$DEPLOY_PATH/releases/$TIMESTAMP" >> $GITHUB_ENV

      - name: Install dependencies (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          cd "$RELEASE_DIR"
          echo "ðŸ“‚ Release directory: $RELEASE_DIR"
          
          if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
            sudo $NPM_CMD ci --production
          else
            $NPM_CMD ci --production
          fi
          
          # Verify Prisma is installed
          if [ ! -f "node_modules/.bin/prisma" ]; then
            echo "âš ï¸  Prisma binary not found after npm ci"
            echo "   Checking if prisma package is installed..."
            if [ -d "node_modules/prisma" ]; then
              echo "   âœ… prisma package found in node_modules"
              echo "   Listing node_modules/.bin:"
              ls -la node_modules/.bin/ 2>/dev/null | head -10 || echo "   node_modules/.bin not found"
            else
              echo "   âŒ prisma package not found in node_modules"
              echo "   This might be because prisma is in devDependencies"
              echo "   Installing prisma as production dependency..."
              if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
                sudo $NPM_CMD install prisma@^5.20.0 --save --no-save || true
              else
                $NPM_CMD install prisma@^5.20.0 --save --no-save || true
              fi
            fi
          fi

      - name: Setup environment variables (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          cd "$RELEASE_DIR"
          DEPLOY_PATH="${DEPLOY_PATH:-/var/www/investment-crm/backend}"
          
          # Create .env file from secret or use shared .env
          if [ -f "$WORKSPACE_PATH/backend-env.txt" ]; then
            cp "$WORKSPACE_PATH/backend-env.txt" .env
            rm "$WORKSPACE_PATH/backend-env.txt"
            echo "âœ… Created .env file from BACKEND_ENV_FILE secret"
          elif [ -f "$DEPLOY_PATH/shared/.env" ]; then
            cp "$DEPLOY_PATH/shared/.env" .env
            echo "âœ… Using shared .env file"
          else
            echo "âŒ Error: No .env file found. Deployment cannot continue."
            exit 1
          fi
          
          # Validate required environment variables
          echo "ðŸ” Validating environment variables..."
          set -a
          source .env
          set +a
          if [ -z "$DATABASE_URL" ]; then
            echo "âŒ Error: DATABASE_URL is not set in .env file"
            exit 1
          fi
          if [ -z "$JWT_SECRET" ]; then
            echo "âŒ Error: JWT_SECRET is not set in .env file"
            exit 1
          fi
          echo "âœ… Required environment variables are set"

      - name: Start Docker services (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          DEPLOY_PATH="${DEPLOY_PATH:-/var/www/investment-crm/backend}"
          
          # Check for Docker (try multiple methods)
          DOCKER_CMD=""
          if command -v docker &> /dev/null; then
            DOCKER_CMD="docker"
            echo "âœ… Docker is installed (found via command -v)"
          elif [ -f /usr/bin/docker ]; then
            DOCKER_CMD="/usr/bin/docker"
            echo "âœ… Docker is installed (found at /usr/bin/docker)"
          elif [ -f /usr/local/bin/docker ]; then
            DOCKER_CMD="/usr/local/bin/docker"
            echo "âœ… Docker is installed (found at /usr/local/bin/docker)"
          elif sudo command -v docker &> /dev/null; then
            DOCKER_CMD="sudo docker"
            echo "âœ… Docker is installed (found via sudo command -v)"
          else
            echo "âš ï¸  Docker is not found in PATH"
            DOCKER_CMD=$(find /usr /opt -name docker -type f -executable 2>/dev/null | head -1)
            if [ -n "$DOCKER_CMD" ]; then
              echo "âœ… Docker found at: $DOCKER_CMD"
            else
              echo "âŒ Docker is not installed or not accessible"
              exit 1
            fi
          fi
          
          if [ -n "$DOCKER_CMD" ]; then
            # Check if docker-compose is available
            DOCKER_COMPOSE_CMD=""
            if command -v docker-compose &> /dev/null; then
              DOCKER_COMPOSE_CMD="docker-compose"
            elif $DOCKER_CMD compose version &> /dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="$DOCKER_CMD compose"
            fi
            
            if [ -n "$DOCKER_COMPOSE_CMD" ]; then
              # Find docker-compose.yml
              DOCKER_COMPOSE_DIR=""
              if [ -f "$WORKSPACE_PATH/docker-compose.yml" ]; then
                DOCKER_COMPOSE_DIR="$WORKSPACE_PATH"
              elif [ -f "$DEPLOY_PATH/docker-compose.yml" ]; then
                DOCKER_COMPOSE_DIR="$DEPLOY_PATH"
              elif [ -f "$DEPLOY_PATH/current/docker-compose.yml" ]; then
                DOCKER_COMPOSE_DIR="$DEPLOY_PATH/current"
              fi
              
              if [ -n "$DOCKER_COMPOSE_DIR" ]; then
                cd "$DOCKER_COMPOSE_DIR"
                if ! $DOCKER_CMD ps --filter "name=investment_crm_db" --filter "status=running" --format "{{.Names}}" 2>/dev/null | grep -q "investment_crm_db"; then
                  echo "ðŸš€ Starting Docker services..."
                  $DOCKER_COMPOSE_CMD up -d postgres redis
                  
                  # Wait for PostgreSQL
                  RETRY_COUNT=0
                  while [ $RETRY_COUNT -lt 30 ]; do
                    if $DOCKER_CMD exec investment_crm_db pg_isready -U postgres &> /dev/null 2>&1; then
                      echo "âœ… PostgreSQL is ready"
                      break
                    fi
                    RETRY_COUNT=$((RETRY_COUNT + 1))
                    sleep 2
                  done
                  
                  # Wait for Redis
                  RETRY_COUNT=0
                  while [ $RETRY_COUNT -lt 30 ]; do
                    if $DOCKER_CMD exec investment_crm_redis redis-cli ping &> /dev/null 2>&1; then
                      echo "âœ… Redis is ready"
                      break
                    fi
                    RETRY_COUNT=$((RETRY_COUNT + 1))
                    sleep 2
                  done
                else
                  echo "âœ… Docker services are already running"
                fi
              fi
            fi
          fi

      - name: Run database migrations (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          cd "$RELEASE_DIR"
          
          # Generate Prisma client
          echo "ðŸ“¦ Generating Prisma client..."
          PRISMA_BIN=""
          if [ -f "node_modules/.bin/prisma" ]; then
            PRISMA_BIN="node_modules/.bin/prisma"
          elif [ -f "$RELEASE_DIR/node_modules/.bin/prisma" ]; then
            PRISMA_BIN="$RELEASE_DIR/node_modules/.bin/prisma"
          elif [ -d "node_modules/prisma" ] && [ -f "node_modules/prisma/build/index.js" ]; then
            PRISMA_BIN="node node_modules/prisma/build/index.js"
          fi
          
          if [ -n "$PRISMA_BIN" ]; then
            if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
              sudo "$PRISMA_BIN" generate
              sudo "$PRISMA_BIN" migrate deploy
            else
              "$PRISMA_BIN" generate
              "$PRISMA_BIN" migrate deploy
            fi
          else
            if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
              sudo $NPM_CMD run db:generate
              sudo $NPM_CMD exec --yes prisma migrate deploy
            else
              $NPM_CMD run db:generate
              $NPM_CMD exec --yes prisma migrate deploy
            fi
          fi
          echo "âœ… Database migrations completed"

      - name: Install PM2 if needed (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          echo "ðŸ” Checking for PM2..."
          
          # Source profile to ensure PATH includes npm global bin
          [ -f /etc/profile ] && source /etc/profile
          [ -f ~/.bashrc ] && source ~/.bashrc
          [ -f ~/.profile ] && source ~/.profile
          
          # Add npm global bin to PATH if not already there
          NPM_GLOBAL_BIN=""
          if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
            NPM_GLOBAL_BIN=$(sudo -n $NPM_CMD config get prefix 2>/dev/null)/bin || \
            NPM_GLOBAL_BIN=$(sudo $NPM_CMD config get prefix 2>/dev/null)/bin || \
            NPM_GLOBAL_BIN="/usr/local/bin"
          else
            NPM_GLOBAL_BIN=$($NPM_CMD config get prefix 2>/dev/null)/bin || \
            NPM_GLOBAL_BIN="$HOME/.npm-global/bin" || \
            NPM_GLOBAL_BIN="/usr/local/bin"
          fi
          
          if [ -n "$NPM_GLOBAL_BIN" ] && [[ ":$PATH:" != *":$NPM_GLOBAL_BIN:"* ]]; then
            export PATH="$NPM_GLOBAL_BIN:$PATH"
            echo "ðŸ“‚ Added npm global bin to PATH: $NPM_GLOBAL_BIN"
          fi
          
          # Check if pm2 is installed
          if command -v pm2 &> /dev/null; then
            PM2_VERSION=$(pm2 --version 2>/dev/null || echo "unknown")
            echo "âœ… PM2 is already installed (version: $PM2_VERSION)"
            echo "PM2_AVAILABLE=1" >> $GITHUB_ENV
          else
            echo "ðŸ“¦ PM2 not found, installing..."
            
            # Try to install pm2 globally
            if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
              # Check if passwordless sudo is available
              if sudo -n true 2>/dev/null; then
                echo "Installing PM2 with sudo..."
                sudo $NPM_CMD install -g pm2
              else
                echo "âš ï¸  Passwordless sudo not available, trying without sudo..."
                $NPM_CMD install -g pm2 || {
                  echo "âŒ Failed to install PM2 without sudo"
                  echo "ðŸ’¡ To install PM2 manually, run:"
                  echo "   sudo $NPM_CMD install -g pm2"
                  echo "PM2_AVAILABLE=0" >> $GITHUB_ENV
                  exit 0  # Don't fail deployment if PM2 install fails
                }
              fi
            else
              $NPM_CMD install -g pm2 || {
                echo "âŒ Failed to install PM2"
                echo "ðŸ’¡ To install PM2 manually, run: $NPM_CMD install -g pm2"
                echo "PM2_AVAILABLE=0" >> $GITHUB_ENV
                exit 0  # Don't fail deployment if PM2 install fails
              }
            fi
            
            # Update PATH again after installation
            if [ -n "$NPM_GLOBAL_BIN" ] && [[ ":$PATH:" != *":$NPM_GLOBAL_BIN:"* ]]; then
              export PATH="$NPM_GLOBAL_BIN:$PATH"
            fi
            
            # Verify installation
            if command -v pm2 &> /dev/null; then
              PM2_VERSION=$(pm2 --version 2>/dev/null || echo "unknown")
              echo "âœ… PM2 installed successfully (version: $PM2_VERSION)"
              echo "PM2_AVAILABLE=1" >> $GITHUB_ENV
            else
              # Try to find pm2 in common locations
              PM2_PATH=""
              for path in "$NPM_GLOBAL_BIN/pm2" "/usr/local/bin/pm2" "/usr/bin/pm2" "$HOME/.npm-global/bin/pm2"; do
                if [ -f "$path" ] && [ -x "$path" ]; then
                  PM2_PATH="$path"
                  echo "âœ… Found PM2 at: $PM2_PATH"
                  echo "PM2_AVAILABLE=1" >> $GITHUB_ENV
                  echo "PM2_PATH=$PM2_PATH" >> $GITHUB_ENV
                  break
                fi
              done
              
              if [ -z "$PM2_PATH" ]; then
                echo "âš ï¸  PM2 installation completed but command not found in PATH"
                echo "ðŸ’¡ You may need to restart the shell or add npm global bin to PATH"
                echo "PM2_AVAILABLE=0" >> $GITHUB_ENV
              fi
            fi
          fi

      - name: Finalize deployment (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          set +e  # Don't exit on error - we'll handle errors manually
          DEPLOY_PATH="${DEPLOY_PATH:-/var/www/investment-crm/backend}"
          
          # Create symlink to current release
          cd "$DEPLOY_PATH"
          rm -f current
          ln -s "releases/$TIMESTAMP" current
          
          # Restart application
          # Source profile to ensure PATH includes pm2
          [ -f /etc/profile ] && source /etc/profile
          [ -f ~/.bashrc ] && source ~/.bashrc
          [ -f ~/.profile ] && source ~/.profile
          
          # Initialize PM2_RUNNING
          PM2_RUNNING="0"
          
          # Use PM2_PATH if set, otherwise try command -v
          PM2_CMD=""
          echo "ðŸ” Checking PM2 availability..."
          echo "   PM2_AVAILABLE: ${PM2_AVAILABLE:-0}"
          echo "   PM2_PATH: ${PM2_PATH:-not set}"
          
          # First, try to use PM2_PATH from environment (set in Install PM2 step)
          if [ -n "${PM2_PATH:-}" ] && [ -f "${PM2_PATH}" ]; then
            PM2_CMD="${PM2_PATH}"
            echo "âœ… Using PM2 from PM2_PATH: $PM2_CMD"
          # Try command -v
          elif command -v pm2 &> /dev/null; then
            PM2_CMD="pm2"
            echo "âœ… Found PM2 in PATH: $PM2_CMD"
            $PM2_CMD --version || echo "âš ï¸  PM2 version check failed"
          else
            echo "âš ï¸  PM2 command not found in PATH, searching common locations..."
            # Try to find PM2 in common locations (including npm global bin)
            NPM_GLOBAL_BIN=""
            if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
              NPM_GLOBAL_BIN=$(sudo -n $NPM_CMD config get prefix 2>/dev/null)/bin || \
              NPM_GLOBAL_BIN=$(sudo $NPM_CMD config get prefix 2>/dev/null)/bin || \
              NPM_GLOBAL_BIN="/usr/local/bin"
            else
              NPM_GLOBAL_BIN=$($NPM_CMD config get prefix 2>/dev/null)/bin || \
              NPM_GLOBAL_BIN="$HOME/.npm-global/bin" || \
              NPM_GLOBAL_BIN="/usr/local/bin"
            fi
            
            for path in "$NPM_GLOBAL_BIN/pm2" "/opt/nodejs/bin/pm2" "/usr/local/bin/pm2" "/usr/bin/pm2" "$HOME/.npm-global/bin/pm2"; do
              if [ -f "$path" ] && [ -x "$path" ]; then
                PM2_CMD="$path"
                echo "âœ… Found PM2 at: $PM2_CMD"
                # Save for future use
                echo "PM2_PATH=$PM2_CMD" >> $GITHUB_ENV
                break
              fi
            done
          fi
          
          # If still not found, try to find it using find command
          if [ -z "$PM2_CMD" ]; then
            echo "   Searching for PM2 binary..."
            FOUND_PM2=$(find /usr /opt /home -name pm2 -type f -executable 2>/dev/null | head -1)
            if [ -n "$FOUND_PM2" ]; then
              PM2_CMD="$FOUND_PM2"
              echo "âœ… Found PM2 using find: $PM2_CMD"
              echo "PM2_PATH=$PM2_CMD" >> $GITHUB_ENV
            fi
          fi
          
          if [ "${PM2_AVAILABLE:-0}" = "1" ] && [ -n "$PM2_CMD" ]; then
            echo "ðŸ”„ Attempting to use PM2 process manager..."
            echo "   PM2 command: $PM2_CMD"
            
            # Verify PM2 binary exists and is executable
            if [ ! -f "$PM2_CMD" ]; then
              echo "âŒ PM2 binary not found at: $PM2_CMD"
              PM2_CMD=""
            elif [ ! -x "$PM2_CMD" ]; then
              echo "âš ï¸  PM2 binary is not executable, trying to fix permissions..."
              if chmod +x "$PM2_CMD" 2>/dev/null; then
                echo "âœ… Fixed PM2 permissions"
              elif sudo chmod +x "$PM2_CMD" 2>/dev/null; then
                echo "âœ… Fixed PM2 permissions with sudo"
              else
                echo "âŒ Could not make PM2 executable"
                PM2_CMD=""
              fi
            fi
            
            if [ -n "$PM2_CMD" ]; then
              # Fix PM2 permission issues first
              echo "   Checking PM2 daemon status..."
              PM2_HOME="${PM2_HOME:-$HOME/.pm2}"
              
              # Fix socket permissions BEFORE checking daemon status
              if [ -d "$PM2_HOME" ]; then
                echo "   Fixing PM2 directory permissions..."
                # Fix ownership of PM2 directory
                if [ "$USE_SUDO_FOR_NODE" = "1" ] && sudo -n true 2>/dev/null; then
                  sudo chown -R "$USER:$USER" "$PM2_HOME" 2>/dev/null || true
                  sudo chmod -R 755 "$PM2_HOME" 2>/dev/null || true
                else
                  chown -R "$USER:$USER" "$PM2_HOME" 2>/dev/null || true
                  chmod -R 755 "$PM2_HOME" 2>/dev/null || true
                fi
                
                # Fix socket permissions if they exist
                if [ -S "$PM2_HOME/rpc.sock" ] || [ -S "$PM2_HOME/pub.sock" ]; then
                  if [ "$USE_SUDO_FOR_NODE" = "1" ] && sudo -n true 2>/dev/null; then
                    sudo chown "$USER:$USER" "$PM2_HOME/rpc.sock" "$PM2_HOME/pub.sock" 2>/dev/null || true
                    sudo chmod 666 "$PM2_HOME/rpc.sock" "$PM2_HOME/pub.sock" 2>/dev/null || true
                  else
                    chown "$USER:$USER" "$PM2_HOME/rpc.sock" "$PM2_HOME/pub.sock" 2>/dev/null || true
                    chmod 666 "$PM2_HOME/rpc.sock" "$PM2_HOME/pub.sock" 2>/dev/null || true
                  fi
                fi
              fi
              
              # Only kill PM2 daemon if it's truly hung (not responding to ping)
              echo "   Checking if PM2 daemon is responsive..."
              if ! $PM2_CMD ping 2>/dev/null; then
                echo "   âš ï¸  PM2 daemon not responding, checking for stale daemon..."
                # Check if there are multiple PM2 daemons running
                PM2_PIDS=$(pgrep -f "pm2.*daemon" 2>/dev/null | wc -l)
                if [ "$PM2_PIDS" -gt 1 ]; then
                  echo "   âš ï¸  Multiple PM2 daemons detected ($PM2_PIDS), cleaning up..."
                  # Kill all PM2 daemons
                  pkill -f "pm2.*daemon" 2>/dev/null || true
                  sleep 2
                  # Remove stale sockets
                  rm -f "$PM2_HOME/rpc.sock" "$PM2_HOME/pub.sock" 2>/dev/null || true
                elif [ "$PM2_PIDS" -eq 1 ]; then
                  echo "   âš ï¸  PM2 daemon exists but not responding, killing stale daemon..."
                  $PM2_CMD kill 2>/dev/null || pkill -f "pm2.*daemon" 2>/dev/null || true
                  sleep 2
                  # Remove stale sockets
                  rm -f "$PM2_HOME/rpc.sock" "$PM2_HOME/pub.sock" 2>/dev/null || true
                else
                  echo "   â„¹ï¸  No PM2 daemon running, will start fresh"
                fi
              else
                echo "   âœ… PM2 daemon is responsive"
              fi
              
              # Check PM2 version (this will also verify PM2 works)
              echo "   Checking PM2 version..."
              PM2_VERSION_OUTPUT=$($PM2_CMD --version 2>&1)
              PM2_VERSION_EXIT=$?
              
              if [ $PM2_VERSION_EXIT -ne 0 ]; then
                echo "âš ï¸  PM2 version check failed: $PM2_VERSION_OUTPUT"
                # If it's a permission error, try to fix it
                if echo "$PM2_VERSION_OUTPUT" | grep -q "Permission denied"; then
                  echo "   Attempting to fix PM2 permissions..."
                  # Don't kill daemon here - just fix permissions
                  if [ "$USE_SUDO_FOR_NODE" = "1" ] && sudo -n true 2>/dev/null; then
                    sudo chown -R "$USER:$USER" "$PM2_HOME" 2>/dev/null || true
                    sudo chmod -R 755 "$PM2_HOME" 2>/dev/null || true
                  fi
                  sleep 1
                  # Try version check again
                  PM2_VERSION_OUTPUT=$($PM2_CMD --version 2>&1)
                  PM2_VERSION_EXIT=$?
                  if [ $PM2_VERSION_EXIT -eq 0 ]; then
                    echo "âœ… PM2 is working after permission fix (version: $PM2_VERSION_OUTPUT)"
                  else
                    echo "âš ï¸  PM2 still not working, will skip PM2 and use manual start"
                    PM2_CMD=""
                  fi
                else
                  echo "ðŸ’¡ This might be normal if PM2 daemon needs initialization"
                  echo "   Trying to use PM2 anyway (daemon will start on first command)..."
                fi
              else
                echo "âœ… PM2 is working (version: $PM2_VERSION_OUTPUT)"
              fi
              
              # Try to use PM2 - the daemon will start automatically on first command
              if [ -n "$PM2_CMD" ]; then
                echo "   Attempting to use PM2 (daemon will auto-start if needed)..."
                
                # Try to restart existing PM2 process
                echo "   Trying to restart existing PM2 process..."
                RESTART_OUTPUT=$($PM2_CMD restart investment-crm-backend 2>&1)
                RESTART_EXIT=$?
                
                if [ $RESTART_EXIT -eq 0 ]; then
                  echo "âœ… Application restarted with PM2"
                  PM2_RUNNING="1"
                # If restart fails, start a new process
                else
                  echo "   Restart output: $RESTART_OUTPUT"
                  echo "   Restart exit code: $RESTART_EXIT"
                  echo "   Trying to start new PM2 process..."
                  
                  # Delete existing process if it exists in error state
                  $PM2_CMD delete investment-crm-backend 2>/dev/null || echo "   No existing process to delete"
                  
                  # Start new process with full path and proper working directory
                  # Change to the deployment directory first to ensure correct working directory
                  cd "$DEPLOY_PATH/current"
                  echo "   Starting: $PM2_CMD start dist/index.js --name investment-crm-backend"
                  START_OUTPUT=$($PM2_CMD start dist/index.js --name investment-crm-backend 2>&1)
                  START_EXIT=$?
                  
                  echo "   Start output: $START_OUTPUT"
                  echo "   Start exit code: $START_EXIT"
                  
                  if [ $START_EXIT -eq 0 ]; then
                    echo "âœ… Application started with PM2"
                    PM2_RUNNING="1"
                  else
                    echo "âš ï¸  PM2 start command returned non-zero exit code"
                    # Check if PM2 process is actually running despite the error
                    sleep 3
                    echo "   Checking if process is running..."
                    if $PM2_CMD list 2>&1 | grep -q "investment-crm-backend"; then
                      PM2_RUNNING="1"
                      echo "âœ… PM2 process is running (despite error message)"
                      echo "ðŸ“‹ PM2 process details:"
                      $PM2_CMD list 2>&1 | grep -A 3 "investment-crm-backend" || true
                    else
                      echo "âŒ PM2 process not found in PM2 list"
                      echo "ðŸ“‹ Full PM2 status:"
                      $PM2_CMD status 2>&1 || true
                      echo "ðŸ“‹ PM2 list:"
                      $PM2_CMD list 2>&1 || true
                      echo "ðŸ“‹ PM2 logs (if any):"
                      $PM2_CMD logs investment-crm-backend --lines 10 --nostream 2>&1 || true
                    fi
                  fi
                fi
                
                # Final verification - check if process is ACTUALLY running
                if [ "$PM2_RUNNING" = "1" ]; then
                  echo "âœ… Verifying PM2 process is actually running..."
                  sleep 5  # Give process time to start
                  
                  # Check if process is in PM2 list
                  if $PM2_CMD list 2>&1 | grep -q "investment-crm-backend"; then
                    # Get process PID from PM2
                    if command -v jq &> /dev/null; then
                      PROCESS_PID=$($PM2_CMD jlist 2>/dev/null | jq -r '.[] | select(.name=="investment-crm-backend") | .pid' 2>/dev/null | head -1)
                    else
                      # Fallback: extract PID from pm2 describe output
                      PROCESS_PID=$($PM2_CMD describe investment-crm-backend 2>/dev/null | grep -E "pid.*:" | head -1 | awk '{print $4}' || echo "")
                    fi
                    
                    # Verify process is actually running (not just in PM2 list)
                    if [ -n "$PROCESS_PID" ] && ps -p "$PROCESS_PID" > /dev/null 2>&1; then
                      echo "âœ… Process actually running (PID: $PROCESS_PID)"
                      $PM2_CMD describe investment-crm-backend 2>&1 | head -20 || true
                    else
                      echo "âŒ Process is in PM2 list but not actually running (may have crashed)"
                      echo "ðŸ“‹ Checking PM2 logs for errors..."
                      $PM2_CMD logs investment-crm-backend --lines 20 --nostream 2>&1 || true
                      echo "âš ï¸  Process appears to have crashed, resetting flag"
                      PM2_RUNNING="0"
                    fi
                  else
                    echo "âš ï¸  PM2 process not found in list, resetting flag"
                    PM2_RUNNING="0"
                  fi
                fi
              fi
            fi
          else
            if [ "${PM2_AVAILABLE:-0}" != "1" ]; then
              echo "â„¹ï¸  PM2 not available (PM2_AVAILABLE=0), will use manual start"
            elif [ -z "$PM2_CMD" ]; then
              echo "â„¹ï¸  PM2 command not found, will use manual start"
            fi
          fi
          
          # Try systemctl if PM2 didn't work
          if [ "$PM2_RUNNING" = "0" ] && command -v systemctl &> /dev/null; then
            echo "ðŸ”„ Attempting to restart systemd service..."
            # Try without sudo first
            if systemctl restart investment-crm-backend 2>/dev/null; then
              echo "âœ… Service restarted (without sudo)"
            # Try with passwordless sudo if available
            elif sudo -n systemctl restart investment-crm-backend 2>/dev/null; then
              echo "âœ… Service restarted (with passwordless sudo)"
            # If systemctl exists but service doesn't, that's okay
            elif ! systemctl list-unit-files | grep -q "investment-crm-backend.service"; then
              echo "â„¹ï¸  Systemd service not configured, will start manually"
            else
              echo "âš ï¸  Service exists but restart failed (may need passwordless sudo)"
              echo "ðŸ’¡ Configure passwordless sudo: sudo visudo"
              echo "   Add: $USER ALL=(ALL) NOPASSWD: /bin/systemctl restart investment-crm-backend"
            fi
          fi
          
          # Verify PM2 process is actually running
          if [ "${PM2_AVAILABLE:-0}" = "1" ] && [ -n "$PM2_CMD" ] && [ "$PM2_RUNNING" = "1" ]; then
            # Double-check that PM2 process is actually running
            if ! $PM2_CMD list 2>/dev/null | grep -q "investment-crm-backend"; then
              PM2_RUNNING="0"
              echo "âš ï¸  PM2 process not found in PM2 list, will try manual start"
            fi
          fi
          
          # Check if application is already running
          APP_RUNNING="0"
          if pgrep -f 'node.*dist/index.js' > /dev/null 2>&1; then
            APP_RUNNING="1"
            echo "âœ… Application is already running"
          fi
          
          # Start application if not running
          if [ "$APP_RUNNING" = "0" ] && [ "$PM2_RUNNING" = "0" ]; then
            echo "ðŸš€ Starting application manually..."
            
            # Kill any existing processes
            pkill -f 'node.*dist/index.js' || true
            sleep 1
            
            # Change to the current release directory
            cd "$DEPLOY_PATH/current"
            echo "ðŸ“‚ Current directory: $(pwd)"
            
            # Verify the dist/index.js file exists
            if [ ! -f "dist/index.js" ]; then
              echo "âŒ Error: dist/index.js not found in $DEPLOY_PATH/current"
              echo "ðŸ’¡ Make sure the build completed successfully"
              exit 1
            fi
            
            # Check if required files exist
            echo "ðŸ” Checking for required files..."
            if [ ! -d "dist/config" ]; then
              echo "âŒ Error: dist/config directory not found"
              echo "ðŸ“‹ Contents of dist directory:"
              ls -la dist/ || true
              exit 1
            fi
            
            if [ ! -f "dist/config/logger.js" ]; then
              echo "âŒ Error: dist/config/logger.js not found"
              echo "ðŸ“‹ Contents of dist/config directory:"
              ls -la dist/config/ || true
              echo ""
              echo "ðŸ“‹ All files in dist:"
              find dist -type f -name "*.js" | head -20 || true
              exit 1
            fi
            
            echo "âœ… Required files found:"
            echo "   - dist/index.js"
            echo "   - dist/config/logger.js"
            
            # Check the import statement in the compiled code
            echo "ðŸ” Checking import statements in dist/index.js:"
            LOGGER_IMPORT=$(grep -E "from ['\"].*config/logger" dist/index.js | head -1 || echo "")
            
            if [ -n "$LOGGER_IMPORT" ]; then
              echo "ðŸ“‹ Found logger import: $LOGGER_IMPORT"
              
              if echo "$LOGGER_IMPORT" | grep -qE "\.js['\"]"; then
                echo "âœ… Import already has .js extension"
              else
                echo "âš ï¸  Import missing .js extension. ES modules require .js extensions."
                echo "ðŸ’¡ Fixing all relative imports in dist directory..."
                
                # Fix relative imports to include .js extension using sed
                echo "Fixing relative imports with sed..."
                # First, remove any double .js extensions that might exist
                find dist -name "*.js" -type f -exec sed -i 's|\.js\.js|\.js|g' {} \;
                
                # Fix specific logger imports (most common issue) - simple replacement
                # Single quotes
                find dist -name "*.js" -type f -exec sed -i "s|from './config/logger'|from './config/logger.js'|g" {} \;
                find dist -name "*.js" -type f -exec sed -i "s|from '../config/logger'|from '../config/logger.js'|g" {} \;
                # Double quotes
                find dist -name "*.js" -type f -exec sed -i 's|from "./config/logger"|from "./config/logger.js"|g' {} \;
                find dist -name "*.js" -type f -exec sed -i 's|from "../config/logger"|from "../config/logger.js"|g' {} \;
                
                # Fix general relative imports (only if doesn't already end with .js, .json, or .ts)
                # Single quotes - match ./path' or ../path' but not if already has extension
                find dist -name "*.js" -type f -exec sed -i "s|from '\\.\\(/[^']*\\)'\\([^jsn]\\)|from '\\.\\1.js'\\2|g" {} \;
                find dist -name "*.js" -type f -exec sed -i "s|from '\\.\\(/[^']*\\)'$|from '\\.\\1.js'|g" {} \;
                # Double quotes
                find dist -name "*.js" -type f -exec sed -i 's|from "\\.\\(/[^"]*\\)"\\([^jsn]\\)|from "\\.\\1.js"\\2|g' {} \;
                find dist -name "*.js" -type f -exec sed -i 's|from "\\.\\(/[^"]*\\)"$|from "\\.\\1.js"|g' {} \;
                
                # Final cleanup: remove any double .js extensions that might have been created
                find dist -name "*.js" -type f -exec sed -i 's|\.js\.js|\.js|g' {} \;
                
                # Verify the fix worked
                echo "   Verifying logger import was fixed..."
                if grep -q "from './config/logger.js'" dist/index.js 2>/dev/null || grep -q 'from "./config/logger.js"' dist/index.js 2>/dev/null; then
                  echo "   âœ… Logger import fixed successfully"
                else
                  echo "   âš ï¸  Logger import may not have been fixed, checking..."
                  grep -E "from ['\"].*config/logger" dist/index.js | head -3 || echo "   (no logger import found)"
                fi
                
                echo "âœ… Fixed imports to include .js extensions"
                echo "ðŸ“‹ Updated logger import:"
                grep -E "from ['\"].*config/logger" dist/index.js | head -1 || true
              fi
            else
              echo "âš ï¸  Could not find logger import"
              echo "ðŸ“‹ Sample of imports in dist/index.js:"
              grep -E "from ['\"]" dist/index.js | head -10 || true
            fi
            
            # Check if .env exists
            if [ ! -f ".env" ]; then
              echo "âš ï¸  Warning: .env file not found in current directory"
            fi
            
            # Start the application with proper error handling
            START_LOG="$DEPLOY_PATH/current/start.log"
            if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
              # Try passwordless sudo first
              if sudo -n true 2>/dev/null; then
                echo "Starting with sudo..."
                sudo nohup $NPM_CMD start > "$START_LOG" 2>&1 &
                START_PID=$!
              else
                echo "âš ï¸  Passwordless sudo not available, trying without sudo..."
                nohup $NPM_CMD start > "$START_LOG" 2>&1 &
                START_PID=$!
              fi
            else
              nohup $NPM_CMD start > "$START_LOG" 2>&1 &
              START_PID=$!
            fi
            
            echo "ðŸ“ Application start command executed (PID: $START_PID)"
            echo "ðŸ“‹ Logs will be written to: $START_LOG"
            
            # Wait a bit and check if process started
            sleep 3
            
            # Check if the process is running
            if pgrep -f 'node.*dist/index.js' > /dev/null 2>&1; then
              echo "âœ… Application started successfully"
              # Show last few lines of log
              if [ -f "$START_LOG" ]; then
                echo "ðŸ“‹ Last few lines of startup log:"
                tail -5 "$START_LOG" || echo "   (log file not readable)"
              fi
            else
              echo "âŒ Application failed to start"
              echo "ðŸ“‹ Checking startup log for errors:"
              if [ -f "$START_LOG" ]; then
                cat "$START_LOG" || echo "   (log file not readable)"
              else
                echo "   (log file not found)"
              fi
              echo ""
              echo "ðŸ’¡ Troubleshooting steps:"
              echo "   1. Check if Node.js is working: $NODE_CMD --version"
              echo "   2. Check if npm is working: $NPM_CMD --version"
              echo "   3. Try starting manually: cd $DEPLOY_PATH/current && $NPM_CMD start"
              echo "   4. Check application logs in: $DEPLOY_PATH/current"
              # Don't exit with error - deployment succeeded, just app didn't start
              echo "âš ï¸  Deployment completed but application may need manual start"
            fi
          elif [ "$PM2_RUNNING" = "1" ]; then
            echo "âœ… Application is running via PM2"
            echo "ðŸ“‹ PM2 status:"
            $PM2_CMD list 2>&1 | grep -A 5 "investment-crm-backend" || $PM2_CMD list 2>&1 || true
            echo "ðŸ’¡ To manage the process: $PM2_CMD [start|stop|restart|delete] investment-crm-backend"
          else
            echo "â„¹ï¸  Application started manually (not using PM2)"
            echo "ðŸ’¡ To use PM2 next time, ensure PM2 is installed and accessible"
          fi
          
          # Cleanup old releases (keep last 5)
          cd "$DEPLOY_PATH/releases"
          ls -t | tail -n +6 | xargs -r rm -rf

      - name: Show deployment method
        run: |
          if [ "$USE_SELF_HOSTED" = "true" ]; then
            echo "âœ… Using self-hosted runner deployment"
            echo "   The GitHub-hosted deployment step will be skipped"
            echo "   All deployment steps are handled by self-hosted runner steps above"
          else
            echo "âœ… Using GitHub-hosted runner deployment"
            echo "   The self-hosted deployment steps were skipped"
            echo "   Deployment will proceed via SSH"
          fi

      - name: Deploy to server (GitHub-hosted)
        if: env.USE_SELF_HOSTED != 'true'
        run: |
          DEPLOY_PATH="${DEPLOY_PATH:-/var/www/investment-crm/backend}"
          
          # GitHub-hosted runner: deploy via SSH
          echo "ðŸš€ Deploying via SSH..."
          
          # Create deployment directory on server
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
            mkdir -p $DEPLOY_PATH/releases
            mkdir -p $DEPLOY_PATH/shared
          "
          
          # Upload build artifact
          scp backend-deploy.tar.gz ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:$DEPLOY_PATH/releases/
          
          # Upload .env file if provided
          if [ -f backend-env.txt ]; then
            scp backend-env.txt ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:$DEPLOY_PATH/releases/backend-env.txt
          fi
          
          # Extract and deploy on server
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
              cd $DEPLOY_PATH/releases
            TIMESTAMP=\$(date +%Y%m%d%H%M%S)
            mkdir -p \$TIMESTAMP
            tar -xzf backend-deploy.tar.gz -C \$TIMESTAMP
            rm backend-deploy.tar.gz
            
            # Install production dependencies
            cd \$TIMESTAMP
              ${NPM_CMD:-npm} ci --production
            
            # Create .env file from secret or use shared .env
            if [ -f ../backend-env.txt ]; then
              cp ../backend-env.txt .env
              rm ../backend-env.txt
              echo 'âœ… Created .env file from BACKEND_ENV_FILE secret'
              elif [ -f $DEPLOY_PATH/shared/.env ]; then
                cp $DEPLOY_PATH/shared/.env .env
              echo 'âœ… Using shared .env file'
            else
              echo 'âŒ Error: No .env file found. Deployment cannot continue.'
              exit 1
            fi
            
            # Validate required environment variables
            echo 'ðŸ” Validating environment variables...'
            source .env
              if [ -z \"\$DATABASE_URL\" ]; then
              echo 'âŒ Error: DATABASE_URL is not set in .env file'
              exit 1
            fi
              if [ -z \"\$JWT_SECRET\" ]; then
              echo 'âŒ Error: JWT_SECRET is not set in .env file'
              exit 1
            fi
            echo 'âœ… Required environment variables are set'
            
              # Test database connectivity
            echo 'ðŸ—„ï¸  Testing database connectivity...'
            if command -v psql &> /dev/null; then
                DB_CONN=\$(echo \$DATABASE_URL | sed -E 's|postgresql://([^:]+):([^@]+)@([^:]+):([^/]+)/(.+)|host=\3 port=\4 user=\1 password=\2 dbname=\5|')
                if psql \"\$DB_CONN\" -c 'SELECT 1' &> /dev/null; then
                echo 'âœ… Database connection successful'
              else
                echo 'âš ï¸  Could not verify database connection with psql, but continuing...'
              fi
            else
              echo 'âš ï¸  psql not available, skipping database connectivity test'
            fi
            
            # Generate Prisma client
            echo 'ðŸ“¦ Generating Prisma client...'
              # Use the local Prisma binary directly
              if [ -f 'node_modules/.bin/prisma' ]; then
                node_modules/.bin/prisma generate || {
              echo 'âŒ Error: Failed to generate Prisma client'
              exit 1
            }
              elif [ -f './node_modules/.bin/prisma' ]; then
                ./node_modules/.bin/prisma generate || {
                  echo 'âŒ Error: Failed to generate Prisma client'
                  exit 1
                }
              elif command -v npx &> /dev/null; then
                npx prisma generate || {
                  echo 'âŒ Error: Failed to generate Prisma client'
                  exit 1
                }
              else
                ${NPM_CMD:-npm} run db:generate || {
              echo 'âŒ Error: Failed to generate Prisma client'
              exit 1
            }
              fi
            
            # Run database migrations
            echo 'ðŸ”„ Running database migrations...'
              if [ -f 'node_modules/.bin/prisma' ]; then
                node_modules/.bin/prisma migrate deploy || {
                  echo 'âŒ Error: Database migration failed'
                  exit 1
                }
              elif [ -f './node_modules/.bin/prisma' ]; then
                ./node_modules/.bin/prisma migrate deploy || {
                  echo 'âŒ Error: Database migration failed'
                  exit 1
                }
              elif command -v npx &> /dev/null; then
            npx prisma migrate deploy || {
              echo 'âŒ Error: Database migration failed'
              exit 1
            }
              else
                ${NPM_CMD:-npm} run db:generate || {
                  echo 'âŒ Error: Database migration failed'
                  exit 1
                }
              fi
            echo 'âœ… Database migrations completed'
            
            # Create symlink to current release
              cd $DEPLOY_PATH
            rm -f current
            ln -s releases/\$TIMESTAMP current
            
              # Restart application
            if command -v pm2 &> /dev/null; then
              pm2 restart investment-crm-backend || pm2 start current/dist/index.js --name investment-crm-backend
            elif command -v systemctl &> /dev/null; then
              sudo systemctl restart investment-crm-backend || echo 'Service not configured'
            else
              # Fallback: kill existing process and start new one
              pkill -f 'node.*dist/index.js' || true
              cd current
                nohup ${NPM_CMD:-npm} start > /dev/null 2>&1 &
            fi
            
            # Cleanup old releases (keep last 5)
            cd releases
            ls -t | tail -n +6 | xargs -r rm -rf
          "

      - name: Health check
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          echo "ðŸ¥ Performing health check..."
          # Wait a bit for the app to start
          sleep 10
          
          # Try multiple URLs
          HEALTH_URL="${BACKEND_URL:-http://localhost:3001}"
          if [ -z "$BACKEND_URL" ]; then
            # Try common ports
            for port in 3001 3000 8080; do
              if curl -f "http://localhost:$port/health" 2>/dev/null; then
                echo "âœ… Health check passed on port $port"
                exit 0
              fi
            done
            echo "âš ï¸  Health check failed on all ports, but deployment may still be successful"
            echo "ðŸ’¡ Check if the application is running: ps aux | grep node"
            exit 0  # Don't fail the deployment if health check fails
          else
            if curl -f "$HEALTH_URL/health" 2>/dev/null; then
              echo "âœ… Health check passed"
            else
              echo "âš ï¸  Health check failed, but deployment may still be successful"
              echo "ðŸ’¡ Verify the application manually at: $HEALTH_URL/health"
              exit 0  # Don't fail the deployment if health check fails
            fi
          fi


