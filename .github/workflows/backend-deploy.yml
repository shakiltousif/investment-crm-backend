name: Backend Deployment

on:
  push:
    branches:
      - main
      - master
    paths:
      - '.github/workflows/backend-deploy.yml'
  pull_request:
    branches:
      - main
      - master
    paths:
      - '.github/workflows/backend-deploy.yml'
  workflow_dispatch:

env:
  NODE_VERSION: '20'

jobs:
  test:
    name: Test Backend
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: investment_crm_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        id: setup-node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: package-lock.json
        continue-on-error: true

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npm run db:generate
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/investment_crm_test

      - name: Run database migrations
        run: npx prisma migrate deploy
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/investment_crm_test

      - name: Run linter
        run: npm run lint

      - name: Type check
        run: npm run type-check

      - name: Run tests
        run: npm test
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/investment_crm_test
          NODE_ENV: test
          JWT_SECRET: test-secret-key

  build:
    name: Build Backend
    runs-on: ubuntu-latest
    needs: test
    if: |
      always() &&
      (needs.test.result == 'success' || needs.test.result == 'skipped') &&
      ((github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')) ||
       (github.event_name == 'workflow_dispatch' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')))
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify package-lock.json exists
        run: |
          if [ ! -f package-lock.json ]; then
            echo "Warning: package-lock.json not found, cache will be skipped"
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npm run db:generate

      - name: Build application
        run: |
          echo "üî® Building application..."
          npm run build
          
          # Check if build was successful
          if [ $? -ne 0 ]; then
            echo "‚ùå Build failed"
            exit 1
          fi
          
          echo "‚úÖ Build completed"

      - name: Verify build output
        run: |
          echo "üîç Verifying build output..."
          if [ ! -d "dist" ]; then
            echo "‚ùå Error: dist directory not found"
            exit 1
          fi
          
          # Check for critical files
          if [ ! -f "dist/index.js" ]; then
            echo "‚ùå Error: dist/index.js not found"
            exit 1
          fi
          
          # Check if config directory exists
          if [ ! -d "dist/config" ]; then
            echo "‚ö†Ô∏è  Warning: dist/config directory not found"
            echo "üìã Contents of dist directory:"
            ls -la dist/ || true
          else
            echo "‚úÖ dist/config directory found"
            if [ ! -f "dist/config/logger.js" ]; then
              echo "‚ö†Ô∏è  Warning: dist/config/logger.js not found"
              echo "üìã Contents of dist/config:"
              ls -la dist/config/ || true
            else
              echo "‚úÖ dist/config/logger.js found"
            fi
          fi
          
          # Show dist structure
          echo "üìã Build output structure:"
          find dist -type f -name "*.js" | head -20 || true
          
          # Check if config directory has all files
          if [ -d "dist/config" ]; then
            echo "üìã Files in dist/config:"
            ls -la dist/config/ || true
            CONFIG_FILE_COUNT=$(find dist/config -name "*.js" | wc -l)
            echo "‚úÖ Found $CONFIG_FILE_COUNT .js files in dist/config"
          fi
          
          # Check compiled index.js for import statements
          if [ -f "dist/index.js" ]; then
            echo "üìã Checking imports in dist/index.js:"
            grep -E "from ['\"].*config/logger" dist/index.js | head -5 || echo "   (no logger import found or different format)"
          fi
          
          echo "‚úÖ Build verification complete"

      - name: Create deployment package
        run: |
          echo "üì¶ Creating deployment package..."
          mkdir -p deploy
          
          # Copy dist directory (preserve structure)
          if [ -d "dist" ]; then
          cp -r dist deploy/
            echo "‚úÖ Copied dist directory"
          else
            echo "‚ùå Error: dist directory not found"
            exit 1
          fi
          
          # Copy prisma directory
          if [ -d "prisma" ]; then
          cp -r prisma deploy/
            echo "‚úÖ Copied prisma directory"
          fi
          
          # Copy package files
          cp package.json deploy/
          cp package-lock.json deploy/
          
          # Verify package contents
          echo "üìã Deployment package contents:"
          ls -la deploy/ || true
          if [ -d "deploy/dist" ]; then
            echo "üìã dist directory structure:"
            find deploy/dist -type f -name "*.js" | head -10 || true
          fi
          
          # Create tarball
          tar -czf backend-deploy.tar.gz -C deploy .
          echo "‚úÖ Created backend-deploy.tar.gz"
          
          # Verify tarball
          echo "üìã Verifying tarball contents:"
          tar -tzf backend-deploy.tar.gz | head -20 || true
          
          rm -rf deploy

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: backend-build
          path: backend-deploy.tar.gz
          retention-days: 1

  pre-deploy-check:
    name: Pre-Deployment Validation
    runs-on: ${{ vars.USE_SELF_HOSTED_RUNNER == 'true' && 'self-hosted' || 'ubuntu-latest' }}
    needs: build
    if: |
      (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')) ||
      (github.event_name == 'workflow_dispatch' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'))
    
    env:
      USE_SELF_HOSTED: ${{ vars.USE_SELF_HOSTED_RUNNER == 'true' }}
      WORKSPACE_PATH: $WORKSPACE_PATH
      DEPLOY_PATH: ${{ secrets.BACKEND_DEPLOY_PATH || '/var/www/investment-crm/backend' }}
    
    steps:
      - name: Setup SSH (for GitHub-hosted runners only)
        if: env.USE_SELF_HOSTED != 'true'
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts (for GitHub-hosted runners only)
        if: env.USE_SELF_HOSTED != 'true'
        run: |
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Setup environment for self-hosted runner
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          echo "‚úÖ Running on self-hosted runner - no SSH needed"
          [ -f /etc/profile ] && source /etc/profile
          [ -f ~/.bashrc ] && source ~/.bashrc
          [ -f ~/.bash_profile ] && source ~/.bash_profile
          [ -f ~/.profile ] && source ~/.profile
          export PATH="/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin:$PATH"
          export PATH="$HOME/.nvm/versions/node/*/bin:$PATH"
          export PATH="/opt/nodejs/bin:$PATH"

      - name: Validate Node.js (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          echo "üì¶ Checking Node.js installation..."
          echo "Current user: $(whoami)"
          echo "Current PATH: $PATH"
          
          NODE_CMD=""
          if [ -d /opt/nodejs/bin ]; then
            echo "Checking /opt/nodejs/bin directory..."
            ls -la /opt/nodejs/bin/ 2>/dev/null | head -10 || echo "Cannot list /opt/nodejs/bin"
            if [ -f /opt/nodejs/bin/node ]; then
              if [ -x /opt/nodejs/bin/node ]; then
                NODE_CMD="/opt/nodejs/bin/node"
                echo "‚úÖ Found executable node in /opt/nodejs/bin"
              else
                echo "‚ö†Ô∏è  Found node in /opt/nodejs/bin but not executable"
                if sudo chmod +x /opt/nodejs/bin/node 2>/dev/null; then
                  NODE_CMD="/opt/nodejs/bin/node"
                  echo "‚úÖ Made node executable"
                fi
              fi
            fi
          fi
          
          if [ -z "$NODE_CMD" ]; then
            if command -v node &> /dev/null; then
              NODE_CMD="node"
              echo "‚úÖ Found node via command -v"
            elif [ -f /usr/local/bin/node ]; then
              NODE_CMD="/usr/local/bin/node"
              echo "‚úÖ Found node in /usr/local/bin"
            elif [ -f /usr/bin/node ]; then
              NODE_CMD="/usr/bin/node"
              echo "‚úÖ Found node in /usr/bin"
            fi
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            if [ -d /root/.nvm/versions/node ]; then
              NODE_CMD=$(find /root/.nvm/versions/node -name node -type f -executable 2>/dev/null | sort -V | tail -1)
            fi
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            if [ -d "$HOME/.nvm/versions/node" ]; then
              NODE_CMD=$(find "$HOME/.nvm/versions/node" -name node -type f -executable 2>/dev/null | sort -V | tail -1)
            fi
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            NODE_CMD=$(find /usr/local/bin /usr/bin /opt /root/.nvm /root/.local /root/bin -name node -type f -executable 2>/dev/null | head -1)
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            ROOT_NODE=$(sudo sh -c 'command -v node' 2>/dev/null || echo "")
            if [ -z "$ROOT_NODE" ]; then
              ROOT_NODE=$(sudo -n sh -c 'command -v node' 2>/dev/null || echo "")
            fi
            if [ -n "$ROOT_NODE" ] && [ -f "$ROOT_NODE" ]; then
              NODE_CMD="$ROOT_NODE"
              echo "Found node via root's PATH: $NODE_CMD"
            fi
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            if [ -f /root/.bashrc ]; then
              ROOT_NVM_DIR=$(grep -o 'NVM_DIR="[^"]*"' /root/.bashrc 2>/dev/null | cut -d'"' -f2 || echo "")
              if [ -n "$ROOT_NVM_DIR" ] && [ -d "$ROOT_NVM_DIR/versions/node" ]; then
                NODE_CMD=$(find "$ROOT_NVM_DIR/versions/node" -name node -type f -executable 2>/dev/null | sort -V | tail -1)
              fi
            fi
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            ROOT_NODE_PATH=$(sudo sh -c 'which node 2>&1' 2>/dev/null | grep -v "not found" | head -1 || echo "")
            if [ -n "$ROOT_NODE_PATH" ] && [ "$ROOT_NODE_PATH" != "" ]; then
              if sudo test -f "$ROOT_NODE_PATH" 2>/dev/null; then
                echo "‚úÖ Found Node.js at: $ROOT_NODE_PATH (requires sudo)"
                NODE_CMD="$ROOT_NODE_PATH"
                echo "USE_SUDO_FOR_NODE=1" >> $GITHUB_ENV
                echo "‚úÖ Will use sudo for all Node.js/npm commands"
              fi
            fi
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            ROOT_NODE_PATH=$(sudo sh -c 'which node 2>&1' 2>/dev/null | grep -v "not found" | head -1 || echo "")
            if [ -n "$ROOT_NODE_PATH" ] && sudo test -f "$ROOT_NODE_PATH" 2>/dev/null; then
              echo "Found Node.js at: $ROOT_NODE_PATH"
              if sudo ln -sf "$ROOT_NODE_PATH" /usr/local/bin/node 2>/dev/null; then
                sudo chmod +x /usr/local/bin/node 2>/dev/null
                if [ -f /usr/local/bin/node ] && [ -x /usr/local/bin/node ]; then
                  NODE_CMD="/usr/local/bin/node"
                  echo "‚úÖ Symlink created successfully"
                fi
              fi
            fi
          fi
          
          if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
            echo "‚ùå Node.js is not installed on the server or not accessible"
            exit 1
          fi
          
          if [ ! -x "$NODE_CMD" ]; then
            if sudo chmod +x "$NODE_CMD" 2>/dev/null; then
              echo "‚úÖ Made Node.js executable"
            else
              echo "‚ùå Node.js found at $NODE_CMD but cannot be executed"
              exit 1
            fi
          fi
          
          if [ "${USE_SUDO_FOR_NODE:-}" = "1" ]; then
            NODE_VERSION=$(sudo $NODE_CMD --version 2>/dev/null || echo "unknown")
          else
            NODE_VERSION=$($NODE_CMD --version 2>/dev/null || sudo $NODE_CMD --version 2>/dev/null || echo "unknown")
          fi
          echo "‚úÖ Node.js found at: $NODE_CMD"
          echo "‚úÖ Node.js version: $NODE_VERSION"
          echo "NODE_CMD=$NODE_CMD" >> $GITHUB_ENV

      - name: Validate npm (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          echo "üì¶ Checking npm installation..."
          NPM_CMD=""
          if [ -f /opt/nodejs/bin/npm ] && [ -x /opt/nodejs/bin/npm ]; then
            NPM_CMD="/opt/nodejs/bin/npm"
          elif command -v npm &> /dev/null; then
            NPM_CMD="npm"
          elif [ -f /usr/local/bin/npm ]; then
            NPM_CMD="/usr/local/bin/npm"
          elif [ -f /usr/bin/npm ]; then
            NPM_CMD="/usr/bin/npm"
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            if [ -n "$NODE_CMD" ] && [ -d "$(dirname "$NODE_CMD")" ]; then
              NPM_CMD="$(dirname "$NODE_CMD")/npm"
              [ ! -f "$NPM_CMD" ] && NPM_CMD=""
            elif [ -d /root/.nvm/versions/node ]; then
              NPM_CMD=$(find /root/.nvm/versions/node -name npm -type f -executable 2>/dev/null | sort -V | tail -1)
            fi
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            if [ -d "$HOME/.nvm/versions/node" ]; then
              NPM_CMD=$(find "$HOME/.nvm/versions/node" -name npm -type f -executable 2>/dev/null | sort -V | tail -1)
            fi
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            NPM_CMD=$(find /usr/local/bin /usr/bin /opt /root/.nvm /root/.local /root/bin -name npm -type f -executable 2>/dev/null | head -1)
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            ROOT_NPM=$(sudo sh -c 'command -v npm' 2>/dev/null || echo "")
            [ -z "$ROOT_NPM" ] && ROOT_NPM=$(sudo -n sh -c 'command -v npm' 2>/dev/null || echo "")
            if [ -n "$ROOT_NPM" ] && [ -f "$ROOT_NPM" ]; then
              NPM_CMD="$ROOT_NPM"
            fi
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            if [ -f /root/.bashrc ]; then
              ROOT_NVM_DIR=$(grep -o 'NVM_DIR="[^"]*"' /root/.bashrc 2>/dev/null | cut -d'"' -f2 || echo "")
              if [ -n "$ROOT_NVM_DIR" ] && [ -d "$ROOT_NVM_DIR/versions/node" ]; then
                NPM_CMD=$(find "$ROOT_NVM_DIR/versions/node" -name npm -type f -executable 2>/dev/null | sort -V | tail -1)
              fi
            fi
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            ROOT_NPM_PATH=$(sudo sh -c 'which npm 2>&1' 2>/dev/null | grep -v "not found" | head -1 || echo "")
            if [ -n "$ROOT_NPM_PATH" ] && [ "$ROOT_NPM_PATH" != "" ]; then
              if sudo test -f "$ROOT_NPM_PATH" 2>/dev/null; then
                echo "‚úÖ Found npm at: $ROOT_NPM_PATH (requires sudo)"
                NPM_CMD="$ROOT_NPM_PATH"
                if [ "${USE_SUDO_FOR_NODE:-}" != "1" ]; then
                  echo "USE_SUDO_FOR_NODE=1" >> $GITHUB_ENV
                fi
              fi
            fi
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            ROOT_NPM_PATH=$(sudo sh -c 'which npm 2>&1' 2>/dev/null | grep -v "not found" | head -1 || echo "")
            if [ -n "$ROOT_NPM_PATH" ] && sudo test -f "$ROOT_NPM_PATH" 2>/dev/null; then
              if sudo ln -sf "$ROOT_NPM_PATH" /usr/local/bin/npm 2>/dev/null; then
                sudo chmod +x /usr/local/bin/npm 2>/dev/null
                if [ -f /usr/local/bin/npm ] && [ -x /usr/local/bin/npm ]; then
                  NPM_CMD="/usr/local/bin/npm"
                fi
              fi
            fi
          fi
          
          if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
            echo "‚ùå npm is not installed on the server or not accessible"
            exit 1
          fi
          
          if [ ! -x "$NPM_CMD" ]; then
            if sudo chmod +x "$NPM_CMD" 2>/dev/null; then
              echo "‚úÖ Made npm executable"
            else
              echo "‚ùå npm found at $NPM_CMD but cannot be executed"
              exit 1
            fi
          fi
          
          if [ "${USE_SUDO_FOR_NODE:-}" = "1" ]; then
            NPM_VERSION=$(sudo $NPM_CMD --version 2>/dev/null || echo "unknown")
          else
            NPM_VERSION=$($NPM_CMD --version 2>/dev/null || sudo $NPM_CMD --version 2>/dev/null || echo "unknown")
          fi
          echo "‚úÖ npm found at: $NPM_CMD"
          echo "‚úÖ npm version: $NPM_VERSION"
          echo "NPM_CMD=$NPM_CMD" >> $GITHUB_ENV

      - name: Validate deployment directory and Docker (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          echo "üìÅ Checking deployment directory..."
          DEPLOY_PATH="$DEPLOY_PATH"
          if [ ! -d "$DEPLOY_PATH" ]; then
            mkdir -p "$DEPLOY_PATH/releases"
            mkdir -p "$DEPLOY_PATH/shared"
          fi
          if [ ! -w "$DEPLOY_PATH" ]; then
            echo "‚ùå Deployment directory is not writable"
            exit 1
          fi
          echo "‚úÖ Deployment directory is ready"
          
          echo "üîê Checking environment configuration..."
          if [ -n "${{ secrets.BACKEND_ENV_FILE }}" ]; then
            echo "‚úÖ BACKEND_ENV_FILE secret is set"
          elif [ -f "$DEPLOY_PATH/shared/.env" ]; then
            echo "‚úÖ Shared .env file found"
          else
            echo "‚ùå No .env file found"
            exit 1
          fi
          
          echo "üê≥ Checking Docker and services..."
          if command -v docker &> /dev/null; then
            echo "‚úÖ Docker is installed"
            if command -v docker-compose &> /dev/null; then
              DOCKER_COMPOSE_CMD="docker-compose"
            elif docker compose version &> /dev/null; then
              DOCKER_COMPOSE_CMD="docker compose"
            else
              if command -v apt-get &> /dev/null; then
                sudo apt-get update && sudo apt-get install -y docker-compose-plugin 2>/dev/null || true
                DOCKER_COMPOSE_CMD="docker compose"
              fi
            fi
            
            if [ -n "$DOCKER_COMPOSE_CMD" ]; then
              # Check workspace root first (backend and frontend are separate repos)
              if [ -f "$WORKSPACE_PATH/docker-compose.yml" ]; then
                DOCKER_COMPOSE_FILE="$WORKSPACE_PATH/docker-compose.yml"
                DOCKER_COMPOSE_DIR="$WORKSPACE_PATH"
              elif [ -f "$DEPLOY_PATH/docker-compose.yml" ]; then
                DOCKER_COMPOSE_FILE="$DEPLOY_PATH/docker-compose.yml"
                DOCKER_COMPOSE_DIR="$DEPLOY_PATH"
              elif [ -f "$DEPLOY_PATH/current/docker-compose.yml" ]; then
                DOCKER_COMPOSE_FILE="$DEPLOY_PATH/current/docker-compose.yml"
                DOCKER_COMPOSE_DIR="$DEPLOY_PATH/current"
              fi
              
              if [ -n "$DOCKER_COMPOSE_FILE" ]; then
                cd "$DOCKER_COMPOSE_DIR"
                POSTGRES_RUNNING=$(docker ps --filter "name=investment_crm_db" --filter "status=running" --format "{{.Names}}" 2>/dev/null | grep -c "investment_crm_db" || echo "0")
                REDIS_RUNNING=$(docker ps --filter "name=investment_crm_redis" --filter "status=running" --format "{{.Names}}" 2>/dev/null | grep -c "investment_crm_redis" || echo "0")
                
                if [ "$POSTGRES_RUNNING" = "0" ] || [ "$REDIS_RUNNING" = "0" ]; then
                  echo "üöÄ Starting Docker services..."
                  if [ "${USE_SUDO_FOR_NODE:-}" = "1" ]; then
                    sudo $DOCKER_COMPOSE_CMD up -d postgres redis 2>&1 || $DOCKER_COMPOSE_CMD up -d postgres redis 2>&1 || exit 1
                  else
                    $DOCKER_COMPOSE_CMD up -d postgres redis 2>&1 || exit 1
                  fi
                  sleep 3
                  
                  RETRY_COUNT=0
                  while [ $RETRY_COUNT -lt 30 ]; do
                    if docker exec investment_crm_db pg_isready -U postgres &> /dev/null 2>&1; then
                      echo "‚úÖ PostgreSQL is ready"
                      break
                    fi
                    RETRY_COUNT=$((RETRY_COUNT + 1))
                    [ $((RETRY_COUNT % 5)) -eq 0 ] && echo "  Still waiting... ($RETRY_COUNT/30)"
                    sleep 2
                  done
                  
                  RETRY_COUNT=0
                  while [ $RETRY_COUNT -lt 30 ]; do
                    if docker exec investment_crm_redis redis-cli ping &> /dev/null 2>&1; then
                      echo "‚úÖ Redis is ready"
                      break
                    fi
                    RETRY_COUNT=$((RETRY_COUNT + 1))
                    [ $((RETRY_COUNT % 5)) -eq 0 ] && echo "  Still waiting... ($RETRY_COUNT/30)"
                    sleep 2
                  done
                else
                  echo "‚úÖ Docker services are already running"
                fi
              fi
            fi
          fi
          
          if command -v psql &> /dev/null; then
            echo "‚úÖ PostgreSQL client is installed"
          fi
          
          if command -v pm2 &> /dev/null; then
            echo "‚úÖ Process manager found: pm2"
          elif command -v systemctl &> /dev/null; then
            echo "‚úÖ Process manager found: systemd"
          fi

      - name: Validate server prerequisites (GitHub-hosted)
        if: env.USE_SELF_HOSTED != 'true'
        run: |
          echo "üì° Testing SSH connection..."
          ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "echo 'SSH connection successful'" || {
            echo "‚ùå SSH connection failed"
            exit 1
          }
          
          NODE_VERSION=$(ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "node --version 2>/dev/null || echo 'not_installed'")
          if [ "$NODE_VERSION" = "not_installed" ]; then
            echo "‚ùå Node.js is not installed on the server"
            exit 1
          fi
          echo "‚úÖ Node.js version: $NODE_VERSION"
          
          NPM_VERSION=$(ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "npm --version 2>/dev/null || echo 'not_installed'")
          if [ "$NPM_VERSION" = "not_installed" ]; then
            echo "‚ùå npm is not installed on the server"
            exit 1
          fi
          echo "‚úÖ npm version: $NPM_VERSION"
          
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
            if [ ! -d '${{ secrets.BACKEND_DEPLOY_PATH }}' ]; then
              mkdir -p '${{ secrets.BACKEND_DEPLOY_PATH }}/releases'
              mkdir -p '${{ secrets.BACKEND_DEPLOY_PATH }}/shared'
            fi
            if [ ! -w '${{ secrets.BACKEND_DEPLOY_PATH }}' ]; then
              echo '‚ùå Deployment directory is not writable'
              exit 1
            fi
            echo '‚úÖ Deployment directory is ready'
          " || exit 1
          
          if [ -n "${{ secrets.BACKEND_ENV_FILE }}" ]; then
            echo "‚úÖ BACKEND_ENV_FILE secret is set"
          else
            ENV_EXISTS=$(ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
              if [ -f '${{ secrets.BACKEND_DEPLOY_PATH }}/shared/.env' ]; then
                echo 'exists'
              else
                echo 'missing'
              fi
            ")
            if [ "$ENV_EXISTS" = "missing" ]; then
              echo "‚ùå No .env file found"
              exit 1
            fi
            echo "‚úÖ Shared .env file found"
          fi
          
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
            if command -v psql &> /dev/null; then
              echo '‚úÖ PostgreSQL client is installed'
            fi
          " || true
          
          PM_MANAGER=$(ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
            if command -v pm2 &> /dev/null; then
              echo 'pm2'
            elif command -v systemctl &> /dev/null; then
              echo 'systemd'
            else
              echo 'none'
            fi
          ")
          if [ "$PM_MANAGER" != "none" ]; then
            echo "‚úÖ Process manager found: $PM_MANAGER"
          fi
          
          echo "‚úÖ All prerequisites validated successfully!"

  deploy:
    name: Deploy Backend to Server
    runs-on: ${{ vars.USE_SELF_HOSTED_RUNNER == 'true' && 'self-hosted' || 'ubuntu-latest' }}
    needs: [build, pre-deploy-check]
    if: |
      (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')) ||
      (github.event_name == 'workflow_dispatch' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'))
    environment:
      name: production
    
    env:
      USE_SELF_HOSTED: ${{ vars.USE_SELF_HOSTED_RUNNER == 'true' }}
      WORKSPACE_PATH: ${{ github.workspace }}
      DEPLOY_PATH: ${{ secrets.BACKEND_DEPLOY_PATH || '/var/www/investment-crm/backend' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: backend-build
          path: .

      - name: Setup SSH (for GitHub-hosted runners only)
        if: env.USE_SELF_HOSTED != 'true'
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts (for GitHub-hosted runners only)
        if: env.USE_SELF_HOSTED != 'true'
        run: |
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Create .env file from secret
        run: |
          if [ -n "${{ secrets.BACKEND_ENV_FILE }}" ]; then
            echo "${{ secrets.BACKEND_ENV_FILE }}" > backend-env.txt
          fi

      - name: Setup PATH for self-hosted runner
        if: vars.USE_SELF_HOSTED_RUNNER == 'true'
        run: |
          # Source common profile files to ensure PATH is set correctly
          [ -f /etc/profile ] && source /etc/profile
          [ -f ~/.bashrc ] && source ~/.bashrc
          [ -f ~/.bash_profile ] && source ~/.bash_profile
          [ -f ~/.profile ] && source ~/.profile
          
          # Add common Node.js paths to PATH
          export PATH="/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin:$PATH"
          export PATH="$HOME/.nvm/versions/node/*/bin:$PATH"
          export PATH="/opt/nodejs/bin:$PATH"
          
          # Find Node.js and npm if not in PATH (including root's installation)
          if ! command -v node &> /dev/null; then
            NODE_CMD=$(find /usr/local /usr /opt /root -name node -type f -executable 2>/dev/null | head -1)
            if [ -z "$NODE_CMD" ]; then
              # Try using root's PATH
              ROOT_NODE=$(sudo -n sh -c 'command -v node' 2>/dev/null || echo "")
              if [ -n "$ROOT_NODE" ] && [ -f "$ROOT_NODE" ]; then
                NODE_CMD="$ROOT_NODE"
              fi
            fi
            if [ -n "$NODE_CMD" ]; then
              echo "NODE_CMD=$NODE_CMD" >> $GITHUB_ENV
              echo "PATH=$(dirname $NODE_CMD):$PATH" >> $GITHUB_ENV
            fi
          fi
          
          if ! command -v npm &> /dev/null; then
            NPM_CMD=$(find /usr/local /usr /opt /root -name npm -type f -executable 2>/dev/null | head -1)
            if [ -z "$NPM_CMD" ]; then
              # Try using root's PATH
              ROOT_NPM=$(sudo -n sh -c 'command -v npm' 2>/dev/null || echo "")
              if [ -n "$ROOT_NPM" ] && [ -f "$ROOT_NPM" ]; then
                NPM_CMD="$ROOT_NPM"
              fi
            fi
            if [ -n "$NPM_CMD" ]; then
              echo "NPM_CMD=$NPM_CMD" >> $GITHUB_ENV
              echo "PATH=$(dirname $NPM_CMD):$PATH" >> $GITHUB_ENV
            fi
          fi
          
          # Verify Node.js and npm are accessible
          echo "Node.js: $(command -v node || echo 'not found')"
          echo "npm: $(command -v npm || echo 'not found')"
          if [ -n "$NODE_CMD" ]; then
            $NODE_CMD --version || echo "Node.js version check failed"
          fi
          if [ -n "$NPM_CMD" ]; then
            $NPM_CMD --version || echo "npm version check failed"
          fi

      - name: Setup deployment environment (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          # Set deployment path (already set in env)
          DEPLOY_PATH="${DEPLOY_PATH:-/var/www/investment-crm/backend}"
          
          # Source profile to ensure PATH is correct
          [ -f /etc/profile ] && source /etc/profile
          [ -f ~/.bashrc ] && source ~/.bashrc
          [ -f ~/.profile ] && source ~/.profile
          
          # Use NPM_CMD from environment or find it (including root's installation)
          if [ -z "$NPM_CMD" ]; then
            if command -v npm &> /dev/null; then
              NPM_CMD="npm"
            else
              NPM_CMD=$(find /usr/local /usr /opt /root -name npm -type f -executable 2>/dev/null | head -1)
              if [ -z "$NPM_CMD" ]; then
                # Try using root's PATH
                ROOT_NPM=$(sudo -n sh -c 'command -v npm' 2>/dev/null || echo "")
                if [ -n "$ROOT_NPM" ] && [ -f "$ROOT_NPM" ]; then
                  NPM_CMD="$ROOT_NPM"
                fi
              fi
            fi
          fi
          
          if [ -z "$NPM_CMD" ]; then
            echo "‚ùå Error: npm not found"
            echo "üí° Tip: Run this on your server as root to fix:"
            echo "   sudo ln -s \$(sudo which npm) /usr/local/bin/npm"
            echo "   sudo ln -s \$(sudo which node) /usr/local/bin/node"
            exit 1
          fi
          
          echo "Using npm at: $NPM_CMD"
          echo "NPM_CMD=$NPM_CMD" >> $GITHUB_ENV
          
          # Create deployment directory
          mkdir -p "$DEPLOY_PATH/releases"
          mkdir -p "$DEPLOY_PATH/shared"
          
          # Move build artifact
          mv backend-deploy.tar.gz "$DEPLOY_PATH/releases/"
          
          # Copy docker-compose.yml to deployment directory for easy access
          # Check workspace root first (backend and frontend are separate repos)
          if [ -f "$WORKSPACE_PATH/docker-compose.yml" ]; then
            echo "üìã Copying docker-compose.yml to deployment directory..."
            mkdir -p "$DEPLOY_PATH"
            cp "$WORKSPACE_PATH/docker-compose.yml" "$DEPLOY_PATH/docker-compose.yml" || echo "‚ö†Ô∏è  Failed to copy docker-compose.yml (non-critical)"
          fi
          
          # Extract and deploy
          cd "$DEPLOY_PATH/releases"
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          mkdir -p "$TIMESTAMP"
          
          echo "üì¶ Extracting deployment package..."
          tar -xzf backend-deploy.tar.gz -C "$TIMESTAMP"
          rm backend-deploy.tar.gz
          
          # Verify extracted files
          echo "üîç Verifying extracted files..."
          if [ ! -f "$TIMESTAMP/dist/index.js" ]; then
            echo "‚ùå Error: dist/index.js not found after extraction"
            echo "üìã Contents of $TIMESTAMP:"
            ls -la "$TIMESTAMP/" || true
            exit 1
          fi
          
          if [ ! -d "$TIMESTAMP/dist/config" ]; then
            echo "‚ùå Error: dist/config directory not found after extraction"
            echo "üìã Contents of $TIMESTAMP/dist:"
            ls -la "$TIMESTAMP/dist/" || true
            exit 1
          fi
          
          if [ ! -f "$TIMESTAMP/dist/config/logger.js" ]; then
            echo "‚ùå Error: dist/config/logger.js not found after extraction"
            echo "üìã Contents of $TIMESTAMP/dist/config:"
            ls -la "$TIMESTAMP/dist/config/" || true
            exit 1
          fi
          
          echo "‚úÖ All required files extracted successfully"
          echo "üìã Sample of extracted structure:"
          find "$TIMESTAMP/dist" -type f -name "*.js" | head -10 || true
          
          echo "TIMESTAMP=$TIMESTAMP" >> $GITHUB_ENV
          echo "RELEASE_DIR=$DEPLOY_PATH/releases/$TIMESTAMP" >> $GITHUB_ENV

      - name: Install dependencies (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          cd "$RELEASE_DIR"
          echo "üìÇ Release directory: $RELEASE_DIR"
          
          if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
            sudo $NPM_CMD ci --production
          else
            $NPM_CMD ci --production
          fi
          
          # Verify Prisma is installed
          if [ ! -f "node_modules/.bin/prisma" ]; then
            echo "‚ö†Ô∏è  Prisma binary not found after npm ci"
            echo "   Checking if prisma package is installed..."
            if [ -d "node_modules/prisma" ]; then
              echo "   ‚úÖ prisma package found in node_modules"
              echo "   Listing node_modules/.bin:"
              ls -la node_modules/.bin/ 2>/dev/null | head -10 || echo "   node_modules/.bin not found"
            else
              echo "   ‚ùå prisma package not found in node_modules"
              echo "   This might be because prisma is in devDependencies"
              echo "   Installing prisma as production dependency..."
              if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
                sudo $NPM_CMD install prisma@^5.20.0 --save --no-save || true
              else
                $NPM_CMD install prisma@^5.20.0 --save --no-save || true
              fi
            fi
          fi

      - name: Setup environment variables (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          cd "$RELEASE_DIR"
          DEPLOY_PATH="${DEPLOY_PATH:-/var/www/investment-crm/backend}"
          
          # Create .env file from secret or use shared .env
          if [ -f "$WORKSPACE_PATH/backend-env.txt" ]; then
            cp "$WORKSPACE_PATH/backend-env.txt" .env
            rm "$WORKSPACE_PATH/backend-env.txt"
            echo "‚úÖ Created .env file from BACKEND_ENV_FILE secret"
          elif [ -f "$DEPLOY_PATH/shared/.env" ]; then
            cp "$DEPLOY_PATH/shared/.env" .env
            echo "‚úÖ Using shared .env file"
          else
            echo "‚ùå Error: No .env file found. Deployment cannot continue."
            exit 1
          fi
          
          # Validate required environment variables
          echo "üîç Validating environment variables..."
          set -a
          source .env
          set +a
          if [ -z "$DATABASE_URL" ]; then
            echo "‚ùå Error: DATABASE_URL is not set in .env file"
            exit 1
          fi
          if [ -z "$JWT_SECRET" ]; then
            echo "‚ùå Error: JWT_SECRET is not set in .env file"
            exit 1
          fi
          echo "‚úÖ Required environment variables are set"

      - name: Start Docker services (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          DEPLOY_PATH="${DEPLOY_PATH:-/var/www/investment-crm/backend}"
          
          # Check for Docker (try multiple methods)
          DOCKER_CMD=""
          if command -v docker &> /dev/null; then
            DOCKER_CMD="docker"
            echo "‚úÖ Docker is installed (found via command -v)"
          elif [ -f /usr/bin/docker ]; then
            DOCKER_CMD="/usr/bin/docker"
            echo "‚úÖ Docker is installed (found at /usr/bin/docker)"
          elif [ -f /usr/local/bin/docker ]; then
            DOCKER_CMD="/usr/local/bin/docker"
            echo "‚úÖ Docker is installed (found at /usr/local/bin/docker)"
          elif sudo command -v docker &> /dev/null; then
            DOCKER_CMD="sudo docker"
            echo "‚úÖ Docker is installed (found via sudo command -v)"
          else
            echo "‚ö†Ô∏è  Docker is not found in PATH"
            DOCKER_CMD=$(find /usr /opt -name docker -type f -executable 2>/dev/null | head -1)
            if [ -n "$DOCKER_CMD" ]; then
              echo "‚úÖ Docker found at: $DOCKER_CMD"
            else
              echo "‚ùå Docker is not installed or not accessible"
              exit 1
            fi
          fi
          
          if [ -n "$DOCKER_CMD" ]; then
            # Check if docker-compose is available
            DOCKER_COMPOSE_CMD=""
            if command -v docker-compose &> /dev/null; then
              DOCKER_COMPOSE_CMD="docker-compose"
            elif $DOCKER_CMD compose version &> /dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="$DOCKER_CMD compose"
            fi
            
            if [ -n "$DOCKER_COMPOSE_CMD" ]; then
              # Find docker-compose.yml
              DOCKER_COMPOSE_DIR=""
              if [ -f "$WORKSPACE_PATH/docker-compose.yml" ]; then
                DOCKER_COMPOSE_DIR="$WORKSPACE_PATH"
              elif [ -f "$DEPLOY_PATH/docker-compose.yml" ]; then
                DOCKER_COMPOSE_DIR="$DEPLOY_PATH"
              elif [ -f "$DEPLOY_PATH/current/docker-compose.yml" ]; then
                DOCKER_COMPOSE_DIR="$DEPLOY_PATH/current"
              fi
              
              if [ -n "$DOCKER_COMPOSE_DIR" ]; then
                cd "$DOCKER_COMPOSE_DIR"
                if ! $DOCKER_CMD ps --filter "name=investment_crm_db" --filter "status=running" --format "{{.Names}}" 2>/dev/null | grep -q "investment_crm_db"; then
                  echo "üöÄ Starting Docker services..."
                  $DOCKER_COMPOSE_CMD up -d postgres redis
                  
                  # Wait for PostgreSQL
                  RETRY_COUNT=0
                  while [ $RETRY_COUNT -lt 30 ]; do
                    if $DOCKER_CMD exec investment_crm_db pg_isready -U postgres &> /dev/null 2>&1; then
                      echo "‚úÖ PostgreSQL is ready"
                      break
                    fi
                    RETRY_COUNT=$((RETRY_COUNT + 1))
                    sleep 2
                  done
                  
                  # Wait for Redis
                  RETRY_COUNT=0
                  while [ $RETRY_COUNT -lt 30 ]; do
                    if $DOCKER_CMD exec investment_crm_redis redis-cli ping &> /dev/null 2>&1; then
                      echo "‚úÖ Redis is ready"
                      break
                    fi
                    RETRY_COUNT=$((RETRY_COUNT + 1))
                    sleep 2
                  done
                else
                  echo "‚úÖ Docker services are already running"
                fi
              fi
            fi
          fi

      - name: Run database migrations (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          cd "$RELEASE_DIR"
          
          # Generate Prisma client
          echo "üì¶ Generating Prisma client..."
          PRISMA_BIN=""
          if [ -f "node_modules/.bin/prisma" ]; then
            PRISMA_BIN="node_modules/.bin/prisma"
          elif [ -f "$RELEASE_DIR/node_modules/.bin/prisma" ]; then
            PRISMA_BIN="$RELEASE_DIR/node_modules/.bin/prisma"
          elif [ -d "node_modules/prisma" ] && [ -f "node_modules/prisma/build/index.js" ]; then
            PRISMA_BIN="node node_modules/prisma/build/index.js"
          fi
          
          if [ -n "$PRISMA_BIN" ]; then
            if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
              sudo "$PRISMA_BIN" generate
              sudo "$PRISMA_BIN" migrate deploy
            else
              "$PRISMA_BIN" generate
              "$PRISMA_BIN" migrate deploy
            fi
          else
            if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
              sudo $NPM_CMD run db:generate
              sudo $NPM_CMD exec --yes prisma migrate deploy
            else
              $NPM_CMD run db:generate
              $NPM_CMD exec --yes prisma migrate deploy
            fi
          fi
          echo "‚úÖ Database migrations completed"

      - name: Install PM2 if needed (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          echo "üîç Checking for PM2..."
          
          # Source profile to ensure PATH includes npm global bin
          [ -f /etc/profile ] && source /etc/profile
          [ -f ~/.bashrc ] && source ~/.bashrc
          [ -f ~/.profile ] && source ~/.profile
          
          # Add npm global bin to PATH if not already there
          NPM_GLOBAL_BIN=""
          if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
            NPM_GLOBAL_BIN=$(sudo -n $NPM_CMD config get prefix 2>/dev/null)/bin || \
            NPM_GLOBAL_BIN=$(sudo $NPM_CMD config get prefix 2>/dev/null)/bin || \
            NPM_GLOBAL_BIN="/usr/local/bin"
          else
            NPM_GLOBAL_BIN=$($NPM_CMD config get prefix 2>/dev/null)/bin || \
            NPM_GLOBAL_BIN="$HOME/.npm-global/bin" || \
            NPM_GLOBAL_BIN="/usr/local/bin"
          fi
          
          if [ -n "$NPM_GLOBAL_BIN" ] && [[ ":$PATH:" != *":$NPM_GLOBAL_BIN:"* ]]; then
            export PATH="$NPM_GLOBAL_BIN:$PATH"
            echo "üìÇ Added npm global bin to PATH: $NPM_GLOBAL_BIN"
          fi
          
          # Check if pm2 is installed
          if command -v pm2 &> /dev/null; then
            PM2_VERSION=$(pm2 --version 2>/dev/null || echo "unknown")
            echo "‚úÖ PM2 is already installed (version: $PM2_VERSION)"
            echo "PM2_AVAILABLE=1" >> $GITHUB_ENV
          else
            echo "üì¶ PM2 not found, installing..."
            
            # Try to install pm2 globally
            if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
              # Check if passwordless sudo is available
              if sudo -n true 2>/dev/null; then
                echo "Installing PM2 with sudo..."
                sudo $NPM_CMD install -g pm2
              else
                echo "‚ö†Ô∏è  Passwordless sudo not available, trying without sudo..."
                $NPM_CMD install -g pm2 || {
                  echo "‚ùå Failed to install PM2 without sudo"
                  echo "üí° To install PM2 manually, run:"
                  echo "   sudo $NPM_CMD install -g pm2"
                  echo "PM2_AVAILABLE=0" >> $GITHUB_ENV
                  exit 0  # Don't fail deployment if PM2 install fails
                }
              fi
            else
              $NPM_CMD install -g pm2 || {
                echo "‚ùå Failed to install PM2"
                echo "üí° To install PM2 manually, run: $NPM_CMD install -g pm2"
                echo "PM2_AVAILABLE=0" >> $GITHUB_ENV
                exit 0  # Don't fail deployment if PM2 install fails
              }
            fi
            
            # Update PATH again after installation
            if [ -n "$NPM_GLOBAL_BIN" ] && [[ ":$PATH:" != *":$NPM_GLOBAL_BIN:"* ]]; then
              export PATH="$NPM_GLOBAL_BIN:$PATH"
            fi
            
            # Verify installation
            if command -v pm2 &> /dev/null; then
              PM2_VERSION=$(pm2 --version 2>/dev/null || echo "unknown")
              echo "‚úÖ PM2 installed successfully (version: $PM2_VERSION)"
              echo "PM2_AVAILABLE=1" >> $GITHUB_ENV
            else
              # Try to find pm2 in common locations
              PM2_PATH=""
              for path in "$NPM_GLOBAL_BIN/pm2" "/usr/local/bin/pm2" "/usr/bin/pm2" "$HOME/.npm-global/bin/pm2"; do
                if [ -f "$path" ] && [ -x "$path" ]; then
                  PM2_PATH="$path"
                  echo "‚úÖ Found PM2 at: $PM2_PATH"
                  echo "PM2_AVAILABLE=1" >> $GITHUB_ENV
                  echo "PM2_PATH=$PM2_PATH" >> $GITHUB_ENV
                  break
                fi
              done
              
              if [ -z "$PM2_PATH" ]; then
                echo "‚ö†Ô∏è  PM2 installation completed but command not found in PATH"
                echo "üí° You may need to restart the shell or add npm global bin to PATH"
                echo "PM2_AVAILABLE=0" >> $GITHUB_ENV
              fi
            fi
          fi

      - name: Finalize deployment (self-hosted)
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          set +e  # Don't exit on error - we'll handle errors manually
          DEPLOY_PATH="${DEPLOY_PATH:-/var/www/investment-crm/backend}"
          
          # Create symlink to current release
          cd "$DEPLOY_PATH"
          rm -f current
          ln -s "releases/$TIMESTAMP" current
          
          # Restart application
          # Source profile to ensure PATH includes pm2
          [ -f /etc/profile ] && source /etc/profile
          [ -f ~/.bashrc ] && source ~/.bashrc
          [ -f ~/.profile ] && source ~/.profile
          
          # Initialize PM2_RUNNING
          PM2_RUNNING="0"
          
          # Use PM2_PATH if set, otherwise try command -v
          PM2_CMD=""
          echo "üîç Checking PM2 availability..."
          echo "   PM2_AVAILABLE: ${PM2_AVAILABLE:-0}"
          echo "   PM2_PATH: ${PM2_PATH:-not set}"
          
          # First, try to use PM2_PATH from environment (set in Install PM2 step)
          if [ -n "${PM2_PATH:-}" ] && [ -f "${PM2_PATH}" ]; then
            PM2_CMD="${PM2_PATH}"
            echo "‚úÖ Using PM2 from PM2_PATH: $PM2_CMD"
          # Try command -v
          elif command -v pm2 &> /dev/null; then
            PM2_CMD="pm2"
            echo "‚úÖ Found PM2 in PATH: $PM2_CMD"
            $PM2_CMD --version || echo "‚ö†Ô∏è  PM2 version check failed"
          else
            echo "‚ö†Ô∏è  PM2 command not found in PATH, searching common locations..."
            # Try to find PM2 in common locations (including npm global bin)
            NPM_GLOBAL_BIN=""
            if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
              NPM_GLOBAL_BIN=$(sudo -n $NPM_CMD config get prefix 2>/dev/null)/bin || \
              NPM_GLOBAL_BIN=$(sudo $NPM_CMD config get prefix 2>/dev/null)/bin || \
              NPM_GLOBAL_BIN="/usr/local/bin"
            else
              NPM_GLOBAL_BIN=$($NPM_CMD config get prefix 2>/dev/null)/bin || \
              NPM_GLOBAL_BIN="$HOME/.npm-global/bin" || \
              NPM_GLOBAL_BIN="/usr/local/bin"
            fi
            
            for path in "$NPM_GLOBAL_BIN/pm2" "/opt/nodejs/bin/pm2" "/usr/local/bin/pm2" "/usr/bin/pm2" "$HOME/.npm-global/bin/pm2"; do
              if [ -f "$path" ] && [ -x "$path" ]; then
                PM2_CMD="$path"
                echo "‚úÖ Found PM2 at: $PM2_CMD"
                # Save for future use
                echo "PM2_PATH=$PM2_CMD" >> $GITHUB_ENV
                break
              fi
            done
          fi
          
          # If still not found, try to find it using find command
          if [ -z "$PM2_CMD" ]; then
            echo "   Searching for PM2 binary..."
            FOUND_PM2=$(find /usr /opt /home -name pm2 -type f -executable 2>/dev/null | head -1)
            if [ -n "$FOUND_PM2" ]; then
              PM2_CMD="$FOUND_PM2"
              echo "‚úÖ Found PM2 using find: $PM2_CMD"
              echo "PM2_PATH=$PM2_CMD" >> $GITHUB_ENV
            fi
          fi
          
          if [ "${PM2_AVAILABLE:-0}" = "1" ] && [ -n "$PM2_CMD" ]; then
            echo "üîÑ Attempting to use PM2 process manager..."
            echo "   PM2 command: $PM2_CMD"
            
            # Verify PM2 binary exists and is executable
            if [ ! -f "$PM2_CMD" ]; then
              echo "‚ùå PM2 binary not found at: $PM2_CMD"
              PM2_CMD=""
            elif [ ! -x "$PM2_CMD" ]; then
              echo "‚ö†Ô∏è  PM2 binary is not executable, trying to fix permissions..."
              if chmod +x "$PM2_CMD" 2>/dev/null; then
                echo "‚úÖ Fixed PM2 permissions"
              elif sudo chmod +x "$PM2_CMD" 2>/dev/null; then
                echo "‚úÖ Fixed PM2 permissions with sudo"
              else
                echo "‚ùå Could not make PM2 executable"
                PM2_CMD=""
              fi
            fi
            
            if [ -n "$PM2_CMD" ]; then
              # Check PM2 version (this will also verify PM2 works)
              echo "   Checking PM2 version..."
              PM2_VERSION_OUTPUT=$($PM2_CMD --version 2>&1)
              PM2_VERSION_EXIT=$?
              
              if [ $PM2_VERSION_EXIT -ne 0 ]; then
                echo "‚ö†Ô∏è  PM2 version check failed: $PM2_VERSION_OUTPUT"
                echo "üí° This might be normal if PM2 daemon needs initialization"
                echo "   Trying to use PM2 anyway (daemon will start on first command)..."
              else
                echo "‚úÖ PM2 is working (version: $PM2_VERSION_OUTPUT)"
              fi
              
              # Try to use PM2 - the daemon will start automatically on first command
              echo "   Attempting to use PM2 (daemon will auto-start if needed)..."
              
              # Try to restart existing PM2 process
              echo "   Trying to restart existing PM2 process..."
              RESTART_OUTPUT=$($PM2_CMD restart investment-crm-backend 2>&1)
              RESTART_EXIT=$?
              
              if [ $RESTART_EXIT -eq 0 ]; then
                echo "‚úÖ Application restarted with PM2"
                PM2_RUNNING="1"
              # If restart fails, start a new process
              else
                echo "   Restart output: $RESTART_OUTPUT"
                echo "   Restart exit code: $RESTART_EXIT"
                echo "   Trying to start new PM2 process..."
                
                # Delete existing process if it exists in error state
                $PM2_CMD delete investment-crm-backend 2>/dev/null || echo "   No existing process to delete"
                
                # Start new process with full path and proper working directory
                echo "   Starting: $PM2_CMD start \"$DEPLOY_PATH/current/dist/index.js\" --name investment-crm-backend --cwd \"$DEPLOY_PATH/current\""
                START_OUTPUT=$($PM2_CMD start "$DEPLOY_PATH/current/dist/index.js" --name investment-crm-backend --cwd "$DEPLOY_PATH/current" 2>&1)
                START_EXIT=$?
                
                echo "   Start output: $START_OUTPUT"
                echo "   Start exit code: $START_EXIT"
                
                if [ $START_EXIT -eq 0 ]; then
                  echo "‚úÖ Application started with PM2"
                  PM2_RUNNING="1"
                else
                  echo "‚ö†Ô∏è  PM2 start command returned non-zero exit code"
                  # Check if PM2 process is actually running despite the error
                  sleep 3
                  echo "   Checking if process is running..."
                  if $PM2_CMD list 2>&1 | grep -q "investment-crm-backend"; then
                    PM2_RUNNING="1"
                    echo "‚úÖ PM2 process is running (despite error message)"
                    echo "üìã PM2 process details:"
                    $PM2_CMD list 2>&1 | grep -A 3 "investment-crm-backend" || true
                  else
                    echo "‚ùå PM2 process not found in PM2 list"
                    echo "üìã Full PM2 status:"
                    $PM2_CMD status 2>&1 || true
                    echo "üìã PM2 list:"
                    $PM2_CMD list 2>&1 || true
                    echo "üìã PM2 logs (if any):"
                    $PM2_CMD logs investment-crm-backend --lines 10 --nostream 2>&1 || true
                  fi
                fi
              fi
              
              # Final verification
              if [ "$PM2_RUNNING" = "1" ]; then
                echo "‚úÖ Verifying PM2 process is actually running..."
                sleep 1
                if $PM2_CMD list 2>&1 | grep -q "investment-crm-backend"; then
                  echo "‚úÖ PM2 process confirmed running"
                  $PM2_CMD describe investment-crm-backend 2>&1 | head -20 || true
                else
                  echo "‚ö†Ô∏è  PM2 process not found in list, resetting flag"
                  PM2_RUNNING="0"
                fi
              fi
            fi
          else
            if [ "${PM2_AVAILABLE:-0}" != "1" ]; then
              echo "‚ÑπÔ∏è  PM2 not available (PM2_AVAILABLE=0), will use manual start"
            elif [ -z "$PM2_CMD" ]; then
              echo "‚ÑπÔ∏è  PM2 command not found, will use manual start"
            fi
          fi
          
          # Try systemctl if PM2 didn't work
          if [ "$PM2_RUNNING" = "0" ] && command -v systemctl &> /dev/null; then
            echo "üîÑ Attempting to restart systemd service..."
            # Try without sudo first
            if systemctl restart investment-crm-backend 2>/dev/null; then
              echo "‚úÖ Service restarted (without sudo)"
            # Try with passwordless sudo if available
            elif sudo -n systemctl restart investment-crm-backend 2>/dev/null; then
              echo "‚úÖ Service restarted (with passwordless sudo)"
            # If systemctl exists but service doesn't, that's okay
            elif ! systemctl list-unit-files | grep -q "investment-crm-backend.service"; then
              echo "‚ÑπÔ∏è  Systemd service not configured, will start manually"
            else
              echo "‚ö†Ô∏è  Service exists but restart failed (may need passwordless sudo)"
              echo "üí° Configure passwordless sudo: sudo visudo"
              echo "   Add: $USER ALL=(ALL) NOPASSWD: /bin/systemctl restart investment-crm-backend"
            fi
          fi
          
          # Verify PM2 process is actually running
          if [ "${PM2_AVAILABLE:-0}" = "1" ] && [ -n "$PM2_CMD" ] && [ "$PM2_RUNNING" = "1" ]; then
            # Double-check that PM2 process is actually running
            if ! $PM2_CMD list 2>/dev/null | grep -q "investment-crm-backend"; then
              PM2_RUNNING="0"
              echo "‚ö†Ô∏è  PM2 process not found in PM2 list, will try manual start"
            fi
          fi
          
          # Check if application is already running
          APP_RUNNING="0"
          if pgrep -f 'node.*dist/index.js' > /dev/null 2>&1; then
            APP_RUNNING="1"
            echo "‚úÖ Application is already running"
          fi
          
          # Start application if not running
          if [ "$APP_RUNNING" = "0" ] && [ "$PM2_RUNNING" = "0" ]; then
            echo "üöÄ Starting application manually..."
            
            # Kill any existing processes
            pkill -f 'node.*dist/index.js' || true
            sleep 1
            
            # Change to the current release directory
            cd "$DEPLOY_PATH/current"
            echo "üìÇ Current directory: $(pwd)"
            
            # Verify the dist/index.js file exists
            if [ ! -f "dist/index.js" ]; then
              echo "‚ùå Error: dist/index.js not found in $DEPLOY_PATH/current"
              echo "üí° Make sure the build completed successfully"
              exit 1
            fi
            
            # Check if required files exist
            echo "üîç Checking for required files..."
            if [ ! -d "dist/config" ]; then
              echo "‚ùå Error: dist/config directory not found"
              echo "üìã Contents of dist directory:"
              ls -la dist/ || true
              exit 1
            fi
            
            if [ ! -f "dist/config/logger.js" ]; then
              echo "‚ùå Error: dist/config/logger.js not found"
              echo "üìã Contents of dist/config directory:"
              ls -la dist/config/ || true
              echo ""
              echo "üìã All files in dist:"
              find dist -type f -name "*.js" | head -20 || true
              exit 1
            fi
            
            echo "‚úÖ Required files found:"
            echo "   - dist/index.js"
            echo "   - dist/config/logger.js"
            
            # Check the import statement in the compiled code
            echo "üîç Checking import statements in dist/index.js:"
            LOGGER_IMPORT=$(grep -E "from ['\"].*config/logger" dist/index.js | head -1 || echo "")
            
            if [ -n "$LOGGER_IMPORT" ]; then
              echo "üìã Found logger import: $LOGGER_IMPORT"
              
              if echo "$LOGGER_IMPORT" | grep -qE "\.js['\"]"; then
                echo "‚úÖ Import already has .js extension"
              else
                echo "‚ö†Ô∏è  Import missing .js extension. ES modules require .js extensions."
                echo "üí° Fixing all relative imports in dist directory..."
                
                # Fix relative imports to include .js extension using sed
                echo "Fixing relative imports with sed..."
                # Fix common import patterns with sed
                find dist -name "*.js" -type f -exec sed -i "s|from './config/logger'|from './config/logger.js'|g" {} \;
                find dist -name "*.js" -type f -exec sed -i "s|from '../config/logger'|from '../config/logger.js'|g" {} \;
                find dist -name "*.js" -type f -exec sed -i 's|from "./config/logger"|from "./config/logger.js"|g' {} \;
                find dist -name "*.js" -type f -exec sed -i 's|from "../config/logger"|from "../config/logger.js"|g' {} \;
                # Fix other common relative imports (single quotes)
                find dist -name "*.js" -type f -exec sed -i "s|from '\\.\\(/[^']*\\)'|from '\\.\\1.js'|g" {} \;
                # Fix other common relative imports (double quotes)
                find dist -name "*.js" -type f -exec sed -i 's|from "\\.\\(/[^"]*\\)"|from "\\.\\1.js"|g' {} \;
                # Fix imports without quotes (less common but possible)
                find dist -name "*.js" -type f -exec sed -i 's|from \\.\\(/[^;]*\\)|from \\.\\1.js|g' {} \;
                
                echo "‚úÖ Fixed imports to include .js extensions"
                echo "üìã Updated logger import:"
                grep -E "from ['\"].*config/logger" dist/index.js | head -1 || true
              fi
            else
              echo "‚ö†Ô∏è  Could not find logger import"
              echo "üìã Sample of imports in dist/index.js:"
              grep -E "from ['\"]" dist/index.js | head -10 || true
            fi
            
            # Check if .env exists
            if [ ! -f ".env" ]; then
              echo "‚ö†Ô∏è  Warning: .env file not found in current directory"
            fi
            
            # Start the application with proper error handling
            START_LOG="$DEPLOY_PATH/current/start.log"
            if [ "$USE_SUDO_FOR_NODE" = "1" ]; then
              # Try passwordless sudo first
              if sudo -n true 2>/dev/null; then
                echo "Starting with sudo..."
                sudo nohup $NPM_CMD start > "$START_LOG" 2>&1 &
                START_PID=$!
              else
                echo "‚ö†Ô∏è  Passwordless sudo not available, trying without sudo..."
                nohup $NPM_CMD start > "$START_LOG" 2>&1 &
                START_PID=$!
              fi
            else
              nohup $NPM_CMD start > "$START_LOG" 2>&1 &
              START_PID=$!
            fi
            
            echo "üìù Application start command executed (PID: $START_PID)"
            echo "üìã Logs will be written to: $START_LOG"
            
            # Wait a bit and check if process started
            sleep 3
            
            # Check if the process is running
            if pgrep -f 'node.*dist/index.js' > /dev/null 2>&1; then
              echo "‚úÖ Application started successfully"
              # Show last few lines of log
              if [ -f "$START_LOG" ]; then
                echo "üìã Last few lines of startup log:"
                tail -5 "$START_LOG" || echo "   (log file not readable)"
              fi
            else
              echo "‚ùå Application failed to start"
              echo "üìã Checking startup log for errors:"
              if [ -f "$START_LOG" ]; then
                cat "$START_LOG" || echo "   (log file not readable)"
              else
                echo "   (log file not found)"
              fi
              echo ""
              echo "üí° Troubleshooting steps:"
              echo "   1. Check if Node.js is working: $NODE_CMD --version"
              echo "   2. Check if npm is working: $NPM_CMD --version"
              echo "   3. Try starting manually: cd $DEPLOY_PATH/current && $NPM_CMD start"
              echo "   4. Check application logs in: $DEPLOY_PATH/current"
              # Don't exit with error - deployment succeeded, just app didn't start
              echo "‚ö†Ô∏è  Deployment completed but application may need manual start"
            fi
          elif [ "$PM2_RUNNING" = "1" ]; then
            echo "‚úÖ Application is running via PM2"
            echo "üìã PM2 status:"
            $PM2_CMD list 2>&1 | grep -A 5 "investment-crm-backend" || $PM2_CMD list 2>&1 || true
            echo "üí° To manage the process: $PM2_CMD [start|stop|restart|delete] investment-crm-backend"
          else
            echo "‚ÑπÔ∏è  Application started manually (not using PM2)"
            echo "üí° To use PM2 next time, ensure PM2 is installed and accessible"
          fi
          
          # Cleanup old releases (keep last 5)
          cd "$DEPLOY_PATH/releases"
          ls -t | tail -n +6 | xargs -r rm -rf

      - name: Show deployment method
        run: |
          if [ "$USE_SELF_HOSTED" = "true" ]; then
            echo "‚úÖ Using self-hosted runner deployment"
            echo "   The GitHub-hosted deployment step will be skipped"
            echo "   All deployment steps are handled by self-hosted runner steps above"
          else
            echo "‚úÖ Using GitHub-hosted runner deployment"
            echo "   The self-hosted deployment steps were skipped"
            echo "   Deployment will proceed via SSH"
          fi

      - name: Deploy to server (GitHub-hosted)
        if: env.USE_SELF_HOSTED != 'true'
        run: |
          DEPLOY_PATH="${DEPLOY_PATH:-/var/www/investment-crm/backend}"
          
          # GitHub-hosted runner: deploy via SSH
          echo "üöÄ Deploying via SSH..."
          
          # Create deployment directory on server
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
            mkdir -p $DEPLOY_PATH/releases
            mkdir -p $DEPLOY_PATH/shared
          "
          
          # Upload build artifact
          scp backend-deploy.tar.gz ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:$DEPLOY_PATH/releases/
          
          # Upload .env file if provided
          if [ -f backend-env.txt ]; then
            scp backend-env.txt ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:$DEPLOY_PATH/releases/backend-env.txt
          fi
          
          # Extract and deploy on server
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
              cd $DEPLOY_PATH/releases
            TIMESTAMP=\$(date +%Y%m%d%H%M%S)
            mkdir -p \$TIMESTAMP
            tar -xzf backend-deploy.tar.gz -C \$TIMESTAMP
            rm backend-deploy.tar.gz
            
            # Install production dependencies
            cd \$TIMESTAMP
              ${NPM_CMD:-npm} ci --production
            
            # Create .env file from secret or use shared .env
            if [ -f ../backend-env.txt ]; then
              cp ../backend-env.txt .env
              rm ../backend-env.txt
              echo '‚úÖ Created .env file from BACKEND_ENV_FILE secret'
              elif [ -f $DEPLOY_PATH/shared/.env ]; then
                cp $DEPLOY_PATH/shared/.env .env
              echo '‚úÖ Using shared .env file'
            else
              echo '‚ùå Error: No .env file found. Deployment cannot continue.'
              exit 1
            fi
            
            # Validate required environment variables
            echo 'üîç Validating environment variables...'
            source .env
              if [ -z \"\$DATABASE_URL\" ]; then
              echo '‚ùå Error: DATABASE_URL is not set in .env file'
              exit 1
            fi
              if [ -z \"\$JWT_SECRET\" ]; then
              echo '‚ùå Error: JWT_SECRET is not set in .env file'
              exit 1
            fi
            echo '‚úÖ Required environment variables are set'
            
              # Test database connectivity
            echo 'üóÑÔ∏è  Testing database connectivity...'
            if command -v psql &> /dev/null; then
                DB_CONN=\$(echo \$DATABASE_URL | sed -E 's|postgresql://([^:]+):([^@]+)@([^:]+):([^/]+)/(.+)|host=\3 port=\4 user=\1 password=\2 dbname=\5|')
                if psql \"\$DB_CONN\" -c 'SELECT 1' &> /dev/null; then
                echo '‚úÖ Database connection successful'
              else
                echo '‚ö†Ô∏è  Could not verify database connection with psql, but continuing...'
              fi
            else
              echo '‚ö†Ô∏è  psql not available, skipping database connectivity test'
            fi
            
            # Generate Prisma client
            echo 'üì¶ Generating Prisma client...'
              # Use the local Prisma binary directly
              if [ -f 'node_modules/.bin/prisma' ]; then
                node_modules/.bin/prisma generate || {
              echo '‚ùå Error: Failed to generate Prisma client'
              exit 1
            }
              elif [ -f './node_modules/.bin/prisma' ]; then
                ./node_modules/.bin/prisma generate || {
                  echo '‚ùå Error: Failed to generate Prisma client'
                  exit 1
                }
              elif command -v npx &> /dev/null; then
                npx prisma generate || {
                  echo '‚ùå Error: Failed to generate Prisma client'
                  exit 1
                }
              else
                ${NPM_CMD:-npm} run db:generate || {
              echo '‚ùå Error: Failed to generate Prisma client'
              exit 1
            }
              fi
            
            # Run database migrations
            echo 'üîÑ Running database migrations...'
              if [ -f 'node_modules/.bin/prisma' ]; then
                node_modules/.bin/prisma migrate deploy || {
                  echo '‚ùå Error: Database migration failed'
                  exit 1
                }
              elif [ -f './node_modules/.bin/prisma' ]; then
                ./node_modules/.bin/prisma migrate deploy || {
                  echo '‚ùå Error: Database migration failed'
                  exit 1
                }
              elif command -v npx &> /dev/null; then
            npx prisma migrate deploy || {
              echo '‚ùå Error: Database migration failed'
              exit 1
            }
              else
                ${NPM_CMD:-npm} run db:generate || {
                  echo '‚ùå Error: Database migration failed'
                  exit 1
                }
              fi
            echo '‚úÖ Database migrations completed'
            
            # Create symlink to current release
              cd $DEPLOY_PATH
            rm -f current
            ln -s releases/\$TIMESTAMP current
            
              # Restart application
            if command -v pm2 &> /dev/null; then
              pm2 restart investment-crm-backend || pm2 start current/dist/index.js --name investment-crm-backend
            elif command -v systemctl &> /dev/null; then
              sudo systemctl restart investment-crm-backend || echo 'Service not configured'
            else
              # Fallback: kill existing process and start new one
              pkill -f 'node.*dist/index.js' || true
              cd current
                nohup ${NPM_CMD:-npm} start > /dev/null 2>&1 &
            fi
            
            # Cleanup old releases (keep last 5)
            cd releases
            ls -t | tail -n +6 | xargs -r rm -rf
          "

      - name: Health check
        if: env.USE_SELF_HOSTED == 'true'
        run: |
          echo "üè• Performing health check..."
          # Wait a bit for the app to start
          sleep 10
          
          # Try multiple URLs
          HEALTH_URL="${BACKEND_URL:-http://localhost:3001}"
          if [ -z "$BACKEND_URL" ]; then
            # Try common ports
            for port in 3001 3000 8080; do
              if curl -f "http://localhost:$port/health" 2>/dev/null; then
                echo "‚úÖ Health check passed on port $port"
                exit 0
              fi
            done
            echo "‚ö†Ô∏è  Health check failed on all ports, but deployment may still be successful"
            echo "üí° Check if the application is running: ps aux | grep node"
            exit 0  # Don't fail the deployment if health check fails
          else
            if curl -f "$HEALTH_URL/health" 2>/dev/null; then
              echo "‚úÖ Health check passed"
            else
              echo "‚ö†Ô∏è  Health check failed, but deployment may still be successful"
              echo "üí° Verify the application manually at: $HEALTH_URL/health"
              exit 0  # Don't fail the deployment if health check fails
            fi
          fi


