name: Backend Deployment

on:
  push:
    branches:
      - main
      - master
    paths:
      - 'backend/**'
      - 'backend/.github/workflows/backend-deploy.yml'
  pull_request:
    branches:
      - main
      - master
    paths:
      - 'backend/**'
      - 'backend/.github/workflows/backend-deploy.yml'
  workflow_dispatch:

env:
  NODE_VERSION: '20'

jobs:
  test:
    name: Test Backend
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: investment_crm_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        id: setup-node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: package-lock.json
        continue-on-error: true

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npm run db:generate
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/investment_crm_test

      - name: Run database migrations
        run: npx prisma migrate deploy
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/investment_crm_test

      - name: Run linter
        run: npm run lint

      - name: Type check
        run: npm run type-check

      - name: Run tests
        run: npm test
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/investment_crm_test
          NODE_ENV: test
          JWT_SECRET: test-secret-key

  build:
    name: Build Backend
    runs-on: ubuntu-latest
    needs: test
    if: |
      always() &&
      (needs.test.result == 'success' || needs.test.result == 'skipped') &&
      ((github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')) ||
       (github.event_name == 'workflow_dispatch' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')))
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify package-lock.json exists
        run: |
          if [ ! -f package-lock.json ]; then
            echo "Warning: package-lock.json not found, cache will be skipped"
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npm run db:generate

      - name: Build application
        run: npm run build

      - name: Create deployment package
        run: |
          mkdir -p deploy
          cp -r dist deploy/
          cp -r prisma deploy/
          cp package.json deploy/
          cp package-lock.json deploy/
          tar -czf backend-deploy.tar.gz -C deploy .
          rm -rf deploy

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: backend-build
          path: backend-deploy.tar.gz
          retention-days: 1

  pre-deploy-check:
    name: Pre-Deployment Validation
    runs-on: ${{ vars.USE_SELF_HOSTED_RUNNER == 'true' && 'self-hosted' || 'ubuntu-latest' }}
    needs: build
    if: |
      (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')) ||
      (github.event_name == 'workflow_dispatch' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'))
    
    steps:
      - name: Setup SSH (for GitHub-hosted runners only)
        if: vars.USE_SELF_HOSTED_RUNNER != 'true'
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts (for GitHub-hosted runners only)
        if: vars.USE_SELF_HOSTED_RUNNER != 'true'
        run: |
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Validate server prerequisites
        run: |
          echo "ðŸ” Validating server prerequisites..."
          
          # For self-hosted runners, we're already on the server
          if [ "${{ vars.USE_SELF_HOSTED_RUNNER }}" = "true" ]; then
            echo "âœ… Running on self-hosted runner - no SSH needed"
            
            # Source common profile files to ensure PATH is set correctly
            [ -f /etc/profile ] && source /etc/profile
            [ -f ~/.bashrc ] && source ~/.bashrc
            [ -f ~/.bash_profile ] && source ~/.bash_profile
            [ -f ~/.profile ] && source ~/.profile
            
            # Add common Node.js paths to PATH
            export PATH="/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin:$PATH"
            export PATH="$HOME/.nvm/versions/node/*/bin:$PATH"
            export PATH="/opt/nodejs/bin:$PATH"
            
            # Check Node.js version (try multiple methods, including checking root's PATH)
            echo "ðŸ“¦ Checking Node.js installation..."
            echo "Current user: $(whoami)"
            echo "Current PATH: $PATH"
            
            NODE_CMD=""
            # First try standard locations (check /opt/nodejs/bin first since it's in PATH)
            if [ -f /opt/nodejs/bin/node ] && [ -x /opt/nodejs/bin/node ]; then
              NODE_CMD="/opt/nodejs/bin/node"
              echo "Found node in /opt/nodejs/bin"
            elif command -v node &> /dev/null; then
              NODE_CMD="node"
            elif [ -f /usr/local/bin/node ]; then
              NODE_CMD="/usr/local/bin/node"
            elif [ -f /usr/bin/node ]; then
              NODE_CMD="/usr/bin/node"
            fi
            
            # Check root's nvm installation
            if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
              echo "Checking root's nvm installation..."
              if [ -d /root/.nvm/versions/node ]; then
                NODE_CMD=$(find /root/.nvm/versions/node -name node -type f -executable 2>/dev/null | sort -V | tail -1)
              fi
            fi
            
            # Check current user's nvm
            if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
              if [ -d "$HOME/.nvm/versions/node" ]; then
                NODE_CMD=$(find "$HOME/.nvm/versions/node" -name node -type f -executable 2>/dev/null | sort -V | tail -1)
              fi
            fi
            
            # Try to find node in common locations (including root's home and bin directories)
            if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
              echo "Searching for node in common locations..."
              NODE_CMD=$(find /usr/local/bin /usr/bin /opt /root/.nvm /root/.local /root/bin -name node -type f -executable 2>/dev/null | head -1)
            fi
            
            # If still not found, try using sudo to check root's PATH (without -n to allow password prompt if needed)
            if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
              echo "Trying to find node using root's PATH..."
              # Try without -n first (in case passwordless sudo is configured)
              ROOT_NODE=$(sudo sh -c 'command -v node' 2>/dev/null || echo "")
              if [ -z "$ROOT_NODE" ]; then
                # Try with -n (non-interactive, requires passwordless sudo)
                ROOT_NODE=$(sudo -n sh -c 'command -v node' 2>/dev/null || echo "")
              fi
              if [ -n "$ROOT_NODE" ] && [ -f "$ROOT_NODE" ]; then
                NODE_CMD="$ROOT_NODE"
                echo "Found node via root's PATH: $NODE_CMD"
              fi
            fi
            
            # Last resort: try to read root's .bashrc or .profile to find NVM_DIR
            if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
              echo "Checking root's shell configuration for Node.js path..."
              if [ -f /root/.bashrc ]; then
                ROOT_NVM_DIR=$(grep -o 'NVM_DIR="[^"]*"' /root/.bashrc 2>/dev/null | cut -d'"' -f2 || echo "")
                if [ -n "$ROOT_NVM_DIR" ] && [ -d "$ROOT_NVM_DIR/versions/node" ]; then
                  NODE_CMD=$(find "$ROOT_NVM_DIR/versions/node" -name node -type f -executable 2>/dev/null | sort -V | tail -1)
                fi
              fi
            fi
            
            # If still not found, try to create symlinks automatically (if sudo is available)
            if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
              echo "Attempting to find and create symlinks automatically..."
              # Try to get root's node path and create symlink
              ROOT_NODE_PATH=$(sudo sh -c 'which node' 2>/dev/null || echo "")
              if [ -n "$ROOT_NODE_PATH" ] && [ -f "$ROOT_NODE_PATH" ]; then
                echo "Found Node.js at: $ROOT_NODE_PATH"
                echo "Creating symlink in /usr/local/bin..."
                sudo ln -sf "$ROOT_NODE_PATH" /usr/local/bin/node 2>/dev/null || echo "Failed to create symlink (may need manual setup)"
                if [ -f /usr/local/bin/node ]; then
                  NODE_CMD="/usr/local/bin/node"
                  echo "âœ… Symlink created successfully"
                fi
              fi
            fi
            
            if [ -z "$NODE_CMD" ] || [ ! -f "$NODE_CMD" ]; then
              echo "âŒ Node.js is not installed on the server or not accessible"
              echo "Current PATH: $PATH"
              echo "Current user: $(whoami)"
              echo ""
              echo "Trying to find node..."
              which node 2>/dev/null || echo "node not in PATH"
              echo ""
              echo "Searching in common locations:"
              find /usr /opt -name node -type f 2>/dev/null | head -10 || echo "node not found in /usr or /opt"
              echo ""
              echo "Checking if we can access root's directories:"
              ls -la /root/.nvm 2>/dev/null | head -5 || echo "Cannot access /root/.nvm"
              echo ""
              echo "ðŸ’¡ Solution: Run these commands on your server as root:"
              echo "   NODE_PATH=\$(which node)"
              echo "   NPM_PATH=\$(which npm)"
              echo "   sudo ln -sf \$NODE_PATH /usr/local/bin/node"
              echo "   sudo ln -sf \$NPM_PATH /usr/local/bin/npm"
              echo "   sudo chmod +x /usr/local/bin/node /usr/local/bin/npm"
              echo ""
              echo "Or configure passwordless sudo for the runner user:"
              echo "   sudo visudo"
              echo "   Add: signin-fil-investments-api ALL=(ALL) NOPASSWD: ALL"
              exit 1
            fi
            
            # Verify we can execute it
            if [ ! -x "$NODE_CMD" ]; then
              echo "âš ï¸  Node.js found but not executable, checking permissions..."
              ls -la "$NODE_CMD" || echo "Cannot check permissions"
              # Try to make it executable
              if sudo chmod +x "$NODE_CMD" 2>/dev/null; then
                echo "âœ… Made Node.js executable"
              elif sudo -n test -x "$NODE_CMD" 2>/dev/null; then
                echo "Node.js requires sudo to execute"
              else
                echo "âŒ Node.js found at $NODE_CMD but cannot be executed"
                echo "Try: sudo chmod +x $NODE_CMD"
                exit 1
              fi
            fi
            
            NODE_VERSION=$($NODE_CMD --version 2>/dev/null || sudo $NODE_CMD --version 2>/dev/null || echo "unknown")
            echo "âœ… Node.js found at: $NODE_CMD"
            echo "âœ… Node.js version: $NODE_VERSION"
            
            # Export NODE_CMD for use in later steps
            echo "NODE_CMD=$NODE_CMD" >> $GITHUB_ENV
            
            # Check npm (try multiple methods, including checking root's PATH)
            echo "ðŸ“¦ Checking npm installation..."
            NPM_CMD=""
            # First try standard locations (check /opt/nodejs/bin first since it's in PATH)
            if [ -f /opt/nodejs/bin/npm ] && [ -x /opt/nodejs/bin/npm ]; then
              NPM_CMD="/opt/nodejs/bin/npm"
              echo "Found npm in /opt/nodejs/bin"
            elif command -v npm &> /dev/null; then
              NPM_CMD="npm"
            elif [ -f /usr/local/bin/npm ]; then
              NPM_CMD="/usr/local/bin/npm"
            elif [ -f /usr/bin/npm ]; then
              NPM_CMD="/usr/bin/npm"
            fi
            
            # Check root's nvm installation (use same directory as node if found)
            if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
              if [ -n "$NODE_CMD" ] && [ -d "$(dirname "$NODE_CMD")" ]; then
                # npm should be in the same directory as node
                NPM_CMD="$(dirname "$NODE_CMD")/npm"
                if [ ! -f "$NPM_CMD" ]; then
                  NPM_CMD=""
                fi
              elif [ -d /root/.nvm/versions/node ]; then
                NPM_CMD=$(find /root/.nvm/versions/node -name npm -type f -executable 2>/dev/null | sort -V | tail -1)
              fi
            fi
            
            # Check current user's nvm
            if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
              if [ -d "$HOME/.nvm/versions/node" ]; then
                NPM_CMD=$(find "$HOME/.nvm/versions/node" -name npm -type f -executable 2>/dev/null | sort -V | tail -1)
              fi
            fi
            
            # Try to find npm in common locations
            if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
              echo "Searching for npm in common locations..."
              NPM_CMD=$(find /usr/local/bin /usr/bin /opt /root/.nvm /root/.local /root/bin -name npm -type f -executable 2>/dev/null | head -1)
            fi
            
            # If still not found, try using sudo to check root's PATH
            if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
              echo "Trying to find npm using root's PATH..."
              # Try without -n first
              ROOT_NPM=$(sudo sh -c 'command -v npm' 2>/dev/null || echo "")
              if [ -z "$ROOT_NPM" ]; then
                # Try with -n
                ROOT_NPM=$(sudo -n sh -c 'command -v npm' 2>/dev/null || echo "")
              fi
              if [ -n "$ROOT_NPM" ] && [ -f "$ROOT_NPM" ]; then
                NPM_CMD="$ROOT_NPM"
                echo "Found npm via root's PATH: $NPM_CMD"
              fi
            fi
            
            # Last resort: try to read root's .bashrc or .profile to find NVM_DIR
            if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
              if [ -f /root/.bashrc ]; then
                ROOT_NVM_DIR=$(grep -o 'NVM_DIR="[^"]*"' /root/.bashrc 2>/dev/null | cut -d'"' -f2 || echo "")
                if [ -n "$ROOT_NVM_DIR" ] && [ -d "$ROOT_NVM_DIR/versions/node" ]; then
                  NPM_CMD=$(find "$ROOT_NVM_DIR/versions/node" -name npm -type f -executable 2>/dev/null | sort -V | tail -1)
                fi
              fi
            fi
            
            # If still not found, try to create symlinks automatically (if sudo is available)
            if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
              echo "Attempting to find and create symlinks automatically..."
              # Try multiple methods to find root's npm
              ROOT_NPM_PATH=""
              # Method 1: Try sudo which
              ROOT_NPM_PATH=$(sudo sh -c 'which npm' 2>/dev/null || echo "")
              # Method 2: Use same directory as node if found
              if [ -z "$ROOT_NPM_PATH" ] && [ -n "$NODE_CMD" ] && [ -f "$NODE_CMD" ]; then
                ROOT_NPM_PATH="$(dirname "$NODE_CMD")/npm"
                if [ ! -f "$ROOT_NPM_PATH" ]; then
                  ROOT_NPM_PATH=""
                fi
              fi
              # Method 3: Check if /opt/nodejs/bin/npm exists
              if [ -z "$ROOT_NPM_PATH" ] && [ -f /opt/nodejs/bin/npm ]; then
                ROOT_NPM_PATH="/opt/nodejs/bin/npm"
              fi
              
              if [ -n "$ROOT_NPM_PATH" ] && [ -f "$ROOT_NPM_PATH" ]; then
                echo "Found npm at: $ROOT_NPM_PATH"
                echo "Creating symlink in /usr/local/bin..."
                sudo ln -sf "$ROOT_NPM_PATH" /usr/local/bin/npm 2>/dev/null || echo "Failed to create symlink (may need manual setup)"
                if [ -f /usr/local/bin/npm ] && [ -x /usr/local/bin/npm ]; then
                  NPM_CMD="/usr/local/bin/npm"
                  echo "âœ… Symlink created successfully"
                elif [ -f /opt/nodejs/bin/npm ]; then
                  # If /opt/nodejs/bin/npm exists, try to use it directly
                  NPM_CMD="/opt/nodejs/bin/npm"
                  echo "âœ… Using /opt/nodejs/bin/npm directly"
                fi
              fi
            fi
            
            if [ -z "$NPM_CMD" ] || [ ! -f "$NPM_CMD" ]; then
              echo "âŒ npm is not installed on the server or not accessible"
              echo "Trying to find npm..."
              which npm 2>/dev/null || echo "npm not in PATH"
              echo ""
              echo "Searching in common locations:"
              find /usr /opt -name npm -type f 2>/dev/null | head -10 || echo "npm not found in /usr or /opt"
              echo ""
              echo "ðŸ’¡ Solution: Run these commands on your server as root:"
              echo "   NODE_PATH=\$(which node)"
              echo "   NPM_PATH=\$(which npm)"
              echo "   sudo ln -sf \$NODE_PATH /usr/local/bin/node"
              echo "   sudo ln -sf \$NPM_PATH /usr/local/bin/npm"
              echo "   sudo chmod +x /usr/local/bin/node /usr/local/bin/npm"
              echo ""
              echo "Or configure passwordless sudo for the runner user:"
              echo "   sudo visudo"
              echo "   Add: signin-fil-investments-api ALL=(ALL) NOPASSWD: ALL"
              exit 1
            fi
            
            # Verify we can execute it
            if [ ! -x "$NPM_CMD" ]; then
              echo "âš ï¸  npm found but not executable, checking permissions..."
              ls -la "$NPM_CMD" || echo "Cannot check permissions"
              # Try to make it executable
              if sudo chmod +x "$NPM_CMD" 2>/dev/null; then
                echo "âœ… Made npm executable"
              elif sudo -n test -x "$NPM_CMD" 2>/dev/null; then
                echo "npm requires sudo to execute"
              else
                echo "âŒ npm found at $NPM_CMD but cannot be executed"
                echo "Try: sudo chmod +x $NPM_CMD"
                exit 1
              fi
            fi
            
            NPM_VERSION=$($NPM_CMD --version 2>/dev/null || sudo $NPM_CMD --version 2>/dev/null || echo "unknown")
            echo "âœ… npm found at: $NPM_CMD"
            echo "âœ… npm version: $NPM_VERSION"
            
            # Export NPM_CMD for use in later steps
            echo "NPM_CMD=$NPM_CMD" >> $GITHUB_ENV
            
            # Check deployment directory
            echo "ðŸ“ Checking deployment directory..."
            DEPLOY_PATH="${{ secrets.BACKEND_DEPLOY_PATH || '/var/www/investment-crm/backend' }}"
            if [ ! -d "$DEPLOY_PATH" ]; then
              echo "Creating deployment directory..."
              mkdir -p "$DEPLOY_PATH/releases"
              mkdir -p "$DEPLOY_PATH/shared"
            fi
            
            if [ ! -w "$DEPLOY_PATH" ]; then
              echo "âŒ Deployment directory is not writable"
              exit 1
            fi
            echo "âœ… Deployment directory is ready"
            
            # Check .env file
            echo "ðŸ” Checking environment configuration..."
            if [ -n "${{ secrets.BACKEND_ENV_FILE }}" ]; then
              echo "âœ… BACKEND_ENV_FILE secret is set"
            elif [ -f "$DEPLOY_PATH/shared/.env" ]; then
              echo "âœ… Shared .env file found"
            else
              echo "âŒ No .env file found. Please set BACKEND_ENV_FILE secret or create shared/.env file"
              exit 1
            fi
            
            # Check PostgreSQL client
            echo "ðŸ—„ï¸  Checking database prerequisites..."
            if command -v psql &> /dev/null; then
              echo "âœ… PostgreSQL client is installed"
            else
              echo "âš ï¸  PostgreSQL client (psql) not found. Database migrations may require manual setup."
            fi
            
            # Check process manager
            echo "âš™ï¸  Checking process manager..."
            if command -v pm2 &> /dev/null; then
              echo "âœ… Process manager found: pm2"
            elif command -v systemctl &> /dev/null; then
              echo "âœ… Process manager found: systemd"
            else
              echo "âš ï¸  No process manager found. Application will run in background mode."
            fi
            
            # Check port availability
            echo "ðŸ”Œ Checking port availability..."
            if command -v netstat &> /dev/null; then
              PORT_CHECK=$(netstat -tuln | grep ':3001' || echo 'available')
            elif command -v ss &> /dev/null; then
              PORT_CHECK=$(ss -tuln | grep ':3001' || echo 'available')
            else
              PORT_CHECK='unknown'
            fi
            if [ "$PORT_CHECK" != "available" ] && [ "$PORT_CHECK" != "unknown" ]; then
              echo "âš ï¸  Port 3001 may be in use. Ensure the application can bind to this port."
            else
              echo "âœ… Port 3001 appears to be available"
            fi
          else
            # For GitHub-hosted runners, use SSH
            echo "ðŸ“¡ Testing SSH connection..."
            ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "echo 'SSH connection successful'" || {
              echo "âŒ SSH connection failed"
              exit 1
            }
            
            # Check Node.js version
            echo "ðŸ“¦ Checking Node.js installation..."
            NODE_VERSION=$(ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "node --version 2>/dev/null || echo 'not_installed'")
            if [ "$NODE_VERSION" = "not_installed" ]; then
              echo "âŒ Node.js is not installed on the server"
              exit 1
            fi
            echo "âœ… Node.js version: $NODE_VERSION"
            
            # Check npm
            echo "ðŸ“¦ Checking npm installation..."
            NPM_VERSION=$(ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "npm --version 2>/dev/null || echo 'not_installed'")
            if [ "$NPM_VERSION" = "not_installed" ]; then
              echo "âŒ npm is not installed on the server"
              exit 1
            fi
            echo "âœ… npm version: $NPM_VERSION"
            
            # Check deployment directory
            echo "ðŸ“ Checking deployment directory..."
            ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
              if [ ! -d '${{ secrets.BACKEND_DEPLOY_PATH }}' ]; then
                echo 'Creating deployment directory...'
                mkdir -p '${{ secrets.BACKEND_DEPLOY_PATH }}/releases'
                mkdir -p '${{ secrets.BACKEND_DEPLOY_PATH }}/shared'
              fi
              
              if [ ! -w '${{ secrets.BACKEND_DEPLOY_PATH }}' ]; then
                echo 'âŒ Deployment directory is not writable'
                exit 1
              fi
              echo 'âœ… Deployment directory is ready'
            " || exit 1
            
            # Check .env file
            echo "ðŸ” Checking environment configuration..."
            if [ -n "${{ secrets.BACKEND_ENV_FILE }}" ]; then
              echo "âœ… BACKEND_ENV_FILE secret is set"
            else
              echo "âš ï¸  BACKEND_ENV_FILE secret not set, checking for shared .env file..."
              ENV_EXISTS=$(ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
                if [ -f '${{ secrets.BACKEND_DEPLOY_PATH }}/shared/.env' ]; then
                  echo 'exists'
                else
                  echo 'missing'
                fi
              ")
              if [ "$ENV_EXISTS" = "missing" ]; then
                echo "âŒ No .env file found. Please set BACKEND_ENV_FILE secret or create shared/.env file"
                exit 1
              fi
              echo "âœ… Shared .env file found"
            fi
            
            # Check database prerequisites
            echo "ðŸ—„ï¸  Checking database prerequisites..."
            ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
              if command -v psql &> /dev/null; then
                echo 'âœ… PostgreSQL client is installed'
              else
                echo 'âš ï¸  PostgreSQL client (psql) not found. Database migrations may require manual setup.'
              fi
            " || true
            
            # Check process manager
            echo "âš™ï¸  Checking process manager..."
            PM_MANAGER=$(ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
              if command -v pm2 &> /dev/null; then
                echo 'pm2'
              elif command -v systemctl &> /dev/null; then
                echo 'systemd'
              else
                echo 'none'
              fi
            ")
            if [ "$PM_MANAGER" = "none" ]; then
              echo "âš ï¸  No process manager found. Application will run in background mode."
            else
              echo "âœ… Process manager found: $PM_MANAGER"
            fi
            
            # Check port availability
            echo "ðŸ”Œ Checking port availability..."
            PORT_CHECK=$(ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
              if command -v netstat &> /dev/null; then
                netstat -tuln | grep ':3001' || echo 'available'
              elif command -v ss &> /dev/null; then
                ss -tuln | grep ':3001' || echo 'available'
              else
                echo 'unknown'
              fi
            ")
            if [ "$PORT_CHECK" != "available" ] && [ "$PORT_CHECK" != "unknown" ]; then
              echo "âš ï¸  Port 3001 may be in use. Ensure the application can bind to this port."
            else
              echo "âœ… Port 3001 appears to be available"
            fi
          fi
          
          echo "âœ… All prerequisites validated successfully!"

  deploy:
    name: Deploy Backend to Server
    runs-on: ${{ vars.USE_SELF_HOSTED_RUNNER == 'true' && 'self-hosted' || 'ubuntu-latest' }}
    needs: [build, pre-deploy-check]
    if: |
      (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')) ||
      (github.event_name == 'workflow_dispatch' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'))
    environment:
      name: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: backend-build
          path: .

      - name: Setup SSH (for GitHub-hosted runners only)
        if: vars.USE_SELF_HOSTED_RUNNER != 'true'
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts (for GitHub-hosted runners only)
        if: vars.USE_SELF_HOSTED_RUNNER != 'true'
        run: |
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Create .env file from secret
        run: |
          if [ -n "${{ secrets.BACKEND_ENV_FILE }}" ]; then
            echo "${{ secrets.BACKEND_ENV_FILE }}" > backend-env.txt
          fi

      - name: Setup PATH for self-hosted runner
        if: vars.USE_SELF_HOSTED_RUNNER == 'true'
        run: |
          # Source common profile files to ensure PATH is set correctly
          [ -f /etc/profile ] && source /etc/profile
          [ -f ~/.bashrc ] && source ~/.bashrc
          [ -f ~/.bash_profile ] && source ~/.bash_profile
          [ -f ~/.profile ] && source ~/.profile
          
          # Add common Node.js paths to PATH
          export PATH="/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin:$PATH"
          export PATH="$HOME/.nvm/versions/node/*/bin:$PATH"
          export PATH="/opt/nodejs/bin:$PATH"
          
          # Find Node.js and npm if not in PATH (including root's installation)
          if ! command -v node &> /dev/null; then
            NODE_CMD=$(find /usr/local /usr /opt /root -name node -type f -executable 2>/dev/null | head -1)
            if [ -z "$NODE_CMD" ]; then
              # Try using root's PATH
              ROOT_NODE=$(sudo -n sh -c 'command -v node' 2>/dev/null || echo "")
              if [ -n "$ROOT_NODE" ] && [ -f "$ROOT_NODE" ]; then
                NODE_CMD="$ROOT_NODE"
              fi
            fi
            if [ -n "$NODE_CMD" ]; then
              echo "NODE_CMD=$NODE_CMD" >> $GITHUB_ENV
              echo "PATH=$(dirname $NODE_CMD):$PATH" >> $GITHUB_ENV
            fi
          fi
          
          if ! command -v npm &> /dev/null; then
            NPM_CMD=$(find /usr/local /usr /opt /root -name npm -type f -executable 2>/dev/null | head -1)
            if [ -z "$NPM_CMD" ]; then
              # Try using root's PATH
              ROOT_NPM=$(sudo -n sh -c 'command -v npm' 2>/dev/null || echo "")
              if [ -n "$ROOT_NPM" ] && [ -f "$ROOT_NPM" ]; then
                NPM_CMD="$ROOT_NPM"
              fi
            fi
            if [ -n "$NPM_CMD" ]; then
              echo "NPM_CMD=$NPM_CMD" >> $GITHUB_ENV
              echo "PATH=$(dirname $NPM_CMD):$PATH" >> $GITHUB_ENV
            fi
          fi
          
          # Verify Node.js and npm are accessible
          echo "Node.js: $(command -v node || echo 'not found')"
          echo "npm: $(command -v npm || echo 'not found')"
          if [ -n "$NODE_CMD" ]; then
            $NODE_CMD --version || echo "Node.js version check failed"
          fi
          if [ -n "$NPM_CMD" ]; then
            $NPM_CMD --version || echo "npm version check failed"
          fi

      - name: Deploy to server
        run: |
          # Set deployment path
          DEPLOY_PATH="${{ secrets.BACKEND_DEPLOY_PATH || '/var/www/investment-crm/backend' }}"
          
          if [ "${{ vars.USE_SELF_HOSTED_RUNNER }}" = "true" ]; then
            # Self-hosted runner: deploy directly
            echo "ðŸš€ Deploying on self-hosted runner..."
            
            # Source profile to ensure PATH is correct
            [ -f /etc/profile ] && source /etc/profile
            [ -f ~/.bashrc ] && source ~/.bashrc
            [ -f ~/.profile ] && source ~/.profile
            
            # Use NPM_CMD from environment or find it (including root's installation)
            if [ -z "$NPM_CMD" ]; then
              if command -v npm &> /dev/null; then
                NPM_CMD="npm"
              else
                NPM_CMD=$(find /usr/local /usr /opt /root -name npm -type f -executable 2>/dev/null | head -1)
                if [ -z "$NPM_CMD" ]; then
                  # Try using root's PATH
                  ROOT_NPM=$(sudo -n sh -c 'command -v npm' 2>/dev/null || echo "")
                  if [ -n "$ROOT_NPM" ] && [ -f "$ROOT_NPM" ]; then
                    NPM_CMD="$ROOT_NPM"
                  fi
                fi
              fi
            fi
            
            if [ -z "$NPM_CMD" ]; then
              echo "âŒ Error: npm not found"
              echo "ðŸ’¡ Tip: Run this on your server as root to fix:"
              echo "   sudo ln -s \$(sudo which npm) /usr/local/bin/npm"
              echo "   sudo ln -s \$(sudo which node) /usr/local/bin/node"
              exit 1
            fi
            
            echo "Using npm at: $NPM_CMD"
            
            # Create deployment directory
            mkdir -p "$DEPLOY_PATH/releases"
            mkdir -p "$DEPLOY_PATH/shared"
            
            # Move build artifact
            mv backend-deploy.tar.gz "$DEPLOY_PATH/releases/"
            
            # Extract and deploy
            cd "$DEPLOY_PATH/releases"
            TIMESTAMP=$(date +%Y%m%d%H%M%S)
            mkdir -p "$TIMESTAMP"
            tar -xzf backend-deploy.tar.gz -C "$TIMESTAMP"
            rm backend-deploy.tar.gz
            
            # Install production dependencies
            cd "$TIMESTAMP"
            $NPM_CMD ci --production
            
            # Create .env file from secret or use shared .env
            if [ -f "${{ github.workspace }}/backend-env.txt" ]; then
              cp "${{ github.workspace }}/backend-env.txt" .env
              rm "${{ github.workspace }}/backend-env.txt"
              echo "âœ… Created .env file from BACKEND_ENV_FILE secret"
            elif [ -f "$DEPLOY_PATH/shared/.env" ]; then
              cp "$DEPLOY_PATH/shared/.env" .env
              echo "âœ… Using shared .env file"
            else
              echo "âŒ Error: No .env file found. Deployment cannot continue."
              exit 1
            fi
            
            # Validate required environment variables
            echo "ðŸ” Validating environment variables..."
            set -a
            source .env
            set +a
            if [ -z "$DATABASE_URL" ]; then
              echo "âŒ Error: DATABASE_URL is not set in .env file"
              exit 1
            fi
            if [ -z "$JWT_SECRET" ]; then
              echo "âŒ Error: JWT_SECRET is not set in .env file"
              exit 1
            fi
            echo "âœ… Required environment variables are set"
            
            # Test database connectivity
            echo "ðŸ—„ï¸  Testing database connectivity..."
            if command -v psql &> /dev/null; then
              DB_CONN=$(echo "$DATABASE_URL" | sed -E 's|postgresql://([^:]+):([^@]+)@([^:]+):([^/]+)/(.+)|host=\3 port=\4 user=\1 password=\2 dbname=\5|')
              if psql "$DB_CONN" -c 'SELECT 1' &> /dev/null; then
                echo "âœ… Database connection successful"
              else
                echo "âš ï¸  Could not verify database connection with psql, but continuing..."
              fi
            else
              echo "âš ï¸  psql not available, skipping database connectivity test"
            fi
            
            # Generate Prisma client
            echo "ðŸ“¦ Generating Prisma client..."
            $NPM_CMD run db:generate || {
              echo "âŒ Error: Failed to generate Prisma client"
              exit 1
            }
            
            # Run database migrations
            echo "ðŸ”„ Running database migrations..."
            $NPM_CMD exec prisma migrate deploy || {
              echo "âŒ Error: Database migration failed"
              exit 1
            }
            echo "âœ… Database migrations completed"
            
            # Create symlink to current release
            cd "$DEPLOY_PATH"
            rm -f current
            ln -s "releases/$TIMESTAMP" current
            
            # Restart application
            if command -v pm2 &> /dev/null; then
              pm2 restart investment-crm-backend || pm2 start current/dist/index.js --name investment-crm-backend
            elif command -v systemctl &> /dev/null; then
              sudo systemctl restart investment-crm-backend || echo "Service not configured"
            else
              # Fallback: kill existing process and start new one
              pkill -f 'node.*dist/index.js' || true
              cd current
              nohup $NPM_CMD start > /dev/null 2>&1 &
            fi
            
            # Cleanup old releases (keep last 5)
            cd "$DEPLOY_PATH/releases"
            ls -t | tail -n +6 | xargs -r rm -rf
          else
            # GitHub-hosted runner: deploy via SSH
            echo "ðŸš€ Deploying via SSH..."
            
            # Create deployment directory on server
            ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
              mkdir -p $DEPLOY_PATH/releases
              mkdir -p $DEPLOY_PATH/shared
            "
            
            # Upload build artifact
            scp backend-deploy.tar.gz ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:$DEPLOY_PATH/releases/
            
            # Upload .env file if provided
            if [ -f backend-env.txt ]; then
              scp backend-env.txt ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:$DEPLOY_PATH/releases/backend-env.txt
            fi
            
            # Extract and deploy on server
            ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
              cd $DEPLOY_PATH/releases
              TIMESTAMP=\$(date +%Y%m%d%H%M%S)
              mkdir -p \$TIMESTAMP
              tar -xzf backend-deploy.tar.gz -C \$TIMESTAMP
              rm backend-deploy.tar.gz
              
              # Install production dependencies
              cd \$TIMESTAMP
              npm ci --production
              
              # Create .env file from secret or use shared .env
              if [ -f ../backend-env.txt ]; then
                cp ../backend-env.txt .env
                rm ../backend-env.txt
                echo 'âœ… Created .env file from BACKEND_ENV_FILE secret'
              elif [ -f $DEPLOY_PATH/shared/.env ]; then
                cp $DEPLOY_PATH/shared/.env .env
                echo 'âœ… Using shared .env file'
              else
                echo 'âŒ Error: No .env file found. Deployment cannot continue.'
                exit 1
              fi
              
              # Validate required environment variables
              echo 'ðŸ” Validating environment variables...'
              source .env
              if [ -z \"\$DATABASE_URL\" ]; then
                echo 'âŒ Error: DATABASE_URL is not set in .env file'
                exit 1
              fi
              if [ -z \"\$JWT_SECRET\" ]; then
                echo 'âŒ Error: JWT_SECRET is not set in .env file'
                exit 1
              fi
              echo 'âœ… Required environment variables are set'
              
              # Test database connectivity
              echo 'ðŸ—„ï¸  Testing database connectivity...'
              if command -v psql &> /dev/null; then
                DB_CONN=\$(echo \$DATABASE_URL | sed -E 's|postgresql://([^:]+):([^@]+)@([^:]+):([^/]+)/(.+)|host=\3 port=\4 user=\1 password=\2 dbname=\5|')
                if psql \"\$DB_CONN\" -c 'SELECT 1' &> /dev/null; then
                  echo 'âœ… Database connection successful'
                else
                  echo 'âš ï¸  Could not verify database connection with psql, but continuing...'
                fi
              else
                echo 'âš ï¸  psql not available, skipping database connectivity test'
              fi
              
              # Generate Prisma client
              echo 'ðŸ“¦ Generating Prisma client...'
              npm run db:generate || {
                echo 'âŒ Error: Failed to generate Prisma client'
                exit 1
              }
              
              # Run database migrations
              echo 'ðŸ”„ Running database migrations...'
              npx prisma migrate deploy || {
                echo 'âŒ Error: Database migration failed'
                exit 1
              }
              echo 'âœ… Database migrations completed'
              
              # Create symlink to current release
              cd $DEPLOY_PATH
              rm -f current
              ln -s releases/\$TIMESTAMP current
              
              # Restart application
              if command -v pm2 &> /dev/null; then
                pm2 restart investment-crm-backend || pm2 start current/dist/index.js --name investment-crm-backend
              elif command -v systemctl &> /dev/null; then
                sudo systemctl restart investment-crm-backend || echo 'Service not configured'
              else
                # Fallback: kill existing process and start new one
                pkill -f 'node.*dist/index.js' || true
                cd current
                nohup npm start > /dev/null 2>&1 &
              fi
              
              # Cleanup old releases (keep last 5)
              cd releases
              ls -t | tail -n +6 | xargs -r rm -rf
            "
          fi

      - name: Health check
        run: |
          sleep 10
          curl -f ${{ secrets.BACKEND_URL || 'http://localhost:3001' }}/health || exit 1


